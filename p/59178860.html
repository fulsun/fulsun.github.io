<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java多线程简介 | 凉月の博客</title><meta name="author" content="凉月"><meta name="copyright" content="凉月"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一个进程可由多个线程组成，多个线程共享进程内资源，多个线程可在单核处理器上并发执行，在多核处理器并行执行。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java多线程简介">
<meta property="og:url" content="https://fulsun.github.io/p/59178860">
<meta property="og:site_name" content="凉月の博客">
<meta property="og:description" content="一个进程可由多个线程组成，多个线程共享进程内资源，多个线程可在单核处理器上并发执行，在多核处理器并行执行。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fulsun.github.io/medias/featureimages/003.jpg">
<meta property="article:published_time" content="2018-08-23T10:22:50.000Z">
<meta property="article:modified_time" content="2024-10-17T07:06:55.366Z">
<meta property="article:author" content="凉月">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fulsun.github.io/medias/featureimages/003.jpg"><link rel="shortcut icon" href="/medias/favicon.png"><link rel="canonical" href="https://fulsun.github.io/p/59178860"><link rel="preconnect" href="//unpkg.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"至上次更新后的","messageNext":"天,文章内容可能已过时。"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 凉月","link":"链接: ","source":"来源: 凉月の博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://unpkg.com/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java多线程简介',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-17 07:06:55'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/avatar.jpg" onerror="onerror=null;src='/medias/detail/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-heartbeat"></i><span> 我的</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> 联系</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user-circle"></i><span> 博主</span></a></li><li><a class="site-page child" href="/contact"><i class="fa-fw fas fa-comments"></i><span> 留言</span></a></li><li><a class="site-page child" href="/journal"><i class="fa-fw fas fa-cogs"></i><span> 日志</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> JS动画</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/snake/"><i class="fa-fw fas fa-gamepad"></i><span> 贪吃蛇</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/medias/featureimages/003.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="凉月の博客"><span class="site-name">凉月の博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-heartbeat"></i><span> 我的</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> 联系</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user-circle"></i><span> 博主</span></a></li><li><a class="site-page child" href="/contact"><i class="fa-fw fas fa-comments"></i><span> 留言</span></a></li><li><a class="site-page child" href="/journal"><i class="fa-fw fas fa-cogs"></i><span> 日志</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> JS动画</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/snake/"><i class="fa-fw fas fa-gamepad"></i><span> 贪吃蛇</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java多线程简介</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2018-08-23T10:22:50.000Z" title="发表于 2018-08-23 10:22:50">2018-08-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-17T07:06:55.366Z" title="更新于 2024-10-17 07:06:55">2024-10-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JavaSE/">JavaSE</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">24.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>82分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java多线程简介"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><span id="more"></span>

<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul>
<li>要想说线程，首先必须得聊聊进程，因为线程是依赖于进程存在的。</li>
</ul>
<h3 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h3><ul>
<li>进程是程序的一次<strong>执行过程</strong>，是系统运行程序的基本单位，打开 Windows 的任务管理器就可以看到很多进程。</li>
<li>概念：<strong>进程就是正在运行的程序，是系统进行资源分配和调用的独立单位</strong>。每一个进程都有它自己的内存空间和系统资源。</li>
<li>多进程：每个进程都拥有自己独立的资源，多个进程可在单核处理器上并发执行，在多核处理器上并行执行。</li>
</ul>
<h3 id="多进程的意义"><a href="#多进程的意义" class="headerlink" title="多进程的意义"></a>多进程的意义</h3><ul>
<li>单进程计算机只能做一件事情。而我们现在的计算机都可以一边玩游戏(游戏进程),一边听音乐(音乐进程)，所以我们常见的操作系统都是多进程操作系统。比如：Windows，Mac和Linux等，能在同一个时间段内执行多个任务。</li>
<li>对于单核计算机来讲，游戏进程和音乐进程是同时运行的吗?不是。</li>
<li>因为CPU在某个时间点上只能做一件事情，计算机是在游戏进程和音乐进程间做着频繁切换，且切换速度很快，</li>
<li>所以，我们感觉游戏和音乐在同时进行，其实并不是同时执行的。多进程的作用不是提高执行速度，而是提高CPU的使用率。</li>
</ul>
<h3 id="进程状态有哪些"><a href="#进程状态有哪些" class="headerlink" title="进程状态有哪些"></a>进程状态有哪些</h3><ul>
<li>进程状态有哪些<ul>
<li>运行状态：进程正在处理机上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态。</li>
<li>就绪状态：进程已处于准备运行的状态，即进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行。</li>
<li>阻塞状态，又称等待状态：进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入&#x2F;输出完成。即使处理机空闲，该进程也不能运行。</li>
</ul>
</li>
</ul>
<h3 id="进程状态转换"><a href="#进程状态转换" class="headerlink" title="进程状态转换"></a>进程状态转换</h3><ul>
<li><strong>注意区别就绪状态和等待状态：</strong><ul>
<li>就绪状态是指进程仅缺少处理机，只要获得处理机资源就立即执行；而等待状态是指进程需要其他资源（除了处理机）或等待某一事件。</li>
</ul>
</li>
<li><strong>就绪状态 -&gt; 运行状态：</strong><ul>
<li>处于就绪状态的进程被调度后，获得处理机资源（分派处理机时间片），于是进程由就绪状态转换为运行状态。</li>
</ul>
</li>
<li><strong>运行状态 -&gt; 就绪状态：</strong><ul>
<li>处于运行状态的进程在时间片用完后，不得不让出处理机，从而进程由运行状态转换为就绪状态。此外，在可剥夺的操作系统中，当有更高优先级的进程就绪时，调度程度将正执行的进程转换为就绪状态，让更高优先级的进程执行。</li>
</ul>
</li>
<li><strong>运行状态 -&gt; 阻塞状态：</strong><ul>
<li>当进程请求某一资源（如外设）的使用和分配或等待某一事件的发生（如I&#x2F;O操作的完成）时，它就从运行状态转换为阻塞状态。进程以系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式。</li>
</ul>
</li>
<li><strong>阻塞状态 -&gt; 就绪状态：</strong><ul>
<li>当进程等待的事件到来时，如I&#x2F;O操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞状态转换为就绪状态。</li>
</ul>
</li>
</ul>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><ul>
<li>进程通信是指进程之间的信息交换。PV操作是低级通信方式，髙级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方法主要有以下三个类。</li>
<li><strong>共享存储</strong><ul>
<li>在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写&#x2F;读操作实现进程之间的信息交换。在对共享空间进行写&#x2F;读操作时，需要使用同步互斥工具（如 P操作、V操作），对共享空间的写&#x2F;读进行控制。共享存储又分为两种：低级方式的共享是基于数据结构的共享；高级方式则是基于存储区的共享。操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读&#x2F;写指令完成。</li>
<li>需要注意的是，用户进程空间一般都是独立的，要想让两个用户进程共享空间必须通过特殊的系统调用实现，而进程内的线程是自然共享进程空间的。</li>
</ul>
</li>
<li><strong>消息传递</strong><ul>
<li>在消息传递系统中，进程间的数据交换是以格式化的消息(Message)为单位的。若通信的进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方法实现进程通信。进程通过系统提供的发送消息和接收消息两个原语进行数据交换。</li>
<li><ol>
<li>直接通信方式：发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。</li>
</ol>
</li>
<li><ol start="2">
<li>间接通信方式：发送进程把消息发送到某个中间实体中，接收进程从中间实体中取得消息。这种中间实体一般称为信箱，这种通信方式又称为信箱通信方式。该通信方式广泛应用于计算机网络中，相应的通信系统称为电子邮件系统。</li>
</ol>
</li>
</ul>
</li>
<li><strong>管道通信</strong><ul>
<li>管道通信是消息传递的一种特殊方式。所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入（写）管道；而接收管道输出的接收进程（即读进程），则从管道中接收（读）数据。为了协调双方的通信，管道机制必须提供以下三方面的协调能力：互斥、同步和确定对方的存在。</li>
</ul>
</li>
</ul>
<h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><ul>
<li>多进程虽然提高了系统资源利用率和吞吐量，但是由于进程的异步性可能造成系统的混乱。进程同步的任务就是对多个相关进程在执行顺序上进行协调，使并发执行的多个进程之间可以有效的共享资源和相互合作，保证程序执行的可再现性</li>
<li>同步机制需要遵循的原则：<ul>
<li>1.空闲让进：当没有进程处于临界区的时候，应该许可其他进程进入临界区的申请</li>
<li>2.忙则等待：当前如果有进程处于临界区，如果有其他进程申请进入，则必须等待，保证对临界区的互斥访问</li>
<li>3.有限等待：对要求访问临界资源的进程，需要在有限时间内进入临界区，防止出现死等</li>
<li>4.让权等待：当进程无法进入临界区的时候，需要释放处理机，边陷入忙等</li>
</ul>
</li>
<li>经典的进程同步问题：生产者-消费者问题；哲学家进餐问题；读者-写者问题</li>
<li>同步的解决方案：管程，信号量。</li>
</ul>
<h3 id="用户态和核心态"><a href="#用户态和核心态" class="headerlink" title="用户态和核心态"></a>用户态和核心态</h3><ul>
<li><img src= "/medias/detail/load.gif" data-lazy-src="/p/59178860/10261aedb33c35be8bef840031c6c99f.png"></li>
<li><strong>当程序运行在3级特权级上时，就可以称之为运行在用户态</strong>，因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；反之，<strong>当程序运行在级特权级上时，就可以称之为运行在内核态。</strong></li>
<li>虽然用户态下和内核态下工作的程序有很多差别，<strong>但最重要的差别就在于特权级的不同，即权力的不同。</strong> 运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。</li>
<li>当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态。</li>
<li><strong>用户态切换到内核态的3种方式</strong><ul>
<li><ol>
<li>系统调用：这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</li>
</ol>
</li>
<li><ol start="2">
<li>异常：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</li>
</ol>
</li>
<li><ol start="3">
<li>外围设备的中断：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="进程死锁"><a href="#进程死锁" class="headerlink" title="进程死锁"></a>进程死锁</h3><ul>
<li>死锁是指多个进程在运行过程中，因为争夺资源而造成的一种僵局，如果没有外力推进，处于僵局中的进程就无法继续执行。</li>
<li><strong>死锁原因：</strong><ul>
<li>1.竞争资源：请求同一有限资源的进程数多于可用资源数</li>
<li>2.进程推进顺序非法：进程执行中，请求和释放资源顺序不合理，如资源等待链</li>
</ul>
</li>
<li><strong>死锁产生的必要条件：</strong><ul>
<li>1.互斥条件:进程对所分配的资源进行排他性的使用</li>
<li>2.请求和保持条件：进程被阻塞的时候并不释放锁申请到的资源</li>
<li>3.不可剥夺条件：进程对于已经申请到的资源在使用完成之前不可以被剥夺</li>
<li>4.环路等待条件：发生死锁的时候存在的一个 进程-资源 环形等待链</li>
</ul>
</li>
<li><strong>死锁处理：</strong><ul>
<li>预防死锁：破坏产生死锁的4个必要条件中的一个或者多个；实现起来比较简单，但是如果限制过于严格会降低系统资源利用率以及吞吐量</li>
<li>避免死锁：在资源的动态分配中，防止系统进入不安全状态(可能产生死锁的状态)-如银行家算法</li>
<li>检测死锁：允许系统运行过程中产生死锁，在死锁发生之后，采用一定的算法进行检测，并确定与死锁相关的资源和进程，采取相关方法清除检测到的死锁。实现难度大</li>
<li>解除死锁：与死锁检测配合，将系统从死锁中解脱出来（撤销进程或者剥夺资源）。对检测到的和死锁相关的进程以及资源，通过撤销或者挂起的方式，释放一些资源并将其分配给处于阻塞状态的进程，使其转变为就绪态。实现难度大</li>
</ul>
</li>
</ul>
<h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><ul>
<li><strong>先来先服务调度算法FCFS：</strong> 既可以作为作业调度算法也可以作为进程调度算法；按作业或者进程到达的先后顺序依次调度；因此对于长作业比较有利；</li>
<li><strong>短作业优先调度算法SJF：</strong> 作业调度算法，算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行；缺点：不利于长作业；未考虑作业的重要性；运行时间是预估的，并不靠谱 ；</li>
<li><strong>高响应比算法HRN：</strong> 响应比&#x3D;(等待时间+要求服务时间)&#x2F;要求服务时间；</li>
<li><strong>时间片轮转调度RR：</strong> 按到达的先后对进程放入队列中，然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环 ;</li>
<li><strong>多级反馈队列调度算法：</strong> 目前公认较好的调度算法；设置多个就绪队列并为每个队列设置不同的优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短，进程到达之后按FCFS放入第一个队列，如果调度执行后没有完成，那么放到第二个队列尾部等待调度，如果第二次调度仍然没有完成，放入第三队列尾部……只有当前一个队列为空的时候才会去调度下一个队列的进程。</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul>
<li>在一个进程内部又可以执行多个任务，而这每一个任务我们就可以看成是一个线程。是程序使用CPU的基本单位。</li>
<li>线程与进程相似，但线程是一个比进程更小的执行单位，一个进程在其执行的过程中可能产生多个线程。</li>
<li>多线程：一个进程可由多个线程组成，多个线程共享进程内资源，多个线程可在单核处理器上并发执行，在多核处理器并行执行。</li>
</ul>
<h3 id="多线程有什么意义"><a href="#多线程有什么意义" class="headerlink" title="多线程有什么意义"></a>多线程有什么意义</h3><ul>
<li>多线程的作用不是提高执行速度，而是为了提高应用程序的使用率。</li>
<li>那么怎么理解这个问题呢?我们程序在运行的使用,都是在抢CPU的时间片(执行权),如果是多线程的程序,那么在抢到CPU的执行权的概率应该比较单线程程序抢到的概率要大.那么也就是说,<strong>CPU在多线程程序中执行的时间要比单线程多,所以就提高了程序的使用率</strong>.但是即使是多线程程序,那么他们中的哪个线程能抢占到CPU的资源呢,这个是不确定的,所以多线程具有随机性.</li>
</ul>
<h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><ul>
<li>并行是<strong>逻辑</strong>上同时发生，指在某一个时间内同时运行多个程序。在同一时刻多个任务同时执行，或者说是在同一时刻可以执行多条程序指令，<strong>多核</strong>处理器才可以做到。<ul>
<li>在多核处理器上，并发和并行同时存在，处理器上的每个核同一时刻同时执行多个任务，每个核在很短的时间段内又同时执行多个任务，对多任务粗略划分是多个进程，对进程划分可能又是多个线程。</li>
<li>同一时刻，处理器的每个核只能运行一个进程中的一个线程中的一条指令（Intel 的超线程技术，如双核四线程，四核八线程，处理器的线程（硬件上）和进程中的线程（软件上）不是一个概念，这个所谓的超线程技术也并不能达到真正的多核效果，只是提高了处理器的吞吐量核利用率）。</li>
</ul>
</li>
<li>并发是<strong>物理</strong>上同时发生，指在某一个时间点同时运行多个程序。在一段时间内多个任务同时执行，或者说是在一段很短的时间内可以执行多条程序指令，微观上看起来好像是可以同时运行多个进程，<strong>单核</strong>处理器就可以做到。</li>
</ul>
<h3 id="Java程序运行原理"><a href="#Java程序运行原理" class="headerlink" title="Java程序运行原理"></a>Java程序运行原理</h3><ul>
<li>Java命令会启动java虚拟机，启动JVM，等于启动了一个应用程序，也就是启动了一个进程。</li>
<li>该进程会自动启动一个 “主线程” ，然后主线程去调用某个类的 main 方法。所以 main方法运行在主线程中。</li>
</ul>
<h3 id="JVM的启动是多线程的吗"><a href="#JVM的启动是多线程的吗" class="headerlink" title="JVM的启动是多线程的吗"></a>JVM的启动是多线程的吗</h3><ul>
<li>JVM启动至少启动了垃圾回收线程和主线程，所以是多线程的。</li>
</ul>
<h2 id="进程与线程区别"><a href="#进程与线程区别" class="headerlink" title="进程与线程区别"></a>进程与线程区别</h2><h3 id="概念区别"><a href="#概念区别" class="headerlink" title="概念区别"></a>概念区别</h3><ul>
<li><strong>进程：</strong> 进程是进程实体的运行过程，是<strong>系统进行资源分配和调度的一个独立单位</strong>（具有动态、并发、独立、异步的特性，以及就绪、执行、阻塞3种状态）；引入进程是为了使多个程序可以并发的执行，以提高系统的资源利用率和吞吐量。</li>
<li><strong>线程：</strong> 是比进程更小的<strong>可独立运行的基本单位</strong>，可以看做是轻量级的进程（具有轻型实体，独立调度分派单位，可并发执行，共享进程资源等属性）；引入目的是为了减少程序在并发执行过程中的开销，使OS的并发效率更高。</li>
</ul>
<h3 id="调度区别"><a href="#调度区别" class="headerlink" title="调度区别"></a>调度区别</h3><ul>
<li>调度方面：在引入线程的OS中，线程是独立的调度和分派单位，而进程作为资源的拥有单位(相当于把未引入线程的传统OS中的进程的两个属性分开了)。</li>
<li>由于线程不拥有资源，因此可以显著的提高并发度以及减少切换开销。</li>
</ul>
<h3 id="并发行区别"><a href="#并发行区别" class="headerlink" title="并发行区别"></a>并发行区别</h3><ul>
<li>并发性：引入了线程的OS中，进程间可以并发，而且一个进程内部的多个线程之间也是可以并发的，这就使OS具有更好的并发性，有效的提高了系统资源利用率和吞吐量。</li>
</ul>
<h3 id="拥有资源对比"><a href="#拥有资源对比" class="headerlink" title="拥有资源对比"></a>拥有资源对比</h3><ul>
<li>拥有资源：无论OS是否支持线程，进程都是基本的资源拥有单位，线程只拥有很少的基本的资源，但是线程可以访问所隶属的进程的资源（进程的代码段，数据段和所拥有的系统资源如fd）</li>
</ul>
<h3 id="系统开销对比"><a href="#系统开销对比" class="headerlink" title="系统开销对比"></a>系统开销对比</h3><ul>
<li>系统开销：创建或者撤销进程的时候，系统要为之创建或回收PCB，系统资源等，切换时也需要保存和恢复CPU环境。</li>
<li>而线程的切换只需要保存和恢复少量的寄存器，不涉及存储器管理方面的工作，所以开销较小。此外，统一进程中的多个线程由于共享地址空间，所以通信同步等都比较方便。</li>
</ul>
<h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><ul>
<li><p>创建步骤如下</p>
<ul>
<li>定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。</li>
<li>创建Thread子类的实例，即创建了线程对象。</li>
<li>调用线程对象的start()方法来启动该线程。</li>
</ul>
</li>
<li><p>代码如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">第一种方式的步骤:</span></span><br><span class="line"><span class="comment">1: 定义一个类,让该类去继承Thread类</span></span><br><span class="line"><span class="comment">2: 重写run方法</span></span><br><span class="line"><span class="comment">3: 创建该类的对象</span></span><br><span class="line"><span class="comment">4: 启动线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>() ;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>() ;</span><br><span class="line">        <span class="comment">// 启动线程: 需要使用start方法启动线程, 如果我们在这里调用的是run方法,那么我们只是把该方法作为普通方法进行执行</span></span><br><span class="line">        <span class="comment">//		t1.run() ;</span></span><br><span class="line">        <span class="comment">//		t1.run() ;</span></span><br><span class="line">        t1.start() ;		<span class="comment">// 告诉jvm开启一个线程调用run方法</span></span><br><span class="line">        <span class="comment">// t1.start() ;		// 一个线程只能被启动一次</span></span><br><span class="line">        t2.start() ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; <span class="number">1000</span> ; x++) &#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="通过Runnable接口"><a href="#通过Runnable接口" class="headerlink" title="通过Runnable接口"></a>通过Runnable接口</h3><ul>
<li><p>创建步骤如下</p>
<ul>
<li>定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li>
<li>创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</li>
<li>调用线程对象的start()方法来启动该线程。</li>
</ul>
</li>
<li><p>代码如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">实现多线程的第二中方式步骤:</span></span><br><span class="line"><span class="comment">1: 定义一个类,让该类去实现Runnable接口</span></span><br><span class="line"><span class="comment">2: 重写run方法</span></span><br><span class="line"><span class="comment">3: 创建定义的类的对象</span></span><br><span class="line"><span class="comment">4: 创建Thread的对象吧第三步创建的对象作为参数传递进来</span></span><br><span class="line"><span class="comment">5: 启动线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建定义的类的对象</span></span><br><span class="line">    <span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>() ;</span><br><span class="line">    <span class="comment">// 创建Thread的对象吧第三步创建的对象作为参数传递进来</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mt , <span class="string">&quot;张三&quot;</span>) ;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mt , <span class="string">&quot;李四&quot;</span>) ;</span><br><span class="line">    <span class="comment">// 启动线程</span></span><br><span class="line">    t1.start() ;</span><br><span class="line">    t2.start() ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; <span class="number">1000</span> ; x++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&quot;</span> + x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="通过Callable和Future"><a href="#通过Callable和Future" class="headerlink" title="通过Callable和Future"></a>通过Callable和Future</h3><ul>
<li><p><strong>Callable基础介绍</strong></p>
<ul>
<li><p>Runnable 从 JDK1.0 开始就有了，Callable 是在 JDK1.5 增加的。它们的主要区别是 Callable 的 call() 方法<strong>可以返回值和抛出异常</strong>，而 Runnable 的 run() 方法没有这些功能。Callable 可以返回装载有计算结果的 Future 对象。</p>
</li>
<li><p>通过对比两个接口得到这样的结论</p>
<ul>
<li>Callable 接口下的方法是 call()，Runnable 接口的方法是 run()；</li>
<li>Callable 的任务执行后可返回值，而 Runnable 的任务是不能返回值的；</li>
<li>call() 方法可以抛出异常，run()方法不可以的；</li>
<li>运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过 Future 对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>创建步骤如下所示</p>
<ul>
<li>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</li>
<li>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。</li>
<li>使用FutureTask对象作为Thread对象的target创建并启动新线程。</li>
<li>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值，调用get()方法会阻塞线程。</li>
</ul>
</li>
<li><p>代码如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CallableThread</span> <span class="variable">ctt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CallableThread</span>();</span><br><span class="line">        FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(ctt);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 的循环变量i的值&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(ft, <span class="string">&quot;有返回值的线程&quot;</span>).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程的返回值：&quot;</span> + ft.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="三种创建线程区别"><a href="#三种创建线程区别" class="headerlink" title="三种创建线程区别"></a>三种创建线程区别</h3><ul>
<li><p>采用实现Runnable、Callable接口的方式创见多线程时</p>
<ul>
<li>优势是：<ul>
<li>线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。</li>
<li>在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</li>
</ul>
</li>
<li>劣势是：<ul>
<li>编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。</li>
</ul>
</li>
</ul>
</li>
<li><p>使用继承Thread类的方式创建多线程时</p>
<ul>
<li>优势是：<ul>
<li>编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。</li>
</ul>
</li>
<li>劣势是：<ul>
<li>线程类已经继承了Thread类，所以不能再继承其他父类。</li>
</ul>
</li>
</ul>
</li>
<li><p>Runnable和Callable区别</p>
<ul>
<li>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</li>
<li>这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future&#x2F;FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。</li>
</ul>
</li>
</ul>
<h3 id="run方法的作用"><a href="#run方法的作用" class="headerlink" title="run方法的作用"></a>run方法的作用</h3><ul>
<li><strong>为什么要重写run方法</strong><ul>
<li>可以在定义的类中,定义多个方法,而方法中的代码并不是所有的都需要线程来进行执行;如果我们想让某一个段代码被线程,那么我们只需要将那一段代码放在run方法中。那么也就是说<strong>run方法中封装的都是要被线程执行的代码</strong> ;</li>
</ul>
</li>
<li>run方法中的代码的特点:<ul>
<li>封装的都是一些比较耗时的代码</li>
</ul>
</li>
</ul>
<h3 id="start和run区别"><a href="#start和run区别" class="headerlink" title="start和run区别"></a>start和run区别</h3><ul>
<li>线程中start和run方法有什么区别？<ul>
<li>为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？这是一个非常经典的java多线程面试问题。</li>
<li>当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码。但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码。</li>
</ul>
</li>
</ul>
<h3 id="为何不能重复start"><a href="#为何不能重复start" class="headerlink" title="为何不能重复start"></a>为何不能重复start</h3><ul>
<li><p>如下所示，可以发现即使多次调用start方法，线程只会被执行一次。那么这个究竟是怎么做到的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>() ;</span><br><span class="line">        <span class="comment">// 启动线程: 需要使用start方法启动线程, 如果我们在这里调用的是run方法,那么我们只是把该方法作为普通方法进行执行</span></span><br><span class="line">        <span class="comment">// t1.run() ;</span></span><br><span class="line">        t1.start() ;		<span class="comment">// 告诉jvm开启一个线程调用run方法</span></span><br><span class="line">        <span class="comment">// t1.start() ;		// 一个线程只能被启动一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小杨逗比&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalThreadStateException</span><br><span class="line">	at java.lang.Thread.start(Thread.java:<span class="number">708</span>)</span><br><span class="line">	at top.fulsun.TestThread02.main(TestThread02.java:<span class="number">10</span>) <span class="comment">// 第二次调用start()的位置报错</span></span><br><span class="line">小杨逗比</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后查看一下start方法的源码，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Android-changed: throw if &#x27;started&#x27; is true</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span> || started)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">    group.add(<span class="built_in">this</span>);</span><br><span class="line">    started = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        nativeCreate(<span class="built_in">this</span>, stackSize, daemon);</span><br><span class="line">        started = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">              it will be passed up the call stack */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个线程多次start会出现什么情况？</p>
<ul>
<li>会直接抛出异常 IllegalThreadStateException</li>
</ul>
</li>
</ul>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p><img src= "/medias/detail/load.gif" data-lazy-src="/p/59178860/b35c94cf1fc0b3450d1328b5a679185b.jpg"></p>
<p>咱们先来瞅瞅源码定义的状态（为了突出重点，我把注释都去掉了）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line"> NEW,</span><br><span class="line"> RUNNABLE,</span><br><span class="line"> BLOCKED,</span><br><span class="line"> WAITING,</span><br><span class="line"> TIMED_WAITING,</span><br><span class="line"> TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能够清楚的看到，在源码中能够清楚的看到，在源码中定义了 6 种线程状态。</p>
<ul>
<li><p>NEW 到 RUNNABLE ，应该是挺容易理解的，就是 thread 调用了 start 方法</p>
<ul>
<li>Java 刚创建出来的 Thread 对象就是 NEW 状态，创建 Thread 对象主要有两种方法，一种是继承 Thread 对象，重写 run() 方法，一种是实现 Runnable 接口，重写 run() 方法，并将该实现类作为创建 Thread 对象的参数</li>
<li>NEW 只是说，这个线程在编程语言层面创建了，在操作系统层面还没有创建，那当然就不会被操作系统调度了对不对，就更谈不上执行了</li>
<li>所以 Java 线程如果想要执行的话，就必须转换到 RUNNABLE 状态，也就是 thread 调用 start 方法</li>
</ul>
</li>
<li><p>RUNNABLE 与 BLOCKED ，如果线程<strong>等待 synchronized 的隐式锁</strong>时，就会从 RUNNABLE 状态转到 BLOCKED 状态。因为 synchronized 修饰的方法&#x2F;代码块同一时刻只允许一个线程执行，所以其他线程就只能等待了呗，当等待的线程获得 synchronized 隐式锁时，就会从 BLOCKED 状态转到 RUNNABLE 状态</p>
</li>
<li><p>在这里有没有个疑问？就是线程在 wait 一个条件发生时，在操作系统层面线程会转到 waiting 状态，那么在 JVM 层面呢？在 JVM 层面， Java 线程状态是不会发生变化的。也就是这个时候 Java 线程的状态依然是 RUNNABLE 状态</p>
</li>
<li><p>RUNNABLE 与 WAITING 状态转换</p>
<ul>
<li><p>有三种情况会触发 RUNNABLE 和 WAITING 之间的转换：</p>
<ul>
<li>场景一：在 synchronized 代码块中调用 <code>object.wait()</code> 方法</li>
<li>场景二：处于 RUNNABLE 状态的线程调用<code>thread.join()</code>方法等待某个线程运行完成。例如thread1中有一行代码是<code>thread2.join()</code>则执行这行代码后thread1会从RUNNABLE 状态转换成 WAITING 状态，直到thread2执行完成以后，thread1才会从 WAITING 状态再次回到 RUNNABLE 状态。</li>
<li>场景三：调用<code>LockSupport.park()</code>方法，会让当前线程从RUNNABLE 转换为 WAITING。当某个线程调用了<code>LockSupport.unpark(thread)</code>时，thread方法就会从WAITING状态转换成RUNNABLE状态。</li>
</ul>
</li>
</ul>
</li>
<li><p>RUNNABLE 与 TIMED_WAITING 状态转换</p>
<ul>
<li><p>仔细观察下会发现， TIMED_WAITING 与 WAITING 相比，就是多了超时参数，毕竟 TIMED_WAITING 是有时限等待嘛</p>
</li>
<li><p>有四种场景可以使得线程从 RUNNABLE 状态转换到 TIMED_WAITING 状态：</p>
<ul>
<li>场景一：<code>Object.wait(long timeout)</code></li>
<li>场景二：<code>Thread.join(long timeout)</code></li>
<li>场景三：<code>LockSupport.parkUntil(long deadline)</code> （还有一个park型方法，这里不列举了）</li>
<li>场景四：<code>Thread.sleep(long timeout)</code></li>
</ul>
<p>可以看出，这四种场景的前三种都是上面提到的函数的带时间参数的形式，最后一个是我们最直接可以想到的sleep。</p>
</li>
</ul>
</li>
<li><p>RUNNABLE 到 TERMINATED ，这个过程比较好理解，线程执行完 run() 方法之后，就自动到 TERMINATED 状态了，当然了如果在执行 run() 方法过程中有异常抛出，也会导致线程终止</p>
<ul>
<li>强制中断 run() 方法的执行，怎么办呢?是使用 stop() 方法还是 interrupt() 方法呢？正确的姿势是调用 interrupt() 方法</li>
<li>stop() 方法会真的杀死线程，不给线程一点儿喘息的机会，如果被杀死的线程持有 synchronized 隐式锁，那就再也不会释放掉这个锁了，接下来的线程也就没办法获得 synchronized 隐式锁，是不是特别危险？同样 suspend() 和 resume() 这两个方法也是不建议使用</li>
<li>interrupt() 方法相比于 stop() 方法就温柔很多，它只是通知线程后续的操作可以不用去执行了，线程可以选择执行现在就不执行，当然也可以选择再执行一段时间后再停止，或者我就不听你的，非要执行完，都没关系， interrupt() 只是通知一下你而已。就比如你要做火车去一个地方，突然通知你这个火车晚点了，你可以选择无视这个通知继续等待，或者选择另外一趟高铁，但是不管你做什么，和火车站都没啥关系，它通知的责任尽到了</li>
</ul>
</li>
</ul>
<h3 id="wait和sleep方法"><a href="#wait和sleep方法" class="headerlink" title="wait和sleep方法"></a>wait和sleep方法</h3><ul>
<li>wait和sleep方法的区别<ul>
<li>最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。</li>
</ul>
</li>
<li>wait()和sleep()其他区别<ul>
<li>sleep来自Thread类，和wait来自Object类</li>
<li>调用sleep()方法的过程中，线程不会释放对象锁。而 调用 wait 方法线程会释放对象锁</li>
<li>sleep睡眠后不出让系统资源，wait让出系统资源其他线程可以占用CPU</li>
<li>sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒。</li>
</ul>
</li>
<li>通俗解释<ul>
<li>Java程序中wait 和 sleep都会造成某种形式的暂停，它们可以满足不同的需要。wait()方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，而 sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。</li>
</ul>
</li>
</ul>
<h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><h3 id="线程的调度问题"><a href="#线程的调度问题" class="headerlink" title="线程的调度问题"></a>线程的调度问题</h3><ul>
<li>应用程序在执行的时候都需要依赖于线程去抢占CPU的时间片 , 谁抢占到了CPU的时间片,那么CPU就会执行谁</li>
<li>线程的执行：假如我们的计算机只有一个 CPU，那么 CPU在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。</li>
</ul>
<h3 id="线程有两种调度模型"><a href="#线程有两种调度模型" class="headerlink" title="线程有两种调度模型"></a>线程有两种调度模型</h3><ul>
<li><strong>分时调度模型</strong><ul>
<li>所有线程轮流使用CPU的使用权，平均分配每个线程占用 CPU 的时间片</li>
</ul>
</li>
<li><strong>抢占式调度模型</strong><ul>
<li>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些。Java使用的是抢占式调度模型。</li>
<li><strong>java 中的优先级1-10,1最低, 10 最高</strong>。main主线程,优先级为5。优先级高,cpu调用的次数多。并不是绝对,优先级需要看系统等</li>
</ul>
</li>
</ul>
<h2 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h2><h3 id="休眠线程"><a href="#休眠线程" class="headerlink" title="休眠线程"></a>休眠线程</h3><ul>
<li>sleep方法<ul>
<li>public static void sleep(long time) ;</li>
<li>time表达的意思是休眠的时间 , 单位是毫秒</li>
</ul>
</li>
<li>sleep方法具体作用<ul>
<li>在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。</li>
<li>让其他线程有机会继续执行，但它<strong>并不释放对象锁</strong>。也就是如果有Synchronized同步块，<strong>其他线程仍然不能访问共享数据</strong>。注意该方法要捕获异常。</li>
</ul>
</li>
<li>sleep如何使低优先级线程执行<ul>
<li>比如有两个线程同时执行(没有Synchronized)，一个线程优先级为MAX_PRIORITY，另一个为MIN_PRIORITY，如果没有Sleep()方法，只有高优先级的线程执行完成后，低优先级的线程才能执行；但当高优先级的线程sleep(5000)后，低优先级就有机会执行了。</li>
<li>总之，sleep()可以使低优先级的线程得到执行的机会，当然也可以让同优先级、高优先级的线程有执行的机会。</li>
</ul>
</li>
<li>怎么唤醒一个阻塞的线程？<ul>
<li>如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</li>
</ul>
</li>
<li>Thread.sleep(0)的作用是啥？<ul>
<li>由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。</li>
</ul>
</li>
</ul>
<h3 id="wait和sleep方法-1"><a href="#wait和sleep方法-1" class="headerlink" title="wait和sleep方法"></a>wait和sleep方法</h3><ul>
<li>wait和sleep方法的区别<ul>
<li>最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。</li>
</ul>
</li>
<li>wait()和sleep()其他区别<ul>
<li>sleep来自Thread类，和wait来自Object类</li>
<li>调用sleep()方法的过程中，线程不会释放对象锁。而 调用 wait 方法线程会释放对象锁</li>
<li>sleep睡眠后不出让系统资源，wait让出系统资源其他线程可以占用CPU</li>
<li>sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒。</li>
</ul>
</li>
<li>通俗解释<ul>
<li>Java程序中wait 和 sleep都会造成某种形式的暂停，它们可以满足不同的需要。wait()方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，而 sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。</li>
</ul>
</li>
</ul>
<h3 id="加入线程"><a href="#加入线程" class="headerlink" title="加入线程"></a>加入线程</h3><ul>
<li><p>join方法</p>
<ul>
<li>public final void join()</li>
<li><strong>等待该线程执行完毕了以后,其他线程才能再次执行</strong>。Thread的非静态方法join()让一个线程B“加入”到另外一个线程A的尾部。在A执行完毕之前，B不能工作。</li>
<li>保证当前线程停止执行，直到该线程所加入的线程完成为止。然而，如果它加入的线程没有存活，则当前线程不需要停止。</li>
</ul>
</li>
<li><p>join()有什么作用？</p>
<ul>
<li>Thread的join()的含义是等待该线程终止，即将挂起调用线程的执行，直到被调用的对象完成它的执行。比如存在两个线程t1和t2，下述代码表示先启动t1，直到t1的任务结束，才轮到t2启动。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1.start();</span><br><span class="line">t1.join();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意事项:</p>
<ul>
<li>在线程启动之后，才能调用调用方法。如果没有启动，调用该方法，则直接会……</li>
</ul>
</li>
<li><p>join与start调用顺序问题</p>
<ul>
<li>join方法必须在线程start方法调用之后调用才有意义。这个也很容易理解：如果一个线程都没有start，那它也就无法同步了。因为执行完start方法才会创建线程。</li>
</ul>
</li>
</ul>
<h3 id="join方法实现原理"><a href="#join方法实现原理" class="headerlink" title="join方法实现原理"></a>join方法实现原理</h3><ul>
<li><p>join方法是通过调用线程的wait方法来达到同步的目的的。例如A线程中调用了B线程的join方法，则相当于在A线程中调用了B线程的wait方法，当B线程执行完（或者到达等待时间），B线程会自动调用自身的notifyAll方法唤醒A线程，从而达到同步的目的。</p>
</li>
<li><p>join方法源码</p>
<ul>
<li><p>如下所示，由下面的join方法源码可以看到：</p>
<ul>
<li>如果join方法传参为0的话，则会调用isAlive()方法，一直检测线程是否存活（执行完毕）,如果存活就调用wait方法，一直阻塞。isAlive()判断线程是否还活着，即线程是否还未终止。</li>
<li>如果参数为负数，则直接报错：”timeout value is negative”</li>
<li>如果参数大于0，则while里面一直判断线程是否存活，存活的话就一直判断当前线程执行的时间并与计算还需要等待多久时间，最后如果等待时间小于等于0就跳出循环，否则就继续wait</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="礼让线程"><a href="#礼让线程" class="headerlink" title="礼让线程"></a>礼让线程</h3><ul>
<li>yield方法<ul>
<li>public static void yield():</li>
<li>暂停当前正在执行的线程对象，并执行其他线程。</li>
</ul>
</li>
<li>线程礼让的原理是:<ul>
<li>暂停当前的线程,然CPU去执行其他的线程,这个暂定的时间是相当短暂的;当我某一个线程暂定完毕以后,其他的线程还没有抢占到cpu的执行权 ;那么这个是时候当前的<strong>线程会和其他的线程再次抢占cpu的执行权</strong>;</li>
</ul>
</li>
<li>yield礼让线程会释放锁吗<ul>
<li>yield()方法和sleep()方法类似，也不会释放“锁标志”，区别在于，它没有参数，即yield()方法只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行，另外yield()方法只能使同优先级或者高优先级的线程得到执行机会，这也和sleep()方法不同。</li>
</ul>
</li>
</ul>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><ul>
<li><p>setDaemon方法</p>
<ul>
<li>public final void setDaemon(boolean on)，默认false.</li>
<li>将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。</li>
</ul>
</li>
<li><p>注意要点：</p>
<ul>
<li>该方法必须在启动线程前调用。</li>
<li>jvm会线程程序中存在的线程类型,如果线程全部是守护线程,那么jvm就停止。</li>
</ul>
</li>
<li><p>当主线程结束时，结束其余的子线程（守护线程）自动关闭，就免去了还要继续关闭子线程的麻烦。如：Java垃圾回收线程就是一个典型的守护线程；内存资源或者线程的管理，但是非守护线程也可以。它的存在，必定有它的意义，只需在乎我们怎么把它用到恰到好处。</p>
</li>
</ul>
<h3 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h3><ul>
<li>stop方法(不推荐)<ul>
<li>public final void stop():</li>
<li>停止线程的运行</li>
</ul>
</li>
<li>interrupt方法<ul>
<li>public void interrupt():</li>
<li>中断线程(这个翻译不太好),查看API可得当线程调用wait(),sleep(long time)方法的时候处于阻塞状态,可以通过这个方法清除阻塞</li>
</ul>
</li>
</ul>
<h3 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h3><ul>
<li><p>start() 它的作用是启动一个新线程。</p>
<ul>
<li><p>通过start()方法来启动的新线程，处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行相应线程的run()方法。</p>
</li>
<li><p>run方法运行结束，此线程随即终止。start()不能被重复调用。用start方法来启动线程，真正实现了多线程运行，即无需等待某个线程的run方法体代码执行完毕就直接继续执行下面的代码。这里无需等待run方法执行完毕，即可继续执行下面的代码，即进行了线程切换。</p>
</li>
<li><p>run()就和普通的成员方法一样，可以被重复调用。<br>如果直接调用run方法，并不会启动新线程！程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到多线程的目的。</p>
</li>
</ul>
</li>
</ul>
<h2 id="线程关闭"><a href="#线程关闭" class="headerlink" title="线程关闭"></a>线程关闭</h2><ul>
<li><p>线程对象属于一次性消耗品，一般线程执行完run方法之后，线程就正常结束了，线程结束之后就报废了，不能再次start，只能新建一个线程对象。但有时run方法是永远不会结束的。例如在程序中使用线程进行Socket监听请求，或是其他的需要循环处理的任务。在这种情况下，一般是将这些任务放在一个循环中，如while循环。当需要结束线程时，如何退出线程呢？</p>
</li>
<li><p>结束Thread线程的几种方法</p>
<ul>
<li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止</li>
<li>使用interrupt()方法中断线程</li>
<li>使用stop方法强行终止线程（不推荐使用，可能发生不可预料的结果）</li>
<li>前两种方法都可以实现线程的正常退出，也就是要谈的优雅结束线程；第3种方法相当于电脑断电关机一样，是不安全的方法。</li>
</ul>
</li>
</ul>
<h3 id="使用退出标志终止线程"><a href="#使用退出标志终止线程" class="headerlink" title="使用退出标志终止线程"></a>使用退出标志终止线程</h3><ul>
<li><p>使用一个变量来控制循环，例如最直接的方法就是设一个boolean类型的标志，并通过设置这个标志为true或false来控制while循环是否退出。代码如下：</p>
</li>
<li><p>定义了一个退出标志exit，当exit为true时，while循环退出，exit的默认值为false.在定义exit时，使用了一个Java关键字volatile，这个关键字的目的是使exit同步，也就是说在同一时刻只能由一个线程来修改exit的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadSafe</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">exit</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!exit)&#123;</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * stop thread running</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (exit ) &#123;</span><br><span class="line">        exit = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用interrupt-方法终止线程"><a href="#使用interrupt-方法终止线程" class="headerlink" title="使用interrupt()方法终止线程"></a>使用interrupt()方法终止线程</h3><ul>
<li><p>使用interrupt()方法来终端线程可分为两种情况：</p>
</li>
<li><p>线程处于阻塞状态，如使用了sleep，同步锁的wait，socket的receiver，accept等方法时，会使线程处于阻塞状态。当调用线程的interrupt()方法时，系统会抛出一个InterruptedException异常，代码中通过捕获异常，然后break跳出循环状态，使线程正常结束。通常很多人认为只要调用interrupt方法线程就会结束，实际上是错的，<strong>一定要先捕获InterruptedException异常之后通过break来跳出循环，才能正常结束run方法</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadSafe</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">5</span>*<span class="number">1000</span>)；阻塞<span class="number">5</span>妙</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//捕获到异常之后，执行break跳出循环。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程未进入阻塞状态，使用isInterrupted()判断线程的中断标志来退出循环，当使用interrupt()方法时，中断标志就会置true，和使用自定义的标志来控制循环是一样的道理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadSafe</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted())&#123;</span><br><span class="line">            <span class="comment">//do something, but no throw InterruptedException</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为什么要区分进入阻塞状态和和非阻塞状态两种情况了，是因为当阻塞状态时，如果有interrupt()发生，系统除了会抛出InterruptedException异常外，还会调用interrupted()函数，调用时能获取到中断状态是true的状态，调用完之后会复位中断状态为false，所以异常抛出之后通过isInterrupted()是获取不到中断状态是true的状态，从而不能退出循环，因此在线程<strong>未进入阻塞的代码段时是可以通过isInterrupted()来判断中断是否发生来控制循环，在进入阻塞状态后要通过捕获异常来退出循环</strong>。因此使用interrupt()来退出线程的最好的方式应该是两种情况都要考虑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadSafe</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted())&#123; <span class="comment">//非阻塞过程中通过判断中断标志来退出</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">5</span>*<span class="number">1000</span>)；<span class="comment">//阻塞过程捕获中断异常来退出</span></span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//捕获到异常之后，执行break跳出循环。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用stop方法终止线程"><a href="#使用stop方法终止线程" class="headerlink" title="使用stop方法终止线程"></a>使用stop方法终止线程</h3><ul>
<li>程序中可以直接使用thread.stop()来强行终止线程，但是stop方法是很危险的，就象突然关闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果</li>
<li>不安全主要是：thread.stop()调用之后，创建子线程的线程就会抛出ThreadDeatherror的错误，并且会释放子线程所持有的所有锁。一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在调用thread.stop()后导致了该线程所持有的所有锁的突然释放(不可控制)，那么被保护数据就有可能呈现不一致性，其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误。因此，并不推荐使用stop方法来终止线程。</li>
</ul>
<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><h3 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait()&#x2F;notify()"></a>wait()&#x2F;notify()</h3><ul>
<li>Object类中相关的方法有notify方法和wait方法。因为wait和notify方法定义在Object类中，因此会被所有的类所继承。这些方法都是<strong>final</strong>的，即它们都是不能被重写的，不能通过子类覆写去改变它们的行为。<ul>
<li><strong>①wait()方法：</strong> 让当前线程进入等待，并释放锁。</li>
<li><strong>②wait(long)方法：</strong> 让当前线程进入等待，并释放锁，不过等待时间为long，超过这个时间没有对当前线程进行唤醒，将<strong>自动唤醒</strong>。</li>
<li><strong>③notify()方法：</strong> 让当前线程通知那些处于等待状态的线程，当前线程执行完毕后释放锁，并从其他线程中唤醒其中一个继续执行。</li>
<li><strong>④notifyAll()方法：</strong> 让当前线程通知那些处于等待状态的线程，当前线程执行完毕后释放锁，将唤醒所有等待状态的线程。</li>
</ul>
</li>
</ul>
<h3 id="wait-方法使用注意事项"><a href="#wait-方法使用注意事项" class="headerlink" title="wait()方法使用注意事项"></a>wait()方法使用注意事项</h3><ul>
<li>①当前的线程必须拥有当前对象的monitor，也即lock，就是锁，才能调用wait()方法，否则将抛出异常java.lang.IllegalMonitorStateException。</li>
<li>②线程调用wait()方法，释放它对锁的拥有权，然后等待另外的线程来通知它（通知的方式是notify()或者notifyAll()方法），这样它才能重新获得锁的拥有权和恢复执行。</li>
<li>③要确保调用wait()方法的时候拥有锁，即，wait()方法的调用必须放在synchronized方法或synchronized块中。</li>
<li><strong>wait()与sleep()比较</strong><ul>
<li>当线程调用了wait()方法时，它会释放掉对象的锁。</li>
<li>Thread.sleep()，它会导致线程睡眠指定的毫秒数，但线程在睡眠的过程中是不会释放掉对象的锁的。</li>
</ul>
</li>
</ul>
<h3 id="notify-方法使用注意事项"><a href="#notify-方法使用注意事项" class="headerlink" title="notify()方法使用注意事项"></a>notify()方法使用注意事项</h3><ul>
<li>①如果多个线程在等待，它们中的一个将会选择被唤醒。这种选择是随意的，和具体实现有关。（线程等待一个对象的锁是由于调用了wait()方法）。</li>
<li>②被唤醒的线程是不能被执行的，需要等到当前线程放弃这个对象的锁，当前线程会在方法执行完毕后释放锁。</li>
</ul>
<h3 id="wait-notify-协作"><a href="#wait-notify-协作" class="headerlink" title="wait()&#x2F;notify()协作"></a>wait()&#x2F;notify()协作</h3><ul>
<li><p>如果通知过早，则会打乱程序的运行逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">MyRun</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRun</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">bThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run.runnableB);</span><br><span class="line">    bThread.start();</span><br><span class="line">    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">aThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run.runnableA);</span><br><span class="line">    aThread.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRun</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="type">Runnable</span> <span class="variable">runnableA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;begin wait&quot;</span>);</span><br><span class="line">                    lock.wait();</span><br><span class="line">                    System.out.println(<span class="string">&quot;end wait&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">Runnable</span> <span class="variable">runnableB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;begin notify&quot;</span>);</span><br><span class="line">                <span class="comment">// 如果notify方法先执行，将导致wait方法释放锁进入等待状态后</span></span><br><span class="line">                <span class="comment">// 永远无法被唤醒，影响程序逻辑。应避免这种情况。</span></span><br><span class="line">                lock.notify();</span><br><span class="line">                System.out.println(<span class="string">&quot;end notify&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>等待wait的条件发生变化</p>
<ul>
<li><p>也就是wait等待条件发生了变化，也容易造成程序逻辑的混乱。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Add类，执行加法操作，然后通知Subtract类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Add</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Add</span><span class="params">(String lock)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            ValueObject.list.add(<span class="string">&quot;anyThing&quot;</span>);</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Subtract类，执行减法操作，执行完后进入等待状态，等待Add类唤醒notify</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subtract</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Subtract</span><span class="params">(String lock)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subtract</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span>(ValueObject.list.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;wait begin ThreadName=&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">                    lock.wait();</span><br><span class="line">                    System.out.println(<span class="string">&quot;wait end ThreadName=&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">                ValueObject.list.remove(<span class="number">0</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;list size =&quot;</span>+ValueObject.list.size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程ThreadAdd</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadAdd</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Add pAdd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadAdd</span><span class="params">(Add pAdd)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.pAdd = pAdd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        pAdd.add();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程ThreadSubtract</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadSubtract</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Subtract rSubtract;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadSubtract</span><span class="params">(Subtract rSubtract)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.rSubtract = rSubtract;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        rSubtract.subtract();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>启动线程</p>
<ul>
<li>先开启两个ThreadSubtract线程，由于list中没有元素，进入等待状态。</li>
<li>再开启一个ThreadAdd线程，向list中增加一个元素，然后唤醒两个ThreadSubtract线程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">      <span class="type">Add</span> <span class="variable">add</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Add</span>(lock);</span><br><span class="line">      <span class="type">Subtract</span> <span class="variable">subtract</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Subtract</span>(lock);</span><br><span class="line">      <span class="type">ThreadSubtract</span> <span class="variable">subtractThread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadSubtract</span>(subtract);</span><br><span class="line">      subtractThread1.setName(<span class="string">&quot;subtractThread1&quot;</span>);</span><br><span class="line">      subtractThread1.start();</span><br><span class="line">      <span class="type">ThreadSubtract</span> <span class="variable">subtractThread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadSubtract</span>(subtract);</span><br><span class="line">      subtractThread2.setName(<span class="string">&quot;subtractThread2&quot;</span>);</span><br><span class="line">      subtractThread2.start();</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      <span class="type">ThreadAdd</span> <span class="variable">addThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadAdd</span>(add);</span><br><span class="line">      addThread.setName(<span class="string">&quot;addThread&quot;</span>);</span><br><span class="line">      addThread.start();</span><br><span class="line">  &#125;</span><br><span class="line">- 输出结果</span><br><span class="line"></span><br><span class="line">  - 当第二个ThreadSubtract线程执行减法操作时，抛出下标越界异常。</span><br><span class="line">  - 一开始两个ThreadSubtract线程等待状态，当ThreadAdd线程添加一个元素并唤醒所有线程后，</span><br><span class="line">    - 第一个ThreadSubtract线程接着原来的执行到的地点开始继续执行，删除一个元素并输出集合大小。</span><br><span class="line">    - 同样，第二个ThreadSubtract线程也如此，可是此时集合中已经没有元素了，所以抛出异常。</span><br><span class="line"></span><br><span class="line">  ```sh</span><br><span class="line">  &gt; wait begin ThreadName=subtractThread1</span><br><span class="line">  &gt; wait begin ThreadName=subtractThread2</span><br><span class="line">  &gt; wait end ThreadName=subtractThread2</span><br><span class="line">  &gt; Exception in thread <span class="string">&quot;subtractThread1&quot;</span> <span class="type">list</span> <span class="variable">size</span> <span class="operator">=</span><span class="number">0</span></span><br><span class="line">  &gt; wait end ThreadName=subtractThread1</span><br><span class="line">  &gt; java.lang.IndexOutOfBoundsException: Index: <span class="number">0</span>, Size: <span class="number">0</span></span><br><span class="line">  &gt;     at java.util.ArrayList.rangeCheck\(Unknown Source\)</span><br><span class="line">  &gt;     at java.util.ArrayList.remove\(Unknown Source\)</span><br><span class="line">  &gt;     at com.lvr.communication.Subtract.subtract\(Subtract.java:<span class="number">18</span>\)</span><br><span class="line">  &gt;     at com.lvr.communication.ThreadSubtract.run\(ThreadSubtract.java:<span class="number">12</span>\)</span><br><span class="line"></span><br><span class="line">- **解决办法：从等待状态被唤醒后，重新判断条件，看看是否扔需要进入等待状态，不需要进入再进行下一步操作。即把<span class="keyword">if</span>()判断，改成<span class="keyword">while</span>()。**</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subtract</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">              <span class="keyword">while</span>(ValueObject.list.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                  System.out.println(<span class="string">&quot;wait begin ThreadName=&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">                  lock.wait();</span><br><span class="line">                  System.out.println(<span class="string">&quot;wait end ThreadName=&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">              &#125;</span><br><span class="line">              ValueObject.list.remove(<span class="number">0</span>);</span><br><span class="line">              System.out.println(<span class="string">&quot;list size =&quot;</span>+ValueObject.list.size());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="Condition实现等待-通知"><a href="#Condition实现等待-通知" class="headerlink" title="Condition实现等待&#x2F;通知"></a>Condition实现等待&#x2F;通知</h3><h4 id="Condition简单介绍"><a href="#Condition简单介绍" class="headerlink" title="Condition简单介绍"></a>Condition简单介绍</h4><ul>
<li>关键字synchronized与wait()和notify()&#x2F;notifyAll()方法相结合可以实现等待&#x2F;通知模式，类似ReentrantLock也可以实现同样的功能，但需要借助于Condition对象。</li>
<li>关于Condition实现等待&#x2F;通知就不详细介绍了，可以完全类比wait()&#x2F;notify()，基本使用和注意事项完全一致。</li>
<li>就只简单介绍下类比情况：<ul>
<li><strong>condition.await()————&gt;lock.wait()</strong></li>
<li><strong>condition.await(long time, TimeUnit unit)————&gt;lock.wait(long timeout)</strong></li>
<li><strong>condition.signal()————&gt;lock.notify()</strong></li>
<li><strong>condition.signaAll()————&gt;lock.notifyAll()</strong></li>
</ul>
</li>
</ul>
<h4 id="Condition实现方式"><a href="#Condition实现方式" class="headerlink" title="Condition实现方式"></a>Condition实现方式</h4><ul>
<li><strong>特殊之处：synchronized相当于整个ReentrantLock对象只有一个单一的Condition对象情况。而一个ReentrantLock却可以拥有多个Condition对象，来实现通知部分线程。</strong></li>
<li><strong>具体实现方式：</strong><ul>
<li>假设有两个Condition对象：ConditionA和ConditionB。那么由ConditionA.await()方法进入等待状态的线程，由ConditionA.signalAll()通知唤醒；由ConditionB.await()方法进入等待状态的线程，由ConditionB.signalAll()通知唤醒。</li>
</ul>
</li>
</ul>
<h2 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h2><ul>
<li><p>生产者消费者模型发生场景</p>
<ul>
<li>多线程-并发协作(生产者消费者模型)。多线程同步的经典问题！</li>
</ul>
</li>
<li><p>什么是生产者消费者模型，准确说应该是“生产者-消费者-仓储”模型举例式说明</p>
<ul>
<li>生产者仅仅在仓储未满时候生产，仓满则停止生产。</li>
<li>消费者仅仅在仓储有产品时候才能消费，仓空则等待。</li>
<li>当消费者发现仓储没产品可消费时候会通知生产者生产。</li>
<li>生产者在生产出可消费产品时候，应该通知等待的消费者去消费。</li>
</ul>
</li>
<li><p>专业术语说明什么是生产者消费者模型</p>
<ul>
<li>生产者消费者模型通过一个缓存队列，既解决了生产者和消费者之间强耦合的问题，又平衡了生产者和消费者的处理能力。</li>
<li>具体规则：生产者只在缓存区未满时进行生产，缓存区满时生产者进程被阻塞；消费者只在缓存区非空时进行消费，缓存区为空时消费者进程被阻塞；当消费者发现缓存区为空时会通知生产者生产；当生产者发现缓存区满时会通知消费者消费。</li>
<li>实现关键：synchronized保证对象只能被一个线程占用；wait()让当前线程进入等待状态，并释放它所持有的锁；notify()&amp;notifyAll()唤醒一个（所有）正处于等待状态的线程</li>
</ul>
</li>
</ul>
<h3 id="一生产与一消费案例"><a href="#一生产与一消费案例" class="headerlink" title="一生产与一消费案例"></a>一生产与一消费案例</h3><ul>
<li><p>下面代码案例是一个生产者，一个消费者的模式。</p>
<ul>
<li>假设场景：一个String对象，其中生产者为其设置值，消费者拿走其中的值，不断的循环往复，实现生产者&#x2F;消费者的情形。</li>
<li>实现方式：<strong>wait()&#x2F;notify()实现</strong></li>
</ul>
</li>
<li><p>生产者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Product</span><span class="params">(String lock)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!StringObject.value.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">                    <span class="comment">//有值，不生产</span></span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">String</span>  <span class="variable">value</span> <span class="operator">=</span> System.currentTimeMillis()+<span class="string">&quot;&quot;</span>+System.nanoTime();</span><br><span class="line">                System.out.println(<span class="string">&quot;set的值是：&quot;</span>+value);</span><br><span class="line">                StringObject.value = value;</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(String lock)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span>(StringObject.value.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">                    <span class="comment">//没值，不进行消费</span></span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;get的值是：&quot;</span>+StringObject.value);</span><br><span class="line">                StringObject.value = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>生产者线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadProduct</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Product product;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadProduct</span><span class="params">(Product product)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.product = product;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//死循环，不断的生产</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            product.setValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费者线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadConsumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Consumer consumer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadConsumer</span><span class="params">(Consumer consumer)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.consumer = consumer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//死循环，不断的消费</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            consumer.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启生产者&#x2F;消费者模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>(lock);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(lock);</span><br><span class="line">        <span class="type">ThreadProduct</span> <span class="variable">pThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadProduct</span>(product);</span><br><span class="line">        <span class="type">ThreadConsumer</span> <span class="variable">cThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadConsumer</span>(consumer);</span><br><span class="line">        pThread.start();</span><br><span class="line">        cThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>的值是：148827033184127168687409691</span><br><span class="line">get的值是：148827033184127168687409691</span><br><span class="line"><span class="built_in">set</span>的值是：148827033184127168687449887</span><br><span class="line">get的值是：148827033184127168687449887</span><br><span class="line"><span class="built_in">set</span>的值是：148827033184127168687475117</span><br><span class="line">get的值是：148827033184127168687475117</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="多生产与多消费案例"><a href="#多生产与多消费案例" class="headerlink" title="多生产与多消费案例"></a>多生产与多消费案例</h3><ul>
<li><p><strong>特殊情况：</strong> 按照上述一生产与一消费的情况，通过创建多个生产者和消费者线程，实现多生产与多消费的情况，将会出现“假死”。</p>
</li>
<li><p><strong>具体原因：</strong> 多个生产者和消费者线程。当全部运行后，生产者线程生产数据后，可能唤醒的同类即生产者线程。此时可能会出现如下情况：所有生产者线程进入等待状态，然后消费者线程消费完数据后，再次唤醒的还是消费者线程，直至所有消费者线程都进入等待状态，此时将进入“假死”。</p>
</li>
<li><p><strong>解决方法：</strong> 将notify()或signal()方法改为notifyAll()或signalAll()方法，这样就不怕因为唤醒同类而进入“假死”状态了。</p>
</li>
<li><p><strong>Condition方式实现</strong></p>
</li>
<li><p>生产者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock;</span><br><span class="line">    <span class="keyword">private</span> Condition condition;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Product</span><span class="params">(ReentrantLock lock, Condition condition)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.lock = lock;</span><br><span class="line">        <span class="built_in">this</span>.condition = condition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (!StringObject.value.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 有值，不生产</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> System.currentTimeMillis() + <span class="string">&quot;&quot;</span> + System.nanoTime();</span><br><span class="line">            System.out.println(<span class="string">&quot;set的值是：&quot;</span> + value);</span><br><span class="line">            StringObject.value = value;</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock;</span><br><span class="line">    <span class="keyword">private</span> Condition condition;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(ReentrantLock lock,Condition condition)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.lock = lock;</span><br><span class="line">        <span class="built_in">this</span>.condition = condition;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">while</span>(StringObject.value.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">                    <span class="comment">//没值，不进行消费</span></span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;get的值是：&quot;</span>+StringObject.value);</span><br><span class="line">                StringObject.value = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                condition.signalAll();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>生产者线程和消费者线程与一生产一消费的模式相同。</li>
</ul>
</li>
<li><p>开启多生产&#x2F;多消费模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">newCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>(lock,newCondition);</span><br><span class="line">    <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(lock,newCondition);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="type">ThreadProduct</span> <span class="variable">pThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadProduct</span>(product);</span><br><span class="line">        <span class="type">ThreadConsumer</span> <span class="variable">cThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadConsumer</span>(consumer);</span><br><span class="line">        pThread.start();</span><br><span class="line">        cThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>的值是：148827212374628960540784817</span><br><span class="line">get的值是：148827212374628960540784817</span><br><span class="line"><span class="built_in">set</span>的值是：148827212374628960540810047</span><br><span class="line">get的值是：148827212374628960540810047</span><br></pre></td></tr></table></figure>
</li>
<li><p>可见交替地进行get&#x2F;set实现多生产&#x2F;多消费模式。</p>
<ul>
<li><strong>注意：相比一生产一消费的模式，改动了两处。</strong></li>
<li><strong>①signal()–&gt;signalAll()避免进入“假死”状态。</strong></li>
<li><strong>②if()判断–&gt;while()循环，重新判断条件，避免逻辑混乱。</strong></li>
</ul>
</li>
</ul>
<h3 id="会遇到哪些关键问题"><a href="#会遇到哪些关键问题" class="headerlink" title="会遇到哪些关键问题"></a>会遇到哪些关键问题</h3><ul>
<li>如何保证同一资源被多个线程并发访问时的完整性。常用的同步方法是采用信号或加锁机制，保证资源在任意时刻至多被一个线程访问。</li>
<li>如何保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区空时消耗数据？</li>
<li>实际开发时案例<ul>
<li>这种并发情况下，一般服务端程序用的比较多，Android端的应用程序较少有什么并发情况。虽然事实如此，但是构建生产者-消费者模型，是线程间协作的思想，工作线程的协助是为了让UI线程更好的完成工作，提高用户体验。比如，图片选择查看器案例！</li>
</ul>
</li>
</ul>
<h3 id="如何解决关键问题"><a href="#如何解决关键问题" class="headerlink" title="如何解决关键问题"></a>如何解决关键问题</h3><ul>
<li>如何保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区空时消耗数据，思考一下？</li>
<li>解决思路可以简单概括为：<ul>
<li>生产者持续生产，直到缓冲区满，满时阻塞；缓冲区不满后，继续生产；</li>
<li>消费者持续消费，直到缓冲区空，空时阻塞；缓冲区不空后，继续消费；</li>
<li>生产者和消费者都可以有多个；</li>
</ul>
</li>
<li>能够让消费者和生产者在各自满足条件需要阻塞时能够起到正确的作用<ul>
<li>wait()&#x2F;notify()方式；</li>
<li>await()&#x2F;signal()方式；</li>
<li>BlockingQueue阻塞队列方式；</li>
<li>PipedInputStream&#x2F;PipedOutputStream方式；</li>
</ul>
</li>
<li>一般可以使用第一种和第三种方式实现逻辑。</li>
</ul>
<h2 id="多线程并发"><a href="#多线程并发" class="headerlink" title="多线程并发"></a>多线程并发</h2><h3 id="继承Thread类的方式卖电影票案例"><a href="#继承Thread类的方式卖电影票案例" class="headerlink" title="继承Thread类的方式卖电影票案例"></a>继承Thread类的方式卖电影票案例</h3><ul>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 需求：某电影院目前正在上映贺岁大片，共有100张票，而它有3个售票窗口售票，请设计一个程序模拟该电影院售票。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="comment">// 创建3个线程对象</span></span><br><span class="line">        <span class="type">SellTicktes</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicktes</span>() ;</span><br><span class="line">        <span class="type">SellTicktes</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicktes</span>() ;</span><br><span class="line">        <span class="type">SellTicktes</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicktes</span>() ;</span><br><span class="line">        <span class="comment">// 设置名称</span></span><br><span class="line">        t1.setName(<span class="string">&quot;窗口1&quot;</span>) ;</span><br><span class="line">        t2.setName(<span class="string">&quot;窗口2&quot;</span>) ;</span><br><span class="line">        t3.setName(<span class="string">&quot;窗口3&quot;</span>) ;</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        t1.start() ;</span><br><span class="line">        t2.start() ;</span><br><span class="line">        t3.start() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicktes</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span> ;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 定义总票数</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * 如果我们把票数定义成了局部变量,那么表示的意思是每一个窗口出售了各自的100张票; 而我们的需求是: 总共有100张票</span></span><br><span class="line"><span class="comment">		 * 而这100张票要被3个窗口出售; 因此我们就不能把票数定义成局部变量,只能定义成成员变量</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="comment">// 模拟售票</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>( num &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在出售&quot;</span> + (num--) + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>结果如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">窗口<span class="number">1</span>正在出售<span class="number">100</span>张票</span><br><span class="line">窗口<span class="number">2</span>正在出售<span class="number">99</span>张票</span><br><span class="line">窗口<span class="number">3</span>正在出售<span class="number">100</span>张票</span><br><span class="line">窗口<span class="number">2</span>正在出售<span class="number">97</span>张票</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="实现Runnable接口的方式卖电影票"><a href="#实现Runnable接口的方式卖电影票" class="headerlink" title="实现Runnable接口的方式卖电影票"></a>实现Runnable接口的方式卖电影票</h3><ul>
<li><p>代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicektesDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 创建SellTicektes对象</span></span><br><span class="line">		<span class="type">SellTicektes</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicektes</span>() ;</span><br><span class="line">		<span class="comment">// 创建Thread对象</span></span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(st , <span class="string">&quot;窗口1&quot;</span>) ;</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(st , <span class="string">&quot;窗口2&quot;</span>) ;</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(st , <span class="string">&quot;窗口3&quot;</span>) ;</span><br><span class="line">		<span class="comment">// 启动线程</span></span><br><span class="line">		t1.start() ;</span><br><span class="line">		t2.start() ;</span><br><span class="line">		t3.start() ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicektes</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span> ;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在出售第&quot;</span> + (num--) + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">窗口<span class="number">1</span>正在出售 <span class="number">4</span> 张票</span><br><span class="line">窗口<span class="number">2</span>正在出售 <span class="number">1</span> 张票</span><br><span class="line">窗口<span class="number">1</span>正在出售 <span class="number">0</span> 张票</span><br><span class="line">窗口<span class="number">3</span>正在出售 -<span class="number">1</span> 张票</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="同票和负数票的原因分析"><a href="#同票和负数票的原因分析" class="headerlink" title="同票和负数票的原因分析"></a>同票和负数票的原因分析</h3><ul>
<li><p>讲解过电影院售票程序，从表面上看不出什么问题，但是在真实生活中，售票时网络是不能实时传输的，总是存在延迟的情况，所以，在出售一张票以后，需要一点时间的延迟。改实现接口方式的卖票程序,每次卖票延迟100毫秒</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 创建3个线程对象</span></span><br><span class="line">		<span class="type">SellTicktes</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicktes</span>() ;</span><br><span class="line">		<span class="type">SellTicktes</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicktes</span>() ;</span><br><span class="line">		<span class="type">SellTicktes</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicktes</span>() ;</span><br><span class="line">		<span class="comment">// 设置名称</span></span><br><span class="line">		t1.setName(<span class="string">&quot;窗口1&quot;</span>) ;</span><br><span class="line">		t2.setName(<span class="string">&quot;窗口2&quot;</span>) ;</span><br><span class="line">		t3.setName(<span class="string">&quot;窗口3&quot;</span>) ;</span><br><span class="line">		<span class="comment">// 启动线程</span></span><br><span class="line">		t1.start() ;</span><br><span class="line">		t2.start() ;</span><br><span class="line">		t3.start() ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicktes</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span> ;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 模拟售票</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>( num &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">100</span>) ;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在出售&quot;</span> + (num--) + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一步和第二步之间加入了延时操作，那么一个线程就可能在还没有对票数进行减操作之前，其他线程就已经将票数减少了，这样就会出现票数为负的情况。</p>
</li>
</ul>
<h4 id="线程安全问题的产生原因分析"><a href="#线程安全问题的产生原因分析" class="headerlink" title="线程安全问题的产生原因分析"></a>线程安全问题的产生原因分析</h4><ul>
<li>首先想为什么出现问题?</li>
<li>是否是多线程环境，是否有共享数据，是否有多条语句操作共享数据</li>
<li>如何解决多线程安全问题呢?<ul>
<li>基本思想：让程序没有安全问题的环境。怎么实现呢?把多个语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可。</li>
</ul>
</li>
</ul>
<h3 id="同步代码块的方式解决线程安全问题"><a href="#同步代码块的方式解决线程安全问题" class="headerlink" title="同步代码块的方式解决线程安全问题"></a>同步代码块的方式解决线程安全问题</h3><ul>
<li><p><strong>同步代码块的格式</strong></p>
<ul>
<li>同步可以解决安全问题的根本原因就在那个对象上。该对象如同锁的功能</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line">    需要同步的代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>同步代码块优势和劣势</strong></p>
<ul>
<li>同步的好处:同步的出现解决了多线程的安全问题。</li>
<li>同步的弊端:当线程相当多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率。</li>
</ul>
</li>
<li><p>代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">aspackage top.fulsun.tick;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建3个线程对象</span></span><br><span class="line">        <span class="type">SellTicktes3</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicktes3</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t1);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t1);</span><br><span class="line">        <span class="comment">// 设置名称</span></span><br><span class="line">        t1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SellTicktes3</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟售票</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在出售&quot;</span> + (num--) + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果是不同的对象创建的线程，不能使用this</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.fulsun.tick;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建3个线程对象</span></span><br><span class="line">        <span class="type">SellTicktes3</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicktes3</span>();</span><br><span class="line">        <span class="comment">// Thread t2 = new Thread(t1);</span></span><br><span class="line">        <span class="comment">// Thread t3 = new Thread(t1);</span></span><br><span class="line">        <span class="type">SellTicktes3</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicktes3</span>();</span><br><span class="line">        <span class="type">SellTicktes3</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicktes3</span>();</span><br><span class="line">        <span class="comment">// 设置名称</span></span><br><span class="line">        t1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SellTicktes3</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟售票</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="comment">// synchronized (this) &#123;</span></span><br><span class="line">                <span class="keyword">if</span>(num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在出售&quot;</span> + (num--) + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="线程安全特性"><a href="#线程安全特性" class="headerlink" title="线程安全特性"></a>线程安全特性</h2><h3 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h3><ul>
<li>什么是线程安全<ul>
<li>线程安全就是当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。</li>
</ul>
</li>
<li>并发切入点是什么？<ul>
<li>并发分析的切入点分为<strong>两个核心，三大性质</strong>。两大核心：JMM内存模型（主内存和工作内存）以及happens-before；三条性质：原子性，可见性，有序性。</li>
</ul>
</li>
</ul>
<h3 id="线程安全级别"><a href="#线程安全级别" class="headerlink" title="线程安全级别"></a>线程安全级别</h3><ul>
<li>线程安全也是有几个级别<ul>
<li>不可变：<ul>
<li>像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</li>
</ul>
</li>
<li>绝对线程安全<ul>
<li>不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet</li>
</ul>
</li>
<li>相对线程安全<ul>
<li>相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。</li>
</ul>
</li>
<li>线程非安全<ul>
<li>ArrayList、LinkedList、HashMap等都是线程非安全的类.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="多线程三要素"><a href="#多线程三要素" class="headerlink" title="多线程三要素"></a>多线程三要素</h3><ul>
<li>三要素分别是：原子性，可见性，有序性</li>
</ul>
<h4 id="如何理解原子性"><a href="#如何理解原子性" class="headerlink" title="如何理解原子性"></a>如何理解原子性</h4><ul>
<li>如何理解原子性<ul>
<li>即一个操作（有可能包含有多个子操作）要么全部执行（生效），要么全部都不执行（都不生效）。</li>
</ul>
</li>
<li>举一个例子<ul>
<li>关于原子性，一个非常经典的例子就是银行转账问题：比如A和B同时向C转账10万元。如果转账操作不具有原子性，A在向C转账时，读取了C的余额为20万，然后加上转账的10万，计算出此时应该有30万，但还未来及将30万写回C的账户，此时B的转账请求过来了，B发现C的余额为20万，然后将其加10万并写回。然后A的转账操作继续——将30万写回C的余额。这种情况下C的最终余额为30万，而非预期的40万。</li>
</ul>
</li>
</ul>
<h4 id="如何理解可见性"><a href="#如何理解可见性" class="headerlink" title="如何理解可见性"></a>如何理解可见性</h4><ul>
<li>如何理解可见性<ul>
<li>当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立即看到。</li>
</ul>
</li>
<li>举一个例子<ul>
<li>CPU从主内存中读数据的效率相对来说不高，现在主流的计算机中，都有几级缓存。每个线程读取共享变量时，都会将该变量加载进其对应CPU的高速缓存里，修改该变量后，CPU会立即更新该缓存，但并不一定会立即将其写回主内存（实际上写回主内存的时间不可预期）。此时其它线程（尤其是不在同一个CPU上执行的线程）访问该变量时，从主内存中读到的就是旧的数据，而非第一个线程更新后的数据。这一点是操作系统或者说是硬件层面的机制，所以很多应用开发人员经常会忽略。</li>
</ul>
</li>
</ul>
<h4 id="如何理解有序性"><a href="#如何理解有序性" class="headerlink" title="如何理解有序性"></a>如何理解有序性</h4><ul>
<li>如何理解有序性<ul>
<li>顺序性指的是，程序执行的顺序按照代码的先后顺序执行。</li>
</ul>
</li>
<li>举一个例子<ul>
<li>语句应该依次执行，但实际上JVM真正在执行这段代码时，并不保证它们一定完全按照此顺序执行。处理器为了提高程序整体的执行效率，<strong>JVM可能会对代码进行优化，其中的一项优化方式就是调整代码顺序，按照更高效的顺序执行代码</strong>。CPU不按照我的代码顺序执行代码，那怎么保证得到我们想要的效果呢？实际上，CPU虽然并不保证完全按照代码顺序执行，但它会保证程序最终的执行结果和代码顺序执行时的结果一致。</li>
</ul>
</li>
</ul>
<h4 id="三要素作用"><a href="#三要素作用" class="headerlink" title="三要素作用"></a>三要素作用</h4><ul>
<li>上面这三个要素主要作用是保障线程安全。保证线程安全可从多线程三特性出发：<ul>
<li>原子性（Atomicity）：单个或多个操作是要么全部执行，要么都不执行<ul>
<li>Lock：保证同时只有一个线程能拿到锁，并执行申请锁和释放锁的代码</li>
<li>synchronized：对线程加独占锁，被它修饰的类&#x2F;方法&#x2F;变量只允许一个线程访问</li>
</ul>
</li>
<li>可见性（Visibility）：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改<ul>
<li>volatile：保证新值能立即同步到主内存，且每次使用前立即从主内存刷新；</li>
<li>synchronized：在释放锁之前会将工作内存新值更新到主存中</li>
</ul>
</li>
<li>有序性（Ordering）：程序代码按照指令顺序执行<ul>
<li>volatile： 本身就包含了禁止指令重排序的语义</li>
<li>synchronized：保证一个变量在同一个时刻只允许一条线程对其进行lock操作，使得持有同一个锁的两个同步块只能串行地进入</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="处理多线程并发"><a href="#处理多线程并发" class="headerlink" title="处理多线程并发"></a>处理多线程并发</h2><h3 id="保证原子性"><a href="#保证原子性" class="headerlink" title="保证原子性"></a>保证原子性</h3><h4 id="第一种方式：锁和同步"><a href="#第一种方式：锁和同步" class="headerlink" title="第一种方式：锁和同步"></a>第一种方式：锁和同步</h4><ul>
<li><p>常用的保证Java操作原子性的工具是锁和同步方法（或者同步代码块）。可以保证同一时间只有一个线程能拿到锁，也就保证了同一时间只有一个线程能执行申请锁和释放锁之间的代码。</p>
</li>
<li><p>使用锁</p>
<ul>
<li><p>代码形式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLock</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// access the resource protected by this lock</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">- 同步方法或者同步代码块。</span><br><span class="line"></span><br><span class="line">  - 使用非静态同步方法时，锁住的是当前实例；使用静态同步方法时，锁住的是该类的Class对象；使用静态代码块时，锁住的是<span class="keyword">synchronized</span>关键字后面括号内的对象。下面是同步代码块示例</span><br><span class="line"></span><br><span class="line">    ```java</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLock</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (MainActivity.class)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            i = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>无论使用锁还是synchronized，本质都是一样，通过锁来实现资源的排它性，从而实际目标代码段同一时间只会被一个线程执行，进而保证了目标代码段的原子性。这是一种以牺牲性能为代价的方法。</li>
</ul>
</li>
</ul>
<h4 id="第二种方式：CAS"><a href="#第二种方式：CAS" class="headerlink" title="第二种方式：CAS"></a>第二种方式：CAS</h4><ul>
<li><p>基础类型变量自增（i++）是一种常被误以为是原子操作而实际不是的操作。</p>
<ul>
<li>Java中提供了对应的原子操作类来实现该操作，并保证原子性，其本质是利用了CPU级别的CAS指令。由于是CPU级别的指令，其开销比需要操作系统参与的锁的开销小。AtomicInteger使用方法如下。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger atomicInteger = new AtomicInteger();</span><br><span class="line">for(int b = 0; b &lt; numThreads; b++) &#123;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        for(int a = 0; a &lt; iteration; a++) &#123;</span><br><span class="line">            atomicInteger.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a>保证可见性</h3><ul>
<li><p>Java提供了volatile关键字来保证可见性。</p>
<ul>
<li><p>当使用volatile修饰某个变量时，它会保证对该变量的修改会立即被更新到内存中，并且将其它缓存中对该变量的缓存设置成无效，因此其它线程需要读取该值时必须从主内存中读取，从而得到最新的值。</p>
</li>
<li><p>双检锁&#x2F;双重校验锁创建单例模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//创建 SingleObject 的一个对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//让构造函数为 private，这样该类就不会被实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取唯一可用的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletionObject <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123; <span class="comment">// 第一次检查:为避免在实例已经创建的情况下每次获取实例都加锁取(影响性能)</span></span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//synchronized关键字保证的可见性是防止多个线程实例化出多个instance。</span></span><br><span class="line">        <span class="keyword">synchronized</span> (SingletionTest.class) &#123;</span><br><span class="line">            <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;	<span class="comment">//第二次检查:锁内不再次判断，会导致实例重复创建</span></span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 隐患：同步块中修改的变量在释放锁之前对其他线程“可见”</span></span><br><span class="line">            <span class="comment">// （1）分配内存空间。</span></span><br><span class="line">            <span class="comment">// （2）初始化对象</span></span><br><span class="line">            <span class="comment">// （3）将内存空间的地址赋值给对应的引用。</span></span><br><span class="line">            <span class="comment">// 如果先执行了3，但是没有初始化</span></span><br><span class="line">            <span class="comment">// 这个时候新线程(可见)第一次检查不通过，直接返回对象，会返回了一个尚未初始化完成的对象</span></span><br><span class="line">            <span class="comment">// 如果将instance设置volatile类型变量，</span></span><br><span class="line">            <span class="comment">//在volatile写操作之前的任何操作都是不可重排序的，即23的顺序不可重排序。</span></span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="保证有序性"><a href="#保证有序性" class="headerlink" title="保证有序性"></a>保证有序性</h3><ul>
<li>Java中可通过volatile在一定程序上保证顺序性，另外还可以通过synchronized和锁来保证顺序性。</li>
<li>synchronized和锁保证顺序性的原理和保证原子性一样，都是通过保证同一时间只会有一个线程执行目标代码段来实现的。</li>
<li>除了从应用层面保证目标代码段执行的顺序性外，JVM还通过被称为happens-before原则隐式地保证顺序性。两个操作的执行顺序只要可以通过happens-before推导出来，则JVM会保证其顺序性，反之JVM对其顺序性不作任何保证，可对其进行任意必要的重新排序以获取高效率。</li>
</ul>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="实际开发问题"><a href="#实际开发问题" class="headerlink" title="实际开发问题"></a>实际开发问题</h3><ul>
<li>在我们的开发中经常会使用到多线程。例如在Android中，由于主线程的诸多限制，像网络请求等一些耗时的操作我们必须在子线程中运行。</li>
<li>我们往往会通过new Thread来开启一个子线程，待子线程操作完成以后通过Handler切换到主线程中运行。这么以来我们无法管理我们所创建的子线程，并且无限制的创建子线程，它们相互之间竞争，很有可能由于占用过多资源而导致死机或者OOM。所以在Java中为我们提供了线程池来管理我们所创建的线程。</li>
</ul>
<h3 id="线程池的优势"><a href="#线程池的优势" class="headerlink" title="线程池的优势"></a>线程池的优势</h3><ul>
<li>①降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；</li>
<li>②提高系统响应速度，当有任务到达时，无需等待新线程的创建便能立即执行；</li>
<li>③方便线程并发数的管控，线程若是无限制的创建，不仅会额外消耗大量系统资源，更是占用过多资源而阻塞系统或oom等状况，从而降低系统的稳定性。线程池能有效管控线程，统一分配、调优，提供资源使用率；</li>
<li>④更强大的功能，线程池提供了定时、定期以及可控线程数等功能的线程池，使用方便简单。</li>
</ul>
<h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><ul>
<li><p>可以通过ThreadPoolExecutor来创建一个线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(....);</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面我们就来看一下ThreadPoolExecutor中的一个构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">	<span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">	<span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">	TimeUnit unit,</span></span><br><span class="line"><span class="params">	BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">	ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">	RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ThreadPoolExecutor参数含义</p>
</li>
<li><p><strong>1.corePoolSize</strong></p>
<ul>
<li>线程池中的核心线程数，默认情况下，核心线程一直存活在线程池中，即便他们在线程池中处于闲置状态。除非我们将ThreadPoolExecutor的allowCoreThreadTimeOut属性设为true的时候，这时候处于闲置的核心线程在等待新任务到来时会有超时策略，这个超时时间由keepAliveTime来指定。一旦超过所设置的超时时间，闲置的核心线程就会被终止。</li>
</ul>
</li>
<li><p><strong>2.maximumPoolSize</strong></p>
<ul>
<li>线程池中所容纳的最大线程数，如果活动的线程达到这个数值以后，后续的新任务将会被阻塞。包含核心线程数+非核心线程数。</li>
</ul>
</li>
<li><p><strong>3.keepAliveTime</strong></p>
<ul>
<li>非核心线程闲置时的超时时长，对于非核心线程，闲置时间超过这个时间，非核心线程就会被回收。只有对ThreadPoolExecutor的allowCoreThreadTimeOut属性设为true的时候，这个超时时间才会对核心线程产生效果。</li>
</ul>
</li>
<li><p><strong>4.unit</strong></p>
<ul>
<li>用于指定keepAliveTime参数的时间单位。他是一个枚举，可以使用的单位有天（TimeUnit.DAYS），小时（TimeUnit.HOURS），分钟（TimeUnit.MINUTES），毫秒(TimeUnit.MILLISECONDS)，微秒(TimeUnit.MICROSECONDS, 千分之一毫秒)和毫微秒(TimeUnit.NANOSECONDS, 千分之一微秒);</li>
</ul>
</li>
<li><p><strong>5.workQueue</strong></p>
<ul>
<li><p>线程池中保存等待执行的任务的阻塞队列。通过线程池中的execute方法提交的Runable对象都会存储在该队列中。我们可以选择下面几个阻塞队列。我们还能够通过实现BlockingQueue接口来自定义我们所需要的阻塞队列。</p>
<table>
<thead>
<tr>
<th>阻塞队列</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayBlockingQueue</td>
<td>基于数组实现的有界的阻塞队列,该队列按照FIFO（先进先出）原则对队列中的元素进行排序。</td>
</tr>
<tr>
<td>LinkedBlockingQueue</td>
<td>基于链表实现的阻塞队列，该队列按照FIFO（先进先出）原则对队列中的元素进行排序。</td>
</tr>
<tr>
<td>SynchronousQueue</td>
<td>内部没有任何容量的阻塞队列。在它内部没有任何的缓存空间。对于SynchronousQueue中的数据元素只有当我们试着取走的时候才可能存在。</td>
</tr>
<tr>
<td>PriorityBlockingQueue</td>
<td>具有优先级的无限阻塞队列。</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>6.threadFactory</strong></p>
<ul>
<li>线程工厂，为线程池提供新线程的创建。ThreadFactory是一个接口，里面只有一个newThread方法。 默认为DefaultThreadFactory类。</li>
</ul>
</li>
<li><p><strong>7.handler</strong></p>
<ul>
<li><p>是RejectedExecutionHandler对象，而RejectedExecutionHandler是一个接口，里面只有一个rejectedExecution方法。<strong>当任务队列已满并且线程池中的活动线程已经达到所限定的最大值或者是无法成功执行任务，这时候ThreadPoolExecutor会调用RejectedExecutionHandler中的rejectedExecution方法。</strong>在ThreadPoolExecutor中有四个内部类实现了RejectedExecutionHandler接口。在线程池中<strong>它默认是AbortPolicy，在无法处理新任务时抛出RejectedExecutionException异常</strong>。</p>
</li>
<li><p>下面是在ThreadPoolExecutor中提供的四个可选值。</p>
</li>
<li><p>我们也可以通过实现RejectedExecutionHandler接口来自定义我们自己的handler。如记录日志或持久化不能处理的任务。</p>
<table>
<thead>
<tr>
<th>可选值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CallerRunsPolicy</td>
<td>只用调用者所在线程来运行任务。</td>
</tr>
<tr>
<td>AbortPolicy</td>
<td>直接抛出RejectedExecutionException异常。</td>
</tr>
<tr>
<td>DiscardPolicy</td>
<td>丢弃掉该任务，不进行处理。</td>
</tr>
<tr>
<td>DiscardOldestPolicy</td>
<td>丢弃队列里最近的一个任务，并执行当前任务。</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h3 id="ThreadPoolExecutor使用"><a href="#ThreadPoolExecutor使用" class="headerlink" title="ThreadPoolExecutor使用"></a>ThreadPoolExecutor使用</h3><ul>
<li><p>如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">10</span>, <span class="number">10</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;());</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于ThreadPoolExecutor有多个构造方法，对于上面的构造方法中的其他参数都采用默认值。可以通过execute和submit两种方式来向线程池提交一个任务。</p>
</li>
<li><p><strong>execute</strong></p>
<ul>
<li>当我们使用execute来提交任务时，由于execute方法没有返回值，所以说我们也就无法判定任务是否被线程池执行成功。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">service.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;execute方式&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>submit</strong></p>
<ul>
<li>当我们使用submit来提交任务时,它会返回一个future,我们就可以通过这个future来判断任务是否执行成功，还可以通过future的get方法来获取返回值。如果子线程任务没有完成，get方法会阻塞住直到任务完成，而使用get(long timeout, TimeUnit unit)方法则会阻塞一段时间后立即返回，这时候有可能任务并没有执行完。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Integer&gt; future = service.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;submit方式&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> future.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程池关闭</p>
<ul>
<li>调用线程池的<code>shutdown()</code>或<code>shutdownNow()</code>方法来关闭线程池</li>
<li>shutdown原理：将线程池状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</li>
<li>shutdownNow原理：将线程池的状态设置成STOP状态，然后中断所有任务(包括正在执行的)的线程，并返回等待执行任务的列表。</li>
<li><strong>中断采用interrupt方法，所以无法响应中断的任务可能永远无法终止。</strong> 但调用上述的两个关闭之一，isShutdown()方法返回值为true，当所有任务都已关闭，表示线程池关闭完成，则isTerminated()方法返回值为true。当需要立刻中断所有的线程，不一定需要执行完任务，可直接调用shutdownNow()方法。</li>
</ul>
</li>
</ul>
<h3 id="线程池执行流程"><a href="#线程池执行流程" class="headerlink" title="线程池执行流程"></a>线程池执行流程</h3><ul>
<li>大概的流程图如下<ul>
<li><img src= "/medias/detail/load.gif" data-lazy-src="/p/59178860/c4450b042b69dbd6d6bc70e681eb0541.png"></li>
</ul>
</li>
<li>文字描述如下<ul>
<li>①如果在线程池中的线程数量没有达到核心的线程数量，这时候就回启动一个核心线程来执行任务。</li>
<li>②如果线程池中的线程数量已经超过核心线程数，这时候任务就会被插入到任务队列中排队等待执行。</li>
<li>③由于任务队列已满，无法将任务插入到任务队列中。这个时候如果线程池中的线程数量没有达到线程池所设定的最大值，那么这时候就会立即启动一个非核心线程来执行任务。</li>
<li>④如果线程池中的数量达到了所规定的最大值，那么就会拒绝执行此任务，这时候就会调用RejectedExecutionHandler中的rejectedExecution方法来通知调用者。</li>
</ul>
</li>
</ul>
<h2 id="四种线程池类"><a href="#四种线程池类" class="headerlink" title="四种线程池类"></a>四种线程池类</h2><ul>
<li>Java中四种具有不同功能常见的线程池。<ul>
<li>他们都是直接或者间接配置ThreadPoolExecutor来实现他们各自的功能。这四种线程池分别是newFixedThreadPool,newCachedThreadPool,newScheduledThreadPool和newSingleThreadExecutor。这四个线程池可以通过Executors类获取。</li>
</ul>
</li>
</ul>
<h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><ul>
<li><p>通过Executors中的newFixedThreadPool方法来创建，该线程池是一种线程数量固定的线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在这个线程池中 <strong>所容纳最大的线程数就是我们设置的核心线程数。</strong></p>
<ul>
<li>如果线程池的线程处于空闲状态的话，它们并不会被回收，除非是这个线程池被关闭。如果所有的线程都处于活动状态的话，新任务就会处于等待状态，直到有线程空闲出来。</li>
<li>由于newFixedThreadPool只有核心线程，并且这些线程都不会被回收，也就是<strong>它能够更快速的响应外界请求</strong> 。</li>
</ul>
</li>
<li><p>从下面的newFixedThreadPool方法的实现可以看出，newFixedThreadPool只有核心线程，并且不存在超时机制，采用LinkedBlockingQueue，所以对于任务队列的大小也是没有限制的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">		<span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><ul>
<li><p>通过Executors中的newCachedThreadPool方法来创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">		<span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过s上面的newCachedThreadPool方法在这里我们可以看出它的 <strong>核心线程数为0，</strong> 线程池的最大线程数Integer.MAX_VALUE。而Integer.MAX_VALUE是一个很大的数，也差不多可以说 <strong>这个线程池中的最大线程数可以任意大。</strong></p>
<ul>
<li><strong>当线程池中的线程都处于活动状态的时候，线程池就会创建一个新的线程来处理任务。该线程池中的线程超时时长为60秒，所以当线程处于闲置状态超过60秒的时候便会被回收。</strong></li>
<li>这也就意味着若是整个线程池的线程都处于闲置状态超过60秒以后，在newCachedThreadPool线程池中是不存在任何线程的，所以这时候它几乎不占用任何的系统资源。</li>
<li>对于newCachedThreadPool他的任务队列采用的是SynchronousQueue，上面说到在SynchronousQueue内部没有任何容量的阻塞队列。SynchronousQueue内部相当于一个空集合，我们无法将一个任务插入到SynchronousQueue中。所以说在线程池中如果现有线程无法接收任务,将会创建新的线程来执行任务。</li>
</ul>
</li>
</ul>
<h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><ul>
<li><p>通过Executors中的newScheduledThreadPool方法来创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>它的核心线程数是固定的，对于非核心线程几乎可以说是没有限制的，并且当非核心线程处于限制状态的时候就会立即被回收。</p>
<ul>
<li>创建一个可定时执行或周期执行任务的线程池：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line">service.schedule(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">&quot;延迟三秒执行&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">service.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">&quot;延迟三秒后每隔2秒执行&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;, <span class="number">3</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>输出结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-2延迟三秒后每隔2秒执行</span><br><span class="line">pool-1-thread-1延迟三秒执行</span><br><span class="line">pool-1-thread-1延迟三秒后每隔2秒执行</span><br><span class="line">pool-1-thread-2延迟三秒后每隔2秒执行</span><br><span class="line">pool-1-thread-2延迟三秒后每隔2秒执行</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>部分方法说明</p>
<ul>
<li><code>schedule(Runnable command, long delay, TimeUnit unit)</code>：延迟一定时间后执行Runnable任务；</li>
<li><code>schedule(Callable callable, long delay, TimeUnit unit)</code>：延迟一定时间后执行Callable任务；</li>
<li><code>scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</code>：延迟一定时间后，以间隔period时间的频率周期性地执行任务；</li>
<li><code>scheduleWithFixedDelay(Runnable command, long initialDelay, long delay,TimeUnit unit)</code>:与scheduleAtFixedRate()方法很类似，但是不同的是scheduleWithFixedDelay()方法的周期时间间隔是以上一个任务执行结束到下一个任务开始执行的间隔，而scheduleAtFixedRate()方法的周期时间间隔是以上一个任务开始执行到下一个任务开始执行的间隔，也就是这一些任务系列的触发时间都是可预知的。</li>
</ul>
</li>
<li><p>ScheduledExecutorService功能强大，对于定时执行的任务，建议多采用该方法。</p>
</li>
</ul>
<h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><ul>
<li><p>通过Executors中的newSingleThreadExecutor方法来创建，<strong>在这个线程池中只有一个核心线程</strong>，对于任务队列没有大小限制，也就意味着<strong>这一个任务处于活动状态时，其他任务都会在任务队列中排队等候依次执行</strong>。</p>
</li>
<li><p>newSingleThreadExecutor将所有的外界任务统一到一个线程中支持，所以在这个任务执行之间我们不需要处理线程同步的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">	(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">		<span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="线程池的使用技巧"><a href="#线程池的使用技巧" class="headerlink" title="线程池的使用技巧"></a>线程池的使用技巧</h3><ul>
<li><p>需要针对具体情况而具体处理，不同的任务类别应采用不同规模的线程池，任务类别可划分为CPU密集型任务、IO密集型任务和混合型任务。(N代表CPU个数)</p>
<table>
<thead>
<tr>
<th>任务类别</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CPU密集型任务</td>
<td>线程池中线程个数应尽量少，如配置N+1个线程的线程池。</td>
</tr>
<tr>
<td>IO密集型任务</td>
<td>由于IO操作速度远低于CPU速度，那么在运行这类任务时，CPU绝大多数时间处于空闲状态，那么线程池可以配置尽量多些的线程，以提高CPU利用率，如2*N。</td>
</tr>
<tr>
<td>混合型任务</td>
<td>可以拆分为CPU密集型任务和IO密集型任务，当这两类任务执行时间相差无几时，通过拆分再执行的吞吐率高于串行执行的吞吐率，但若这两类任务执行时间有数据级的差距，那么没有拆分的意义。</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h2><h3 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h3><ul>
<li><strong>平时项目中使用锁和synchronized比较多，而很少使用volatile，难道就没有保证可见性？</strong></li>
<li>锁可以保证可见性？<ul>
<li>锁和synchronized即可以保证原子性，也可以保证可见性。都是通过保证同一时间只有一个线程执行目标代码段来实现的。</li>
</ul>
</li>
<li>锁和synchronized即可保证原子性也可保证可见性，为何还需要volatile？<ul>
<li>synchronized和锁需要通过操作系统来仲裁谁获得锁，开销比较高，而volatile开销小很多。因此在只需要保证可见性的条件下，使用volatile的性能要比使用锁和synchronized高得多。</li>
</ul>
</li>
<li>既然锁和synchronized可以保证原子性，为什么还需要AtomicInteger这种的类来保证原子操作？<ul>
<li>锁和synchronized需要通过操作系统来仲裁谁获得锁，开销比较高，而AtomicInteger是通过CPU级的CAS操作来保证原子性，开销比较小。所以使用AtomicInteger的目的还是为了提高性能。</li>
</ul>
</li>
<li>synchronized即可修饰非静态方式，也可修饰静态方法，还可修饰代码块，有何区别<ul>
<li>synchronized修饰非静态同步方法时，锁住的是当前实例；synchronized修饰静态同步方法时，锁住的是该类的Class对象；synchronized修饰静态代码块时，锁住的是synchronized关键字后面括号内的对象。</li>
</ul>
</li>
</ul>
<h3 id="线程问题"><a href="#线程问题" class="headerlink" title="线程问题"></a>线程问题</h3><ul>
<li><p>经典面试题：现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？</p>
<ul>
<li>Thread类中的join方法的主要作用就是同步，它可以使得线程之间的并行执行变为串行执行。当我们调用某个线程的这个方法时，这个方法会挂起调用线程，直到被调用线程结束执行，调用线程才会继续执行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            Log.d(<span class="string">&quot;线程执行&quot;</span>,<span class="string">&quot;Thread1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            Log.d(<span class="string">&quot;线程执行&quot;</span>,<span class="string">&quot;Thread2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            Log.d(<span class="string">&quot;线程执行&quot;</span>,<span class="string">&quot;Thread3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        t1.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t2.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        t2.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t3.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        t3.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">18</span>:<span class="number">12</span>:<span class="number">16.633</span> <span class="number">14354</span>-<span class="number">14423</span>/cn.ycbjie.ycthreadpool D/线程执行: Thread1</span><br><span class="line"><span class="number">2019</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">18</span>:<span class="number">12</span>:<span class="number">16.634</span> <span class="number">14354</span>-<span class="number">14424</span>/cn.ycbjie.ycthreadpool D/线程执行: Thread2</span><br><span class="line"><span class="number">2019</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">18</span>:<span class="number">12</span>:<span class="number">16.635</span> <span class="number">14354</span>-<span class="number">14425</span>/cn.ycbjie.ycthreadpool D/线程执行: Thread3</span><br></pre></td></tr></table></figure>
</li>
<li><p>另一种写法，发现并不是按照t1、t2、t3的执行顺序的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            Log.d(<span class="string">&quot;线程执行&quot;</span>,<span class="string">&quot;Thread1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            Log.d(<span class="string">&quot;线程执行&quot;</span>,<span class="string">&quot;Thread2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            Log.d(<span class="string">&quot;线程执行&quot;</span>,<span class="string">&quot;Thread3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  </span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        t1.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        t2.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        t3.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">18</span>:<span class="number">21</span>:<span class="number">58.182</span> <span class="number">14868</span>-<span class="number">14939</span>/cn.ycbjie.ycthreadpool D/线程执行: Thread3</span><br><span class="line"><span class="number">2019</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">18</span>:<span class="number">21</span>:<span class="number">58.182</span> <span class="number">14868</span>-<span class="number">14937</span>/cn.ycbjie.ycthreadpool D/线程执行: Thread1</span><br><span class="line"><span class="number">2019</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">18</span>:<span class="number">21</span>:<span class="number">58.182</span> <span class="number">14868</span>-<span class="number">14938</span>/cn.ycbjie.ycthreadpool D/线程执行: Thread2</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果不适用join，还可以用什么方式，使用锁也可以实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ShareThread</span> <span class="variable">sh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShareThread</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sh.Test01();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sh.Test02();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sh.Test03();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;T3&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShareThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// flag作为标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">c1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">c2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">c3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test01</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">1</span>) &#123;</span><br><span class="line">                c1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;正在执行的是:&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            flag = <span class="number">2</span>;</span><br><span class="line">            c2.signal();<span class="comment">// 通知一个线程来执行</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test02</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">2</span>) &#123;</span><br><span class="line">                c2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;正在执行的是:&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            flag = <span class="number">3</span>;</span><br><span class="line">            c3.signal();<span class="comment">// 通知一个线程来执行</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test03</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">3</span>) &#123;</span><br><span class="line">                c3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;正在执行的是:&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            c1.signal();<span class="comment">// 通知一个线程来执行</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">18</span>:<span class="number">29</span>:<span class="number">15.153</span> <span class="number">15531</span>-<span class="number">15593</span>/cn.ycbjie.ycthreadpool I/System.out: 正在执行的是:T1</span><br><span class="line"><span class="number">2019</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">18</span>:<span class="number">29</span>:<span class="number">15.154</span> <span class="number">15531</span>-<span class="number">15594</span>/cn.ycbjie.ycthreadpool I/System.out: 正在执行的是:T2</span><br><span class="line"><span class="number">2019</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">18</span>:<span class="number">29</span>:<span class="number">15.154</span> <span class="number">15531</span>-<span class="number">15595</span>/cn.ycbjie.ycthreadpool I/System.out: 正在执行的是:T3</span><br></pre></td></tr></table></figure></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://fulsun.github.io">凉月</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://fulsun.github.io/p/59178860">https://fulsun.github.io/p/59178860</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://fulsun.github.io" target="_blank">凉月の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></div><div class="post_share"><div class="social-share" data-image="/medias/featureimages/003.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/641e58d6" title="Java锁的使用"><img class="cover" src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/003.jpg" onerror="onerror=null;src='/medias/detail/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java锁的使用</div></div></a></div><div class="next-post pull-right"><a href="/p/bcd2273a" title="Java深浅拷贝和序列化拷贝"><img class="cover" src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/006.jpg" onerror="onerror=null;src='/medias/detail/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java深浅拷贝和序列化拷贝</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/p/641e58d6" title="Java锁的使用"><img class="cover" src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/003.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-08-24</div><div class="title">Java锁的使用</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/avatar.jpg" onerror="this.onerror=null;this.src='/medias/detail/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">凉月</div><div class="author-info__description">记录生活,分享知识。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/fulsun"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/fulsun" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:fl_6145@163.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">感谢访问本站，若喜欢请收藏 ^_^</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-text">进程概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-text">多进程的意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">进程状态有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-text">进程状态转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-text">进程通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-text">进程同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E6%A0%B8%E5%BF%83%E6%80%81"><span class="toc-text">用户态和核心态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="toc-text">进程死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">进程调度算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E6%84%8F%E4%B9%89"><span class="toc-text">多线程有什么意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91"><span class="toc-text">并行和并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-text">Java程序运行原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E7%9A%84%E5%90%AF%E5%8A%A8%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%97"><span class="toc-text">JVM的启动是多线程的吗</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB"><span class="toc-text">进程与线程区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%AB"><span class="toc-text">概念区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%8C%BA%E5%88%AB"><span class="toc-text">调度区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E8%A1%8C%E5%8C%BA%E5%88%AB"><span class="toc-text">并发行区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A5%E6%9C%89%E8%B5%84%E6%BA%90%E5%AF%B9%E6%AF%94"><span class="toc-text">拥有资源对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%BC%80%E9%94%80%E5%AF%B9%E6%AF%94"><span class="toc-text">系统开销对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-text">线程创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="toc-text">继承Thread类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-text">通过Runnable接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87Callable%E5%92%8CFuture"><span class="toc-text">通过Callable和Future</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB"><span class="toc-text">三种创建线程区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#run%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">run方法的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#start%E5%92%8Crun%E5%8C%BA%E5%88%AB"><span class="toc-text">start和run区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BD%95%E4%B8%8D%E8%83%BD%E9%87%8D%E5%A4%8Dstart"><span class="toc-text">为何不能重复start</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">线程的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#wait%E5%92%8Csleep%E6%96%B9%E6%B3%95"><span class="toc-text">wait和sleep方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-text">线程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98"><span class="toc-text">线程的调度问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%B8%A4%E7%A7%8D%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B"><span class="toc-text">线程有两种调度模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">线程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%91%E7%9C%A0%E7%BA%BF%E7%A8%8B"><span class="toc-text">休眠线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait%E5%92%8Csleep%E6%96%B9%E6%B3%95-1"><span class="toc-text">wait和sleep方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%85%A5%E7%BA%BF%E7%A8%8B"><span class="toc-text">加入线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">join方法实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BC%E8%AE%A9%E7%BA%BF%E7%A8%8B"><span class="toc-text">礼让线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-text">守护线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B"><span class="toc-text">中断线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B"><span class="toc-text">启动线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%85%B3%E9%97%AD"><span class="toc-text">线程关闭</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%80%80%E5%87%BA%E6%A0%87%E5%BF%97%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="toc-text">使用退出标志终止线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8interrupt-%E6%96%B9%E6%B3%95%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="toc-text">使用interrupt()方法终止线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8stop%E6%96%B9%E6%B3%95%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="toc-text">使用stop方法终止线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-text">线程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#wait-notify"><span class="toc-text">wait()&#x2F;notify()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait-%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">wait()方法使用注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#notify-%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">notify()方法使用注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait-notify-%E5%8D%8F%E4%BD%9C"><span class="toc-text">wait()&#x2F;notify()协作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Condition%E5%AE%9E%E7%8E%B0%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5"><span class="toc-text">Condition实现等待&#x2F;通知</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Condition%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="toc-text">Condition简单介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Condition%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">Condition实现方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="toc-text">生产者消费者模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%94%9F%E4%BA%A7%E4%B8%8E%E4%B8%80%E6%B6%88%E8%B4%B9%E6%A1%88%E4%BE%8B"><span class="toc-text">一生产与一消费案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%94%9F%E4%BA%A7%E4%B8%8E%E5%A4%9A%E6%B6%88%E8%B4%B9%E6%A1%88%E4%BE%8B"><span class="toc-text">多生产与多消费案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%9A%E9%81%87%E5%88%B0%E5%93%AA%E4%BA%9B%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98"><span class="toc-text">会遇到哪些关键问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98"><span class="toc-text">如何解决关键问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91"><span class="toc-text">多线程并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BFThread%E7%B1%BB%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8D%96%E7%94%B5%E5%BD%B1%E7%A5%A8%E6%A1%88%E4%BE%8B"><span class="toc-text">继承Thread类的方式卖电影票案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8D%96%E7%94%B5%E5%BD%B1%E7%A5%A8"><span class="toc-text">实现Runnable接口的方式卖电影票</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E7%A5%A8%E5%92%8C%E8%B4%9F%E6%95%B0%E7%A5%A8%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90"><span class="toc-text">同票和负数票的原因分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90"><span class="toc-text">线程安全问题的产生原因分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E6%96%B9%E5%BC%8F%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-text">同步代码块的方式解决线程安全问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%89%B9%E6%80%A7"><span class="toc-text">线程安全特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-text">什么是线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%BA%A7%E5%88%AB"><span class="toc-text">线程安全级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-text">多线程三要素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-text">如何理解原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-text">如何理解可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-text">如何理解有序性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E8%A6%81%E7%B4%A0%E4%BD%9C%E7%94%A8"><span class="toc-text">三要素作用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91"><span class="toc-text">处理多线程并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-text">保证原子性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5"><span class="toc-text">第一种方式：锁和同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9ACAS"><span class="toc-text">第二种方式：CAS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-text">保证可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-text">保证有序性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-text">实际开发问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">线程池的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadPoolExecutor"><span class="toc-text">ThreadPoolExecutor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadPoolExecutor%E4%BD%BF%E7%94%A8"><span class="toc-text">ThreadPoolExecutor使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">线程池执行流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B1%BB"><span class="toc-text">四种线程池类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#newFixedThreadPool"><span class="toc-text">newFixedThreadPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newCachedThreadPool"><span class="toc-text">newCachedThreadPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newScheduledThreadPool"><span class="toc-text">newScheduledThreadPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newSingleThreadExecutor"><span class="toc-text">newSingleThreadExecutor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7"><span class="toc-text">线程池的使用技巧</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98"><span class="toc-text">面试问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-text">并发问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98"><span class="toc-text">线程问题</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/p/94e3914c" title="Import 注册组件"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/008.jpg" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Import 注册组件"/></a><div class="content"><a class="title" href="/p/94e3914c" title="Import 注册组件">Import 注册组件</a><time datetime="2024-07-15T22:24:08.000Z" title="发表于 2024-07-15 22:24:08">2024-07-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/a0c53761" title="Configuration Bean 注册组件"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/012.jpg" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Configuration Bean 注册组件"/></a><div class="content"><a class="title" href="/p/a0c53761" title="Configuration Bean 注册组件">Configuration Bean 注册组件</a><time datetime="2024-07-15T21:24:08.000Z" title="发表于 2024-07-15 21:24:08">2024-07-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/65826306" title="Spring5新功能"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/008.jpg" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Spring5新功能"/></a><div class="content"><a class="title" href="/p/65826306" title="Spring5新功能">Spring5新功能</a><time datetime="2024-07-14T17:24:08.000Z" title="发表于 2024-07-14 17:24:08">2024-07-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/40bb048a" title="JdbcTemplate与声明式事务"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/013.jpg" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="JdbcTemplate与声明式事务"/></a><div class="content"><a class="title" href="/p/40bb048a" title="JdbcTemplate与声明式事务">JdbcTemplate与声明式事务</a><time datetime="2024-07-14T11:24:08.000Z" title="发表于 2024-07-14 11:24:08">2024-07-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/92933cdb" title="Spring-AOP编程"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/012.jpg" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Spring-AOP编程"/></a><div class="content"><a class="title" href="/p/92933cdb" title="Spring-AOP编程">Spring-AOP编程</a><time datetime="2024-07-14T09:24:38.000Z" title="发表于 2024-07-14 09:24:38">2024-07-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 凉月</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://unpkg.com/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.js"></script><script src="https://unpkg.com/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null

  const initWaline = (Fn) => {
    const waline = Fn(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-fulsun.netlify.app/.netlify/functions/comment',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))

    const destroyWaline = () => {
      waline.destroy()
    }

    btf.addGlobalFn('pjax', destroyWaline, 'destroyWaline')
  }

  const loadWaline = async () => {
    if (initFn) initWaline(initFn)
    else {
      await getCSS('https://unpkg.com/@waline/client@3.1.2/dist/waline.css')
      const { init } = await import('https://unpkg.com/@waline/client@3.1.2/dist/waline.js')
      initFn = init || Waline.init
      initWaline(initFn)
      window.walineFn = initFn
    }
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://unpkg.com/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>