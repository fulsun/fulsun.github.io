<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java8的Stream和Optional | 凉月の博客</title><meta name="author" content="凉月"><meta name="copyright" content="凉月"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java 8引入了全新的Stream API。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java8的Stream和Optional">
<meta property="og:url" content="https://fulsun.github.io/p/c735a0b1">
<meta property="og:site_name" content="凉月の博客">
<meta property="og:description" content="Java 8引入了全新的Stream API。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fulsun.github.io/medias/featureimages/006.jpg">
<meta property="article:published_time" content="2018-09-02T11:00:00.000Z">
<meta property="article:modified_time" content="2024-10-17T07:06:55.382Z">
<meta property="article:author" content="凉月">
<meta property="article:tag" content="凉月">
<meta property="article:tag" content="凉月文">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="web网站">
<meta property="article:tag" content="经验分享">
<meta property="article:tag" content="hexo">
<meta property="article:tag" content="个人博客">
<meta property="article:tag" content="生活记录等">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fulsun.github.io/medias/featureimages/006.jpg"><link rel="shortcut icon" href="/medias/favicon.png"><link rel="canonical" href="https://fulsun.github.io/p/c735a0b1"><link rel="preconnect" href="//unpkg.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"至上次更新后的","messageNext":"天,文章内容可能已过时。"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 凉月","link":"链接: ","source":"来源: 凉月の博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://unpkg.com/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java8的Stream和Optional',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-17 07:06:55'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/avatar.jpg" onerror="onerror=null;src='/medias/detail/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-heartbeat"></i><span> 我的</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> 联系</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user-circle"></i><span> 博主</span></a></li><li><a class="site-page child" href="/contact"><i class="fa-fw fas fa-comments"></i><span> 留言</span></a></li><li><a class="site-page child" href="/journal"><i class="fa-fw fas fa-cogs"></i><span> 日志</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> JS动画</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/snake/"><i class="fa-fw fas fa-gamepad"></i><span> 贪吃蛇</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/medias/featureimages/006.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="凉月の博客"><span class="site-name">凉月の博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-heartbeat"></i><span> 我的</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> 联系</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user-circle"></i><span> 博主</span></a></li><li><a class="site-page child" href="/contact"><i class="fa-fw fas fa-comments"></i><span> 留言</span></a></li><li><a class="site-page child" href="/journal"><i class="fa-fw fas fa-cogs"></i><span> 日志</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> JS动画</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/snake/"><i class="fa-fw fas fa-gamepad"></i><span> 贪吃蛇</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java8的Stream和Optional</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2018-09-02T11:00:00.000Z" title="发表于 2018-09-02 11:00:00">2018-09-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-17T07:06:55.382Z" title="更新于 2024-10-17 07:06:55">2024-10-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JavaSE/">JavaSE</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>47分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java8的Stream和Optional"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><span id="more"></span>

<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><ul>
<li><p>Java 8引入了全新的Stream API。这里的Stream和I&#x2F;O流不同，它更像具有Iterable的集合类，但行为和集合类又有所不同。</p>
</li>
<li><p>最新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码.</p>
</li>
</ul>
<h2 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h2><ul>
<li><p><strong>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的</strong>，它更像一个高级版本的 Iterator。</p>
</li>
<li><p>原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。</p>
</li>
<li><p>你可以将 Streams 视为 Java 中第一个充分利用了lambda表达式的强大功能的库，但它没有什么特别奇妙的地方（尽管它被紧密集成到核心 JDK 库中）。Streams 不是该语言的一部分 — 它是一个精心设计的库，充分利用了一些较新的语言特性。</p>
</li>
<li><p>Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。</p>
</li>
<li><p>而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。</p>
<ul>
<li>当使用串行方式去遍历时，每个 item 读完后再读下一个 item。</li>
<li>而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。</li>
<li>Stream 的并行操作依赖于 Java7 中引入的 Fork&#x2F;Join 框架（JSR166y）来拆分任务和加速处理过程。</li>
</ul>
</li>
<li><p>Java 的并行 API 演变历程基本如下：</p>
<ul>
<li>1.0-1.4 中的 java.lang.Thread</li>
<li>5.0 中的 java.util.concurrent</li>
<li>6.0 中的 Phasers 等</li>
<li>7.0 中的 Fork&#x2F;Join 框架</li>
<li>8.0 中的 Lambda</li>
</ul>
</li>
<li><p><strong>Stream 的另外一大特点是，数据源本身可以是无限的。</strong></p>
</li>
</ul>
<h3 id="集合和流的差异"><a href="#集合和流的差异" class="headerlink" title="集合和流的差异"></a>集合和流的差异</h3><ul>
<li>流并不存储其元素</li>
<li>流的操作不会修改其数据源</li>
<li>流的操作是尽可能惰性执行的</li>
</ul>
<h2 id="流的创建"><a href="#流的创建" class="headerlink" title="流的创建"></a>流的创建</h2><ul>
<li><p>Collection接口下的两个方法可以获取流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterable</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">//将集合转换为一个流</span></span><br><span class="line">    <span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">stream</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生当前集合中所有元素的顺序流或并行流</span></span><br><span class="line">    <span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">parallelStream</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组的静态Stream.of方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Stream</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">BaseStream</span>&lt;T, Stream&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生一个元素为给定值的流</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">of</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(<span class="keyword">new</span> <span class="title class_">Streams</span>.StreamBuilderImpl&lt;&gt;(t), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生一个元素为给定值的流，这里是不定长参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">of</span><span class="params">(T... values)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Array.stream(array, from, to)方法可以从数组中位于from（包括）和to（不包括）的元素中创建一个流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Arrays</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">stream</span><span class="params">(T[] array, <span class="type">int</span> startInclusive, <span class="type">int</span> endExclusive)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(spliterator(array, startInclusive, endExclusive), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">stream</span><span class="params">(T[] array)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stream(array, <span class="number">0</span>, array.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建不包含任何元素的流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Stream</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">BaseStream</span>&lt;T, Stream&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(Spliterators.&lt;T&gt;emptySpliterator(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建无限流的静态方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Stream</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">BaseStream</span>&lt;T, Stream&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接受一个不包含任何引元的函数（从技术上将，是一个Supplier&lt;T&gt;接口的对象），创建无限流</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">generate</span><span class="params">(Supplier&lt;T&gt; s)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(s);</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">StreamSpliterators</span>.InfiniteSupplyingSpliterator.OfRef&lt;&gt;(Long.MAX_VALUE, s), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接受一个“种子”值，以及一个函数（UnaryOperation&lt;T&gt;），产生无限序列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">iterate</span><span class="params">(<span class="keyword">final</span> T seed, <span class="keyword">final</span> UnaryOperator&lt;T&gt; f)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(f);</span><br><span class="line">        <span class="keyword">final</span> Iterator&lt;T&gt; iterator = <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;T&gt;() &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> (T) Streams.NONE;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">return</span> <span class="variable">t</span> <span class="operator">=</span> (t == Streams.NONE) ? seed : f.apply(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(Spliterators.spliteratorUnknownSize(</span><br><span class="line">                iterator,</span><br><span class="line">                Spliterator.ORDERED | Spliterator.IMMUTABLE), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Java API中还有大量可以创建流的方法，这里就不一一列举了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Collection接口的stream()方法</span></span><br><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">arrayList.add(<span class="number">1</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = arrayList.stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//并行流</span></span><br><span class="line">Stream&lt;Integer&gt; parallelStream = arrayList.parallelStream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态Stream.of()方法</span></span><br><span class="line">Stream&lt;Integer&gt; stream1 = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Stream</span> <span class="variable">stream3</span> <span class="operator">=</span> Stream.empty();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Arrays.stream()方法，把数组中的元素创建一个流</span></span><br><span class="line"><span class="type">int</span>[] sum = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">Stream&lt;Integer&gt; stream2 = (Stream&lt;Integer&gt;) Arrays.stream(sum);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="流的操作"><a href="#流的操作" class="headerlink" title="流的操作"></a>流的操作</h2><p>流的操作类型分为两种：</p>
<ul>
<li><strong>Intermediate</strong>（转换操作）：一个流可以后面跟随零个或多个 intermediate 操作。<strong>其目的主要是打开流，做出某种程度的数据映射&#x2F;过滤，然后返回一个新的流，交给下一个操作使用</strong>。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</li>
<li><strong>Terminal</strong>（终止操作）：<strong>一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了</strong>，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。</li>
</ul>
<h3 id="filter、map、flatMap方法"><a href="#filter、map、flatMap方法" class="headerlink" title="filter、map、flatMap方法"></a>filter、map、flatMap方法</h3><ul>
<li><p>方法定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Stream</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">BaseStream</span>&lt;T, Stream&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个流，该流包含与给定谓词匹配的该流的元素。</span></span><br><span class="line">    Stream&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个流，该流包括将给定函数应用于此流的元素的结果。</span></span><br><span class="line">    &lt;R&gt; Stream&lt;R&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends R&gt; mapper)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个流，该流包括将流中的每个元素替换为通过将提供的映射函数应用于每个元素</span></span><br><span class="line">    <span class="comment">//而生成的映射流的内容而得到的结果。</span></span><br><span class="line">    &lt;R&gt; Stream&lt;R&gt; <span class="title function_">flatMap</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>filter解释</p>
<ul>
<li><p>filter转换会产生一个流，它的元素与某种条件相匹配。它的引元是<code>Predicate&lt;T&gt;</code>，即从<code>T</code>到<code>boolean</code>的函数。</p>
</li>
<li><p><code>Predicate&lt;T&gt;</code>就是一个函数式接口，是一个布尔值函数，即里面的test方法返回的是一个布尔值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转换为只包含长单词的另一个流</span></span><br><span class="line">List&lt;String&gt; wordList = ...;</span><br><span class="line">Stream&lt;String&gt; longWords = wordList.stream().filter(w -&gt; w.length() &gt; <span class="number">12</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>map方法可以按照某种方式来转换流中的值，传递执行该转换的函数。</p>
<ul>
<li><p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将所有单词都转换为小写</span></span><br><span class="line">Stream&lt;String&gt; lowerCaseWords = words.stream().map(String::toLowerCase);</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以使用java8的新特性lambda表达式</span></span><br><span class="line"><span class="comment">//产生的流中包含了所有单词的首字母</span></span><br><span class="line">Stream&lt;String&gt; firstLetters = words.stream().map(s -&gt; s.substring(<span class="number">0</span>,<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果我们在一个字符串流上执行映射操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Stream&lt;String&gt;&gt; result = words.parallelStream().map((s -&gt; s.substring(<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line"><span class="comment">//result:  得到一个流的流</span></span><br><span class="line"><span class="comment">// 比如` [... [&quot;b&quot;,&quot;o&quot;,&quot;a&quot;,&quot;t&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;], ...]`，</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>并行map处理的并不是我们想要的结果，如果我们想要摊平它变回一个流<code> [... &quot;b&quot;,&quot;o&quot;,&quot;a&quot;,&quot;t&quot;, &quot;a&quot;,&quot;a&quot;,&quot;a&quot;, ...]</code>，我们可以使用flatMap方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; flatResult = words.stream().flatMap(s -&gt; s.substring(<span class="number">0</span>,<span class="number">1</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="抽取子流和连接流"><a href="#抽取子流和连接流" class="headerlink" title="抽取子流和连接流"></a>抽取子流和连接流</h3><ul>
<li><p>调用limit方法会返回一个新的流，它在n个元素之后结束（如果原来的流更短，那么就会在流结束时结束）。</p>
<ul>
<li>这个方法对于裁剪无限流的尺寸会显得特别有用</li>
</ul>
</li>
<li><p>调用skip方法正好相反，它会丢弃前n个元素。</p>
<ul>
<li>例如在将文本分隔为单词时，按照split方法的工作方式，第一个元素是没什么用的空字符串，这时候可以用skip跳过它</li>
</ul>
</li>
<li><p>concat方法可以将两个流连接起来。<strong>当然第一流不应该是无限的，否则第二个流永远都不会得到处理的机会。</strong></p>
</li>
<li><p>方法定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Stream</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">BaseStream</span>&lt;T, Stream&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回由该流的元素组成的流，其maxSize长度被截断为不超过长度。</span></span><br><span class="line">    Stream&lt;T&gt; <span class="title function_">limit</span><span class="params">(<span class="type">long</span> maxSize)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在丢弃流的第n个元素之后，返回由该流的其余元素组成的流。</span></span><br><span class="line">    Stream&lt;T&gt; <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个延迟串联的流，其元素是第一个流的所有元素，然后是第二个流的所有元素。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">concat</span><span class="params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(a);</span><br><span class="line">        Objects.requireNonNull(b);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Spliterator&lt;T&gt; split = <span class="keyword">new</span> <span class="title class_">Streams</span>.ConcatSpliterator.OfRef&lt;&gt;(</span><br><span class="line">                (Spliterator&lt;T&gt;) a.spliterator(), (Spliterator&lt;T&gt;) b.spliterator());</span><br><span class="line">        Stream&lt;T&gt; stream = StreamSupport.stream(split, a.isParallel() || b.isParallel());</span><br><span class="line">        <span class="keyword">return</span> stream.onClose(Streams.composedClose(a, b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Double&gt; randoms = Stream.generate(Math::random).limit(<span class="number">100</span>);</span><br><span class="line">Stream&lt;String&gt; words = Stream.of(contents.split(<span class="string">&quot;\\PL+&quot;</span>)).skip(<span class="number">1</span>);</span><br><span class="line">Stream&lt;String&gt; combined = Stream.concat(stream1, stream2);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="其他的流转换"><a href="#其他的流转换" class="headerlink" title="其他的流转换"></a>其他的流转换</h3><ul>
<li><p>distinct方法会返回一个流，它的元素是原有流中经过<strong>剔除重复元素</strong>后产生的。这个流能够记住它已经看到过的元素。</p>
</li>
<li><p>sorted方法会产生一个新的流，并会对元素进行排序。其中一种用于操作Comparable元素的流，而另一种可以接受一个Comparator。</p>
</li>
<li><p>peek方法会产生另一个流，它的元素与原来的流中的元素相同，但是在每次获取一个元素时，都会调用一个函数。</p>
</li>
<li><p>方法定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Stream</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">BaseStream</span>&lt;T, Stream&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回由该流的不同元素组成的流（根据 Object.equals(Object))。</span></span><br><span class="line">    Stream&lt;T&gt; <span class="title function_">distinct</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回由该流的元素组成的流，并根据自然顺序排序。</span></span><br><span class="line">    Stream&lt;T&gt; <span class="title function_">sorted</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回由该流的元素组成的流，并根据提供的进行排序Comparator。</span></span><br><span class="line">    Stream&lt;T&gt; <span class="title function_">sorted</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回由该流的元素组成的流，并在从结果流中消耗元素时对每个元素另外执行提供的操作。</span></span><br><span class="line">    Stream&lt;T&gt; <span class="title function_">peek</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有一个merrily</span></span><br><span class="line">Stream&lt;String&gt; uniqueWords = Stream.of(<span class="string">&quot;merrily&quot;</span>, <span class="string">&quot;merrily&quot;</span>, <span class="string">&quot;merrily&quot;</span>, <span class="string">&quot;merrily&quot;</span>, <span class="string">&quot;gently&quot;</span>).distinct();</span><br><span class="line">Stream&lt;String&gt; longestFirst = words.stream().sorted(Compartor.comparing(String::length).reversed());</span><br><span class="line"><span class="comment">//实际访问一个元素时，就会打印出来一条消息</span></span><br><span class="line">Object[] powers = Stream.iterate(<span class="number">1.0</span>, p -&gt; p*<span class="number">2</span>).peek(e -&gt; System.out.println(e).limit(<span class="number">20</span>).toArray());</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="约简操作"><a href="#约简操作" class="headerlink" title="约简操作"></a>约简操作</h3><ul>
<li><p><strong>约简是一种终结操作，它们会将流约简为可以在程序中使用的非法值。</strong></p>
</li>
<li><p>count方法就是一种简单约简，它会返回流中元素的数量</p>
</li>
<li><p>max和min方法会返回流中元素的最大值和最小值。</p>
<ul>
<li>另外，这些方法返回的是一个类型<code>Optional&lt;T&gt;</code>的值，它要么在其中包装了答案，要么表示没有任何值（因为流碰巧为空）。</li>
</ul>
</li>
<li><p>findFirst返回的是非空集合中的第一个值。它通常会在与filter组合使用时显得很有用。例如，下面展示了如何找到第一个以字母A开头的单词。如果没有则Optional为空</p>
</li>
<li><p>如果不强调使用第一个匹配，而是使用任意的匹配都可以，那么就可以使用findAny方法。</p>
</li>
<li><p>如果只想知道是否存在匹配，那么可以使用anyMatch。这个方法会接受一个断言引元，因此不需要使用filter。</p>
</li>
<li><p>同样的allMatch和noneMatch方法，它们分别会在<strong>所有元素</strong>和<strong>没有任何元素</strong>匹配断言的情况下返回true。</p>
</li>
<li><p>方法定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Stream</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">BaseStream</span>&lt;T, Stream&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回此流中的元素计数。</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据提供的返回此流的最小元素 Comparator。</span></span><br><span class="line">    Optional&lt;T&gt; <span class="title function_">min</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据提供的返回此流的最大元素 Comparator。</span></span><br><span class="line">    Optional&lt;T&gt; <span class="title function_">max</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回Optional描述此流的第一个元素的描述；Optional如果流为空，则返回null 。</span></span><br><span class="line">    Optional&lt;T&gt; <span class="title function_">findFirst</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回Optional描述流中某些元素的描述；Optional如果流为空，则返回空。</span></span><br><span class="line">    Optional&lt;T&gt; <span class="title function_">findAny</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回此流的任何元素是否与提供的谓词匹配。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">anyMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回此流的所有元素是否与提供的谓词匹配。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">allMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回此流中是否没有元素与提供的谓词匹配。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">noneMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用提供的标识值和关联 累加函数对此流的元素 执行归约，然后返回归约后的值。</span></span><br><span class="line">    T <span class="title function_">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行减少有关此流的元件，使用 缔合累积功能，并返回一个Optional描述该减小值，如果有的话。</span></span><br><span class="line">    Optional&lt;T&gt; <span class="title function_">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行减少有关此流的元件，使用所提供的身份，积累和组合功能。</span></span><br><span class="line">    &lt;U&gt; U <span class="title function_">reduce</span><span class="params">(U identity,</span></span><br><span class="line"><span class="params">                 BiFunction&lt;U, ? <span class="built_in">super</span> T, U&gt; accumulator,</span></span><br><span class="line"><span class="params">                 BinaryOperator&lt;U&gt; combiner)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; words = Stream.of(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>);</span><br><span class="line">System.out.println(words.count());</span><br><span class="line"><span class="comment">//输出 ：3</span></span><br><span class="line"></span><br><span class="line">Stream&lt;String&gt; words = Stream.of(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>);</span><br><span class="line">System.out.println(words.max(String::compareToIgnoreCase));</span><br><span class="line"><span class="comment">//输出 Optional[C]</span></span><br><span class="line"></span><br><span class="line">Stream&lt;String&gt; words = Stream.of(<span class="string">&quot;ADD&quot;</span>,<span class="string">&quot;BDD&quot;</span>,<span class="string">&quot;CDD&quot;</span>);</span><br><span class="line">System.out.println(words.filter(s -&gt; s.startsWith(<span class="string">&quot;A&quot;</span>)).findFirst());</span><br><span class="line"><span class="comment">//输出 Optional[ADD]</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">aWordStartsWithQ</span> <span class="operator">=</span> words.parallel().anyMatch(s -&gt; s.startsWith(<span class="string">&quot;A&quot;</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="reduce的说明"><a href="#reduce的说明" class="headerlink" title="reduce的说明"></a>reduce的说明</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li><p>reduce方法是一种用于<strong>从流中计算某个值</strong>的通用机制</p>
</li>
<li><p>其最简单的形式将接受一个二元函数，并从前两个元素开始持续应用它。</p>
</li>
<li><p><strong>在并行处理情况下，传入给Reduce等方法的集合类，需要是线程安全的，否则执行结果会与预期结果不一样。</strong></p>
</li>
<li><p>比如求和函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; values =...;</span><br><span class="line">Optional&lt;Integer&gt; sum = values.stream().reduce((x,y) -&gt; x+y);</span><br><span class="line"><span class="comment">//reduce会计算v0+v1+v2+...，如果流为空，会返回空Optional</span></span><br><span class="line"><span class="comment">//上面也可写成reduce(Integer::sum);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果reduce有一项约简操作op，那么该约简就会产生<code> v0 op v1 op v2 op ...</code> , 其中我们调用函数<code>op(vi，vi+1)</code>写作<code>vi op vi+1</code>。这项操作应该是<strong>可结合的</strong>。</p>
</li>
<li><p><strong>通常会有一个幺元值e，使得 e op x &#x3D; x，可以使用这个元素作为计算的起点</strong>。然后可以调用第二种形式的reduce，如果流为空，则会返回幺元值，就不再需要处理Optional类了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; values =...;</span><br><span class="line">Optional&lt;Integer&gt; sum = values.stream().reduce(<span class="number">0</span>, (x,y) -&gt; x+y);</span><br></pre></td></tr></table></figure>
</li>
<li><p>假设你有一个对象流，并且想对某些属性求和，例如字符串流中的所有字符串的长度，那么可以提供一个“累积器”函数<code>（total, word） -&gt; total + word.length()</code>。而且需要合并结果，因此需要提供第二个函数执行处理。例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> words.reduce(<span class="number">0</span>, (total, word) -&gt; total + word.length(), (total1, total2) -&gt; total1 + total2)；</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><ul>
<li><p>方法定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;U&gt; U <span class="title function_">reduce</span><span class="params">(</span></span><br><span class="line"><span class="params">    U identity,</span></span><br><span class="line"><span class="params">    BiFunction&lt;U, ? <span class="built_in">super</span> T, U&gt; accumulator,</span></span><br><span class="line"><span class="params">    BinaryOperator&lt;U&gt; combiner)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>BiFunction 三个参数可以是一样的也可以不一样；<br>它是一个函数式接口，包含的函数式方法定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">R <span class="title function_">apply</span><span class="params">(T t, U u)</span>;</span><br><span class="line"></span><br><span class="line">BiFunction它接收两个输入返回一个输出；</span><br><span class="line">而Function接收一个输入返回一个输出。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>BinaryOperator继承自BiFunction的一个接口</p>
<p><strong>BinaryOperator就直接限定了其三个参数必须是一样的；</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BinaryOperator</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">BiFunction</span>&lt;T,T,T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//它表示的就是两个相同类型的输入经过计算后产生一个同类型的输出。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>BiConsumer :<br>也是一个函数式接口，它的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可见它就是一个两个输入参数的Consumer的变种。计算没有返回值。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BiConsumer</span>&lt;T, U&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs this operation on the given arguments.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the first input argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> u the second input argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t, U u)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="一个参数的Reduce"><a href="#一个参数的Reduce" class="headerlink" title="一个参数的Reduce"></a>一个参数的Reduce</h4><ul>
<li><p>一系列数中的正数求和、将序列中满足某个条件的数一起做某些计算等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; <span class="title function_">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示的含义</span></span><br><span class="line"><span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">	result = accumulator.apply(result, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; s = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 求和，也可以写成Lambda语法：</span></span><br><span class="line"><span class="comment">   * Integer sum = s.reduce((a, b) -&gt; a + b).get();</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> s.reduce(<span class="keyword">new</span> <span class="title class_">BinaryOperator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(Integer integer, Integer integer2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> integer + integer2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).get();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 求最大值，也可以写成Lambda语法：</span></span><br><span class="line"><span class="comment">   * Integer max = s.reduce((a, b) -&gt; a &gt;= b ? a : b).get();</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">max</span> <span class="operator">=</span> s.reduce(<span class="keyword">new</span> <span class="title class_">BinaryOperator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(Integer integer, Integer integer2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> integer &gt;= integer2 ? integer : integer2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).get();</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="两个参数的Reduce"><a href="#两个参数的Reduce" class="headerlink" title="两个参数的Reduce"></a>两个参数的Reduce</h4><ul>
<li><p>相对于一个参数的方法来说，它多了一个T类型的参数；</p>
</li>
<li><p>实际上就相当于需要计算的值在Stream的基础上<strong>多了一个初始化的值。</strong></p>
</li>
<li><p>计算的顺序是：<strong>identity与a[0]进行二合运算，结果与a[1]再进行二合运算，最终与a[n-1]进行二合运算。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T <span class="title function_">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//n个元素的数组进行运算时，其表达的含义如下：</span></span><br><span class="line"><span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> identity;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">	result = accumulator.apply(result, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将一个String类型的Stream中的所有元素连接到一起并在最前面添加[value]后返回：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; s = Stream.of(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;t1&quot;</span>, <span class="string">&quot;t2&quot;</span>, <span class="string">&quot;teeeee&quot;</span>, <span class="string">&quot;aaaa&quot;</span>, <span class="string">&quot;taaa&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(</span><br><span class="line">	s.reduce(<span class="string">&quot;[value]&quot;</span>,<span class="keyword">new</span> <span class="title class_">BinaryOperator</span>&lt;String&gt;()&#123;</span><br><span class="line">        <span class="meta">@override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(String s, String s1)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> s.conncat(s2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下结果将会是：[value]testt1t2teeeeeaaaataaa</span></span><br><span class="line"><span class="comment">//也可以使用Lambda语法：</span></span><br><span class="line">System.out.println(s.reduce(<span class="string">&quot;[value]&quot;</span>, (s1, s2) -&gt; s1.concat(s2)));</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="三个参数的Reduce"><a href="#三个参数的Reduce" class="headerlink" title="三个参数的Reduce"></a>三个参数的Reduce</h4><ul>
<li><p>方法定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;U&gt; U <span class="title function_">reduce</span><span class="params">(</span></span><br><span class="line"><span class="params">    U identity,</span></span><br><span class="line"><span class="params">    BiFunction&lt;U, ? <span class="built_in">super</span> T, U&gt; accumulator,</span></span><br><span class="line"><span class="params">    BinaryOperator&lt;U&gt; combiner</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>identity: 一个初始化的值；这个初始化的值其类型是<strong>泛型U</strong>，与Reduce方法返回的类型一致；</p>
<ul>
<li><p>注意此时Stream中元素的类型是T，与U可以不一样也可以一样，这样的话操作空间就大了；</p>
</li>
<li><p>不管Stream中存储的元素是什么类型，U都可以是任何类型，如U可以是一些基本数据类型的包装类型Integer、Long等；或者是String，又或者是一些集合类型ArrayList等；后面会说到这些用法。</p>
</li>
</ul>
</li>
<li><p>accumulator: 其类型是BiFunction，<strong>输入是U与T两个类型的数据，而返回的是U类型</strong>；</p>
<ul>
<li>也就是说返回的类型与输入的第一个参数类型是一样的，</li>
<li>而输入的第二个参数类型与Stream中元素类型是一样的。</li>
</ul>
</li>
<li><p>combiner: 其类型是BinaryOperator，支持的是<strong>对U类型的对象进行操作</strong>；</p>
<ul>
<li><strong>combiner主要是使用在并行计算的场景；如果Stream是非并行时，第三个参数实际上是不生效的。</strong></li>
</ul>
</li>
<li><p>非并行:其计算过程与两个参数时的Reduce基本是一致的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Result的类型是U，而Element的类型是T！如果U与T一样，那么与1.2就是完全一样的；第三个指定null为返回值。</span></span><br><span class="line"><span class="type">U</span> <span class="variable">result</span> <span class="operator">=</span> identity;</span><br><span class="line"><span class="keyword">for</span> (T element：a) &#123;</span><br><span class="line">	result = accumulator.apply(result, element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设U的类型是ArrayList，那么可以将Stream中所有元素添加到ArrayList中再返回了，如下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下reduce生成的List将会是[aa, ab, c, ad]</span></span><br><span class="line"><span class="comment"> * Lambda语法：</span></span><br><span class="line"><span class="comment"> *  System.out.println(s1.reduce(new ArrayList&lt;String&gt;(), (r, t) -&gt; &#123;r.add(t); return r; &#125;, (r1, r2) -&gt; r1));</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Stream&lt;String&gt; s1 = Stream.of(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;ab&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;ad&quot;</span>);</span><br><span class="line">System.out.println(s1.reduce(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(),</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">BiFunction</span>&lt;ArrayList&lt;String&gt;, String, ArrayList&lt;String&gt;&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title function_">apply</span><span class="params">(ArrayList&lt;String&gt; u, String s)</span> &#123;</span><br><span class="line">				u.add(s);</span><br><span class="line">				<span class="keyword">return</span> u;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="keyword">new</span> <span class="title class_">BinaryOperator</span>&lt;ArrayList&lt;String&gt;&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title function_">apply</span><span class="params">(ArrayList&lt;String&gt; strings, ArrayList&lt;String&gt; strings2)</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> strings;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;));</span><br></pre></td></tr></table></figure>
</li>
<li><p>并行：当Stream是并行时，第三个参数就有意义了，它会将不同线程计算的结果调用combiner做汇总后返回。</p>
<p>注意由于采用了并行计算，前两个参数与非并行时也有了差异！</p>
</li>
<li><p>示例</p>
<ul>
<li><code>计算4+1+2+3的结果，其中4是初始值：</code></li>
<li><code>并行时的计算结果是18，而非并行时的计算结果是10</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * lambda语法：</span></span><br><span class="line"><span class="comment"> * System.out.println(Stream.of(1, 2, 3).parallel().reduce(4, (s1, s2) -&gt; s1 + s2</span></span><br><span class="line"><span class="comment"> , (s1, s2) -&gt; s1 + s2));</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">System.out.println(Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).parallel().reduce(<span class="number">4</span>, <span class="keyword">new</span> <span class="title class_">BiFunction</span>&lt;Integer, Integer, Integer&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(Integer integer, Integer integer2)</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> integer + integer2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		, <span class="keyword">new</span> <span class="title class_">BinaryOperator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(Integer integer, Integer integer2)</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> integer + integer2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;));</span><br></pre></td></tr></table></figure>
</li>
<li><p>先分析下非并行时的计算过程；<strong>每一步都要依赖前一步的运算结果</strong>！</p>
<ul>
<li>第一步计算4 + 1 &#x3D; 5，</li>
<li>第二步是5 + 2 &#x3D; 7，</li>
<li>第三步是7 + 3 &#x3D; 10。</li>
</ul>
</li>
<li><p>并行时的计算过程:初始值4是存储在一个变量result中的；并行计算时，线程之间没有影响，因此每个线程在调用第二个参数BiFunction进行计算时，直接都是使用result值当其第一个参数（由于Stream计算的延迟性，在调用最终方法前，都不会进行实际的运算，因此每个线程取到的result值都是原始的4），</p>
<ul>
<li>线程1：1 + 4 &#x3D; 5；</li>
<li>线程2：2 + 4 &#x3D; 6；</li>
<li>线程3：3 + 4 &#x3D; 7；</li>
<li>Combiner函数： 5 + 6 + 7 &#x3D; 18！</li>
</ul>
</li>
<li><p>示例输出的结果是210！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).parallel().reduce(<span class="number">4</span>, (s1, s2) -&gt; s1 + s2 , (s1, s2) -&gt; s1 * s2);</span><br><span class="line"></span><br><span class="line">线程<span class="number">1</span>：<span class="number">1</span> + <span class="number">4</span> = <span class="number">5</span>；</span><br><span class="line">线程<span class="number">2</span>：<span class="number">2</span> + <span class="number">4</span> = <span class="number">6</span>；</span><br><span class="line">线程<span class="number">3</span>：<span class="number">3</span> + <span class="number">4</span> = <span class="number">7</span>；</span><br><span class="line">ombiner函数<span class="number">5</span> * <span class="number">6</span> * <span class="number">7</span> = <span class="number">210</span>。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于：</span></span><br><span class="line">Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).map(n -&gt; n + <span class="number">4</span>).reduce((s1, s2) -&gt; s1 * s2);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="三个参数误解"><a href="#三个参数误解" class="headerlink" title="三个参数误解"></a>三个参数误解</h4><ul>
<li><p>三个参数时：</p>
<ul>
<li>第一个参数的类型是ArrayList等对象而<strong>非基本数据类型</strong>的包装类或者String，</li>
<li>第三个函数的处理上可能容易引起误解。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟Filter查找其中含有字母a的所有元素，打印结果将是aa ab ad</span></span><br><span class="line"><span class="comment"> * lambda语法：</span></span><br><span class="line"><span class="comment"> * s1.parallel().reduce(new ArrayList&lt;String&gt;(),</span></span><br><span class="line"><span class="comment"> (r, t) -&gt; &#123;if (predicate.test(t)) r.add(t);  return r; &#125;,</span></span><br><span class="line"><span class="comment"> (r1, r2) -&gt; &#123;System.out.println(r1==r2); return r2; &#125;).stream().forEach(System.out::println);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Stream&lt;String&gt; s1 = Stream.of(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;ab&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;ad&quot;</span>);</span><br><span class="line">Predicate&lt;String&gt; predicate = t -&gt; t.contains(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">s1.parallel().reduce(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">BiFunction</span>&lt;ArrayList&lt;String&gt;, String, ArrayList&lt;String&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title function_">apply</span><span class="params">(</span></span><br><span class="line"><span class="params">            ArrayList&lt;String&gt; strings,</span></span><br><span class="line"><span class="params">            String s)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (predicate.test(s)) &#123;</span><br><span class="line">                strings.add(s);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> strings;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">BinaryOperator</span>&lt;ArrayList&lt;String&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title function_">apply</span><span class="params">(</span></span><br><span class="line"><span class="params">            ArrayList&lt;String&gt; strings,</span></span><br><span class="line"><span class="params">            ArrayList&lt;String&gt; strings2)</span> &#123;</span><br><span class="line">            <span class="comment">//经过运行后发现是True！</span></span><br><span class="line">            <span class="comment">//这是因为每次第二个参数也就是accumulator返回的都是第一个参数中New的ArrayList对象！</span></span><br><span class="line">            <span class="comment">//因此combiner中传入的永远都会是这个对象，这样r1与r2就必然是同一样对象！</span></span><br><span class="line">            System.out.println(strings == strings2);</span><br><span class="line">            <span class="keyword">return</span> strings;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
</li>
<li><p>因此如果按理解的，combiner是将不同线程操作的结果汇总起来，那么一般情况下上述代码就会这样写(lambda)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; s1 = Stream.of(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;ab&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;ad&quot;</span>);</span><br><span class="line"><span class="comment">//模拟Filter查找其中含有字母a的所有元素，由于使用了r1.addAll(r2)，其打印结果将不会是预期的aa ab ad</span></span><br><span class="line">Predicate&lt;String&gt; predicate = t -&gt; t.contains(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">s1.parallel().reduce(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(),</span><br><span class="line">(r, t) -&gt; &#123;<span class="keyword">if</span> (predicate.test(t)) r.add(t);  <span class="keyword">return</span> r; &#125;,</span><br><span class="line">(r1, r2) -&gt; &#123;r1.addAll(r2); <span class="keyword">return</span> r1; &#125;).stream().forEach(System.out::println);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h2><ul>
<li><p>collect含义与Reduce有点相似；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; R <span class="title function_">collect</span><span class="params">(</span></span><br><span class="line"><span class="params">    Supplier&lt;R&gt; supplier,</span></span><br><span class="line"><span class="params">    BiConsumer&lt;R, ? <span class="built_in">super</span> T&gt; accumulator,</span></span><br><span class="line"><span class="params">    BiConsumer&lt;R, R&gt; combiner)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>supplier：动态的提供初始化的值；创建一个可变的结果容器（JAVADOC）；对于并行计算，这个方法可能被调用多次，每次返回一个新的对象；</p>
</li>
<li><p>accumulator：类型为BiConsumer，注意这个接口是没有返回值的；它必须将一个元素放入结果容器中（JAVADOC）。</p>
</li>
<li><p>combiner：类型也是BiConsumer，因此也没有返回值。它与三参数的Reduce类型，只是在并行计算时汇总不同线程计算的结果。它的输入是两个结果容器，必须将第二个结果容器中的值全部放入第一个结果容器中（JAVADOC）。</p>
</li>
</ul>
<h3 id="并行示例"><a href="#并行示例" class="headerlink" title="并行示例"></a>并行示例</h3><ul>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟Filter查找其中含有字母a的所有元素，打印结果将是aa ab ad</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Stream&lt;String&gt; s1 = Stream.of(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;ab&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;ad&quot;</span>);</span><br><span class="line">Predicate&lt;String&gt; predicate = t -&gt; t.contains(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">System.out.println(</span><br><span class="line">    s1.parallel().collect(</span><br><span class="line">        () -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(),</span><br><span class="line">		(array, s) -&gt; &#123;<span class="keyword">if</span> (predicate.test(s)) array.add(s); &#125;,</span><br><span class="line">		(array1, array2) -&gt; array1.addAll(array2))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>理解起来就很容易了：</p>
<p>每个线程都创建了一个结果容器ArrayList，假设每个线程处理一个元素，那么处理的结果将会是[aa],[ab],[],[ad]四个结果容器（ArrayList）；最终再调用第三个BiConsumer参数将结果全部Put到第一个List中，因此返回结果就是打印的结果了。</p>
</li>
<li><p>AVADOC中也在强调结果容器（result container)这个，那是否除集合类型，其结果R也可以是其它类型呢？</p>
</li>
<li><p>先看基本类型，由于BiConsumer不会有返回值，如果是基本数据类型或者String，在BiConsumer中加工后的结果都无法在这个函数外体现，因此是没有意义的。</p>
</li>
<li><p>那其它非集合类型的Java对象呢？如果对象中包含有集合类型的属性，也是可以处理的；否则，处理上也没有任何意义，</p>
</li>
<li><p>combiner对象使用一个Java对象来更新另外一个对象？至少目前我没有想到这个有哪些应用场景。</p>
</li>
<li><p>它不同Reduce，Reduce在Java对象上是有应用场景的，就因为Reduce即使是并行情况下，也不会创建多个初始化对象，combiner接收的两个参数永远是同一个对象，如假设有很多人参加会议的记录条，这些记录没有在人本身对象里面存储而在另外一个对象中；人本身对象中只有一个属性是最早参加会议时间，那就可以使用reduce来对这个属性进行更新。当然这个示例不够完美，它能使用其它更快的方式实现，但至少通过Reduce是能够实现这一类型的功能的。</p>
</li>
</ul>
<h2 id="数据收集遍历"><a href="#数据收集遍历" class="headerlink" title="数据收集遍历"></a>数据收集遍历</h2><h3 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h3><ul>
<li><p>当处理完流，通常会想要查看其元素。此时可以调用iterator方法，它会产生可以用来访问元素的旧式风格的迭代器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BaseStream</span>&lt;T, S <span class="keyword">extends</span> <span class="title class_">BaseStream</span>&lt;T, S&gt;&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生一个用于获取当前流中各个元素的迭代器。这是一种终结操作</span></span><br><span class="line">    Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><ul>
<li>或者可以调用forEach方法，将某个函数应用于每个元素。在并行流上，forEach方法会以任意顺序遍历各个元素。</li>
<li>也可以用forEachOrdered方法按照流中的顺序来处理。不过这个方法会丧失并行处理的部分甚至全部优势。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Stream</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">BaseStream</span>&lt;T, Stream&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在流的每个元素上调用action，这是一种终结操作</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果流具有定义的遇到顺序，则按流的遇到顺序对此流的每个元素执行操作。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">forEachOrdered</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回包含此流元素的数组。</span></span><br><span class="line">    Object[] toArray();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生一个对象数组，或者在将构造器引用传递进去时，返回一个对应类型的数组。终结操作</span></span><br><span class="line">    &lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在此流的元素上执行可变的归约运算。</span></span><br><span class="line">    &lt;R&gt; R <span class="title function_">collect</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span><br><span class="line"><span class="params">                  BiConsumer&lt;R, ? <span class="built_in">super</span> T&gt; accumulator,</span></span><br><span class="line"><span class="params">                  BiConsumer&lt;R, R&gt; combiner)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用给定的收集器来收集当前流中的元素</span></span><br><span class="line">    &lt;R, A&gt; R <span class="title function_">collect</span><span class="params">(Collector&lt;? <span class="built_in">super</span> T, A, R&gt; collector)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>遍历输出流中的元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.forEach(System.out::println);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="toArray方法"><a href="#toArray方法" class="headerlink" title="toArray方法"></a>toArray方法</h3><ul>
<li><p>可以<strong>获得由流的元素构成的数组</strong>，但是由于无法在运行时创建泛型数组，所以会返回一个Object[]数组。也可以通过传递<strong>构造器引用</strong>来获取正确的数组类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将流转换为数组，获得Object[]数组</span></span><br><span class="line">Object[] result = stream.toArray();</span><br><span class="line"><span class="comment">//传入String的构造器引用，获得String[]数组</span></span><br><span class="line">String[] result = stream.toArray(String::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="collect元素收集到集合"><a href="#collect元素收集到集合" class="headerlink" title="collect元素收集到集合"></a>collect元素收集到集合</h3><ul>
<li><p>针对将流中的元素收集到另一个目标中，有一个便捷方法collect可用，它会接受一个Collector接口的实例。Collectors类提供了大量用于生成公共收集器的工厂方法。调用collect方法可以进行多种操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将流收集到列表中</span></span><br><span class="line">List&lt;String&gt; result = stream.collect(Collectors.toList());</span><br><span class="line"><span class="comment">//将流收集到集合中</span></span><br><span class="line">Set&lt;String&gt; result = stream.collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果想要获取集的具体实现类，可以</span></span><br><span class="line">TreeSet&lt;String&gt; result = stream.collect(Collectors.toCollection(TreeSet::<span class="keyword">new</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果想要通过连接操作收集流中的所有字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> stream.collect(Collectors.joining());</span><br><span class="line"></span><br><span class="line"><span class="comment">//还可以在元素之间添加分隔符</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> stream.collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="基本类型流"><a href="#基本类型流" class="headerlink" title="基本类型流"></a>基本类型流</h2><ul>
<li><p>之前我们都是将整数收集到<code>Stream&lt;Integer&gt;</code>中，尽管很明显，将每个整数都包装到包装器对象中是很低效的。对其他基本类型来说，情况也是一样的，这些基本类型是：<code>double、float、short、char、byte和boolean</code>。流库中有专门的类型<code>IntStream、LongStream和DoubleStream</code>，用来直接存储基本类型值。</p>
</li>
<li><p><strong>如果想要存储short，char，byte和boolean，可以使用IntStream；</strong></p>
</li>
<li><p><strong>对于float，可以使用DoubleStream。</strong></p>
</li>
<li><p>仅列举一个为例，其余两个API都拥有相似的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IntStream</span> <span class="keyword">extends</span> <span class="title class_">BaseStream</span>&lt;Integer, IntStream&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算当前流的总和</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算当前流的最小值</span></span><br><span class="line">    OptionalInt <span class="title function_">min</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算当前流的最大值</span></span><br><span class="line">    OptionalInt <span class="title function_">max</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算当前流的平均值</span></span><br><span class="line">    OptionalDouble <span class="title function_">average</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取这些结果的所有四种值的对象</span></span><br><span class="line">    IntSummaryStatistics <span class="title function_">summaryStatistics</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生一个由给定元素构成的IntStream</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IntStream <span class="title function_">of</span><span class="params">(<span class="type">int</span> t)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.intStream(<span class="keyword">new</span> <span class="title class_">Streams</span>.IntStreamBuilderImpl(t), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生一个由给定元素构成的IntStream</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IntStream <span class="title function_">of</span><span class="params">(<span class="type">int</span>... values)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生一个由给定范围内的整数构成的IntStream</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IntStream <span class="title function_">range</span><span class="params">(<span class="type">int</span> startInclusive, <span class="type">int</span> endExclusive)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (startInclusive &gt;= endExclusive) &#123;</span><br><span class="line">            <span class="keyword">return</span> empty();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> StreamSupport.intStream(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Streams</span>.RangeIntSpliterator(startInclusive, endExclusive, <span class="literal">false</span>), <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生一个由给定范围内的整数构成的IntStream</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IntStream <span class="title function_">rangeClosed</span><span class="params">(<span class="type">int</span> startInclusive, <span class="type">int</span> endInclusive)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (startInclusive &gt; endInclusive) &#123;</span><br><span class="line">            <span class="keyword">return</span> empty();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> StreamSupport.intStream(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Streams</span>.RangeIntSpliterator(startInclusive, endInclusive, <span class="literal">true</span>), <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生用于当前流中的元素的包装器对象流</span></span><br><span class="line">    Stream&lt;Integer&gt; <span class="title function_">boxed</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生一个由当前流中的元素构成的数组</span></span><br><span class="line">    <span class="type">int</span>[] toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当你拥有一个对象流时，可以用mapToInt、mapToLong和mapToDouble将其转换为基本类型流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; words = ... ;</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">lengths</span> <span class="operator">=</span> words.mapToInt(String::length);</span><br></pre></td></tr></table></figure>
</li>
<li><p>将基本类型流转换为对象流则需要使用boxed方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; integers = IntStream.range(<span class="number">0</span>,<span class="number">100</span>).boxed();</span><br><span class="line"><span class="comment">//range方法可以生成步长为1的整数范围的流</span></span><br><span class="line"><span class="comment">//boxed方法将基本类型流包装为包装类</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h2><ul>
<li><p>在上面流的介绍里，我们谈到的流大多数是串行流，而上文也提到过并行流。在流的创建里，<code>stream()</code>方法就是创建串行流，<code>parallelStream()</code>方法创建的是并行流。那么他们的区别是什么呢？</p>
</li>
<li><p><strong>串行流，即单线程执行的；并行流，即多线程执行操作。</strong></p>
</li>
<li><p><strong>在Java中，并行流使用默认的fork-join池（<code>ForkJoinPool</code>）来操作流的各个部分，并且该池是所有并行流共享的。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterable</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">//用当前集合中的元素产生一个并行流</span></span><br><span class="line">    <span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">parallelStream</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BaseStream</span>&lt;T, S <span class="keyword">extends</span> <span class="title class_">BaseStream</span>&lt;T, S&gt;&gt;</span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生一个与当前流中元素相同的并行流</span></span><br><span class="line">    S <span class="title function_">parallel</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生一个与当前流中元素相同的无序流</span></span><br><span class="line">    S <span class="title function_">unordered</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>流使得<strong>并行处理块操作变得更容易</strong>。这个过程几乎是自动的，但是需要遵守一些规则，首先，必须有一个并行流。可以用<code>Collection.parallelStream()</code>方法从任何集合中获取一个并行流：</p>
</li>
<li><p>而且，parallel方法可以将任意的顺序流转换为并行流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; parallelWords = words.parallelStream();</span><br><span class="line">Stream&lt;String&gt; parallelWords = Stream.of(wordArray).parallel();</span><br></pre></td></tr></table></figure>
</li>
<li><p>只要在终结方法执行时，流处于并行模式，那么所有的中间流操作都将被并行化。</p>
</li>
</ul>
<h3 id="并行流的作用"><a href="#并行流的作用" class="headerlink" title="并行流的作用"></a>并行流的作用</h3><ul>
<li><p>并行流就是支持多线程操作的流，它使得并行处理变得简单。</p>
</li>
<li><p>Stream具有平行处理能力，处理的过程会分而治之，也就是将一个大任务切分成多个小任务，这表示每个任务都是一个操作。</p>
</li>
<li><p>举一个简单的栗子看效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个串行流，并且遍历输出全部元素</span></span><br><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">numbers.stream()</span><br><span class="line">       .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果是 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个并行流，并且遍历输出全部元素</span></span><br><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">numbers.parallelStream()</span><br><span class="line">       .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果是 6 5 7 9 1 8 4 3 2  （但其实结果每次都不一样）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>上面的栗子可以看到，并行流在进行操作时，将一个大操作分成了多个小操作并行进行，再将结果组合起来，于是输出的结果顺序是任意顺序。</p>
</li>
<li><p>倘若你想要结果按照原来元素的顺序，就上面的例子，你可以这样做</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">numbers.parallelStream()</span><br><span class="line">       .forEachOrdered(System.out::println);</span><br><span class="line"><span class="comment">//输出 1 2 3 4 5 6 7 8 9</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**注意:**如果<code>forEachOrdered()</code>中间有其他如<code>filter()</code>的中介操作，会试着平行化处理，然后最终forEachOrdered()会以原数据顺序处理，因此，使用<code>forEachOrdered()</code>这类的有序处理,<strong>可能会（或完全失去）失去平行化的一些优势，</strong>实际上中介操作亦有可能如此，例如sorted()方法。</p>
</li>
</ul>
<h2 id="并行流的性能问题"><a href="#并行流的性能问题" class="headerlink" title="并行流的性能问题"></a>并行流的性能问题</h2><ul>
<li>要想深入的研究parallelStream，我们必须先了解ForkJoin框架和ForkJoinPool。</li>
</ul>
<h3 id="简单了解Fork-Join-框架"><a href="#简单了解Fork-Join-框架" class="headerlink" title="简单了解Fork&#x2F;Join 框架"></a>简单了解Fork&#x2F;Join 框架</h3><ul>
<li><p>Fork&#x2F;Join 框架是 Java7 提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p>
</li>
<li><p>我们再通过 Fork 和 Join 这两个单词来理解下 Fork&#x2F;Join 框架，Fork 就是把一个大任务切分为若干子任务并行的执行，Join 就是合并这些子任务的执行结果，最后得到这个大任务的结果。比如计算 1+2+。。＋10000，可以分割成 10 个子任务，每个子任务分别对 1000 个数进行求和，最终汇总这 10 个子任务的结果。</p>
</li>
</ul>
<h3 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h3><ul>
<li><p>Java 8为ForkJoinPool添加了一个通用线程池，这个线程池用来处理那些没有被显式提交到任何线程池的任务。</p>
</li>
<li><p>它是ForkJoinPool类型上的一个静态元素，它拥有的默认线程数量等于运行计算机上的处理器数量。</p>
</li>
<li><p>当调用Arrays类上添加的新方法时，自动并行化就会发生。比如用来排序一个数组的并行快速排序，用来对一个数组中的元素进行并行遍历。</p>
</li>
<li><p>自动并行化也被运用在Java 8新添加的Stream API中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">numbers.parallelStream()</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于列表中的元素的操作都会以并行的方式执行。forEach方法会为每个元素的计算操作创建一个任务，该任务会被前文中提到的ForkJoinPool中的通用线程池处理。以上的并行计算逻辑当然也可以使用ThreadPoolExecutor完成，但是就代码的可读性和代码量而言，使用ForkJoinPool明显更胜一筹。</p>
</li>
</ul>
<h3 id="并行流的陷阱"><a href="#并行流的陷阱" class="headerlink" title="并行流的陷阱"></a>并行流的陷阱</h3><ul>
<li><p>从java8开始，并行编程变得很容易，通过并行流（parallelStream），可以很轻松的实现多线程并行处理。但是，这里面有个性能“陷阱”，如果不注意，使用并行流的效果反而更差，这个陷阱是什么呢？</p>
</li>
<li><p>这个陷阱就是，并行流默认都是用<strong>同一个默认的ForkJoinPool</strong>，这个ForkJoinPool的线程数和CPU的核心数相同。如果是计算密集型的操作，直接使用是没有问题的，因为这个ForkJoinPool会将所有的CPU打满，系统资源是没有浪费的。但是，如果其中还有IO操作或等待操作，这个默认的ForkJoinPool只能消耗一部分CPU，而另外的并行流因为获取不到该ForkJoinPool的使用权，性能将大大降低。<strong>可见，默认的ForkJoinPool必须只能处理计算密集型的任务</strong>。</p>
</li>
</ul>
<h2 id="Collectors类型"><a href="#Collectors类型" class="headerlink" title="Collectors类型"></a>Collectors类型</h2><p><code>Collector</code>是一个接口，其中<strong>Collectors类有用于多种收集器的工厂方法</strong>。</p>
<p>在流里，<code>collect()</code>方法大量运用到了<code>Collectors里的工厂方法</code>进行收集操作等，该方法里具体能做到什么取决于Collectiors类。</p>
<p>由于该类型的收集器工厂方法太多了，下面列举了部分方法，不一一举例了，需要用到的时候再详细研究。</p>
<h3 id="收集结果List-Set"><a href="#收集结果List-Set" class="headerlink" title="收集结果List|Set"></a>收集结果List|Set</h3><ul>
<li><p>下面这些方法在上面流里有提到过，就不再具体举例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Collectors</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将元素收集到列表中的收集器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line">        Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CollectorImpl</span>&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::<span class="keyword">new</span>, List::add,</span><br><span class="line">                                   (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,</span><br><span class="line">                                   CH_ID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将元素收集到集中的收集器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line">        Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CollectorImpl</span>&lt;&gt;((Supplier&lt;Set&lt;T&gt;&gt;) HashSet::<span class="keyword">new</span>, Set::add,</span><br><span class="line">                                   (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,</span><br><span class="line">                                   CH_UNORDERED_ID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将元素收集到任意集合中的收集器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, C <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;T&gt;&gt;</span><br><span class="line">        Collector&lt;T, ?, C&gt; toCollection(Supplier&lt;C&gt; collectionFactory) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CollectorImpl</span>&lt;&gt;(collectionFactory, Collection&lt;T&gt;::add,</span><br><span class="line">                                   (r1, r2) -&gt; &#123; r1.addAll(r2); <span class="keyword">return</span> r1; &#125;,</span><br><span class="line">                                   CH_ID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接字符串的收集器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CollectorImpl</span>&lt;CharSequence, StringBuilder, String&gt;(</span><br><span class="line">            StringBuilder::<span class="keyword">new</span>, StringBuilder::append,</span><br><span class="line">            (r1, r2) -&gt; &#123; r1.append(r2); <span class="keyword">return</span> r1; &#125;,</span><br><span class="line">            StringBuilder::toString, CH_NOID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接字符串，并以指定分隔符分隔的收集器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter) &#123;</span><br><span class="line">        <span class="keyword">return</span> joining(delimiter, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接字符串，并以指定分隔符分隔，第一个字符串之前可以有前缀，最后一个字符串有后缀的收集器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter,</span><br><span class="line">                                                             CharSequence prefix,</span><br><span class="line">                                                             CharSequence suffix) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CollectorImpl</span>&lt;&gt;(</span><br><span class="line">            () -&gt; <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(delimiter, prefix, suffix),</span><br><span class="line">            StringJoiner::add, StringJoiner::merge,</span><br><span class="line">            StringJoiner::toString, CH_NOID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="收集到映射表Map"><a href="#收集到映射表Map" class="headerlink" title="收集到映射表Map"></a>收集到映射表Map</h3><ul>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Collectors</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *产生一个收集器，它会产生一个映射表或并发映射表。keyMapper和valueMapper函数</span></span><br><span class="line"><span class="comment">     *会应用于每个收集到的元素上，从而在所产生的映射表中生存一个键值项。默认情况下，当</span></span><br><span class="line"><span class="comment">     *两个元素产生相同的键时，会抛出一个IllegalStateException异常。你可以提供一个</span></span><br><span class="line"><span class="comment">     *mergeFunction来合并具有相同键的值。默认情况下，其结果是一个HashMap或ConcurrentHashMap。</span></span><br><span class="line"><span class="comment">     *你可以提供一个mapSupplier，它会产生所期望的映射表实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, U&gt;</span><br><span class="line">    Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">K</span>&gt; keyMapper,</span><br><span class="line">                                    Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">U</span>&gt; valueMapper) &#123;</span><br><span class="line">        <span class="keyword">return</span> toMap(keyMapper, valueMapper, throwingMerger(), HashMap::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, U&gt;</span><br><span class="line">    Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">K</span>&gt; keyMapper,</span><br><span class="line">                                    Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">U</span>&gt; valueMapper,</span><br><span class="line">                                    BinaryOperator&lt;U&gt; mergeFunction) &#123;</span><br><span class="line">        <span class="keyword">return</span> toMap(keyMapper, valueMapper, mergeFunction, HashMap::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, U, M <span class="keyword">extends</span> <span class="title class_">Map</span>&lt;K, U&gt;&gt;</span><br><span class="line">    Collector&lt;T, ?, M&gt; toMap(Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">K</span>&gt; keyMapper,</span><br><span class="line">                                Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">U</span>&gt; valueMapper,</span><br><span class="line">                                BinaryOperator&lt;U&gt; mergeFunction,</span><br><span class="line">                                Supplier&lt;M&gt; mapSupplier) &#123;</span><br><span class="line">        BiConsumer&lt;M, T&gt; accumulator</span><br><span class="line">                = (map, element) -&gt; map.merge(keyMapper.apply(element),</span><br><span class="line">                                              valueMapper.apply(element), mergeFunction);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CollectorImpl</span>&lt;&gt;(mapSupplier, accumulator, mapMerger(mergeFunction), CH_ID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, U&gt;</span><br><span class="line">    Collector&lt;T, ?, ConcurrentMap&lt;K,U&gt;&gt; toConcurrentMap(Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">K</span>&gt; keyMapper,</span><br><span class="line">                                                        Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">U</span>&gt; valueMapper) &#123;</span><br><span class="line">        <span class="keyword">return</span> toConcurrentMap(keyMapper, valueMapper, throwingMerger(), ConcurrentHashMap::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, U&gt;</span><br><span class="line">    Collector&lt;T, ?, ConcurrentMap&lt;K,U&gt;&gt;</span><br><span class="line">    toConcurrentMap(Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">K</span>&gt; keyMapper,</span><br><span class="line">                    Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">U</span>&gt; valueMapper,</span><br><span class="line">                    BinaryOperator&lt;U&gt; mergeFunction) &#123;</span><br><span class="line">        <span class="keyword">return</span> toConcurrentMap(keyMapper, valueMapper, mergeFunction, ConcurrentHashMap::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, U, M <span class="keyword">extends</span> <span class="title class_">ConcurrentMap</span>&lt;K, U&gt;&gt;</span><br><span class="line">    Collector&lt;T, ?, M&gt; toConcurrentMap(Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">K</span>&gt; keyMapper,</span><br><span class="line">                                       Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">U</span>&gt; valueMapper,</span><br><span class="line">                                       BinaryOperator&lt;U&gt; mergeFunction,</span><br><span class="line">                                       Supplier&lt;M&gt; mapSupplier) &#123;</span><br><span class="line">        BiConsumer&lt;M, T&gt; accumulator</span><br><span class="line">                = (map, element) -&gt; map.merge(keyMapper.apply(element),</span><br><span class="line">                                              valueMapper.apply(element), mergeFunction);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CollectorImpl</span>&lt;&gt;(mapSupplier, accumulator, mapMerger(mergeFunction), CH_CONCURRENT_ID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="基础数据类型收集器"><a href="#基础数据类型收集器" class="headerlink" title="基础数据类型收集器"></a>基础数据类型收集器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Collectors</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生能够生产IntSummaryStatistics对象的收集器，通过它可以获得将mapper应用于</span></span><br><span class="line">    <span class="comment">//每个元素后所产生的结果的个数、总和、平均值、最大值和最小值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line">    Collector&lt;T, ?, IntSummaryStatistics&gt; summarizingInt(ToIntFunction&lt;? <span class="built_in">super</span> T&gt; mapper) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CollectorImpl</span>&lt;T, IntSummaryStatistics, IntSummaryStatistics&gt;(</span><br><span class="line">                IntSummaryStatistics::<span class="keyword">new</span>,</span><br><span class="line">                (r, t) -&gt; r.accept(mapper.applyAsInt(t)),</span><br><span class="line">                (l, r) -&gt; &#123; l.combine(r); <span class="keyword">return</span> l; &#125;, CH_ID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生能够生产LongSummaryStatistics对象的收集器，通过它可以获得将mapper应用于</span></span><br><span class="line">    <span class="comment">//每个元素后所产生的结果的个数、总和、平均值、最大值和最小值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line">    Collector&lt;T, ?, LongSummaryStatistics&gt; summarizingLong(ToLongFunction&lt;? <span class="built_in">super</span> T&gt; mapper) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CollectorImpl</span>&lt;T, LongSummaryStatistics, LongSummaryStatistics&gt;(</span><br><span class="line">                LongSummaryStatistics::<span class="keyword">new</span>,</span><br><span class="line">                (r, t) -&gt; r.accept(mapper.applyAsLong(t)),</span><br><span class="line">                (l, r) -&gt; &#123; l.combine(r); <span class="keyword">return</span> l; &#125;, CH_ID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生能够生产DoubleSummaryStatistics对象的收集器，通过它可以获得将mapper应用于</span></span><br><span class="line">    <span class="comment">//每个元素后所产生的结果的个数、总和、平均值、最大值和最小值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line">    Collector&lt;T, ?, DoubleSummaryStatistics&gt; summarizingDouble(ToDoubleFunction&lt;? <span class="built_in">super</span> T&gt; mapper) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CollectorImpl</span>&lt;T, DoubleSummaryStatistics, DoubleSummaryStatistics&gt;(</span><br><span class="line">                DoubleSummaryStatistics::<span class="keyword">new</span>,</span><br><span class="line">                (r, t) -&gt; r.accept(mapper.applyAsDouble(t)),</span><br><span class="line">                (l, r) -&gt; &#123; l.combine(r); <span class="keyword">return</span> l; &#125;, CH_ID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="群组和分区"><a href="#群组和分区" class="headerlink" title="群组和分区"></a>群组和分区</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Collectors</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//产生一个收集器，它会产生一个映射表，</span></span><br><span class="line">   <span class="comment">//其键是将classifier应用于所有收集到的元素上所产生的结果，而值是由具有相同键的元素构成的一个个列表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt;</span><br><span class="line">    groupingBy(Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">K</span>&gt; classifier) &#123;</span><br><span class="line">        <span class="keyword">return</span> groupingBy(classifier, toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//产生一个收集器，它会产生一个并发映射表</span></span><br><span class="line">   <span class="comment">//其键是将classifier应用于所有收集到的元素上所产生的结果，而值是由具有相同键的元素构成的一个个列表</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K&gt;</span><br><span class="line">    Collector&lt;T, ?, ConcurrentMap&lt;K, List&lt;T&gt;&gt;&gt;</span><br><span class="line">    groupingByConcurrent(Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">K</span>&gt; classifier) &#123;</span><br><span class="line">        <span class="keyword">return</span> groupingByConcurrent(classifier, ConcurrentHashMap::<span class="keyword">new</span>, toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//产生一个收集器，他会产生一个映射表，其键是true/false，而值是由满足/不满足断言的元素构成的列表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line">    Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate) &#123;</span><br><span class="line">        <span class="keyword">return</span> partitioningBy(predicate, toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="下游收集器"><a href="#下游收集器" class="headerlink" title="下游收集器"></a>下游收集器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Collectors</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生一个可以对收集到的元素进行计数的收集器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Long&gt;</span><br><span class="line">    counting() &#123;</span><br><span class="line">        <span class="keyword">return</span> reducing(<span class="number">0L</span>, e -&gt; <span class="number">1L</span>, Long::sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生一个收集器，对将mapper应用到收集到的元素上之后产生的值计算总和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Integer&gt;</span><br><span class="line">    summingInt(ToIntFunction&lt;? <span class="built_in">super</span> T&gt; mapper) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CollectorImpl</span>&lt;&gt;(</span><br><span class="line">                () -&gt; <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>],</span><br><span class="line">                (a, t) -&gt; &#123; a[<span class="number">0</span>] += mapper.applyAsInt(t); &#125;,</span><br><span class="line">                (a, b) -&gt; &#123; a[<span class="number">0</span>] += b[<span class="number">0</span>]; <span class="keyword">return</span> a; &#125;,</span><br><span class="line">                a -&gt; a[<span class="number">0</span>], CH_NOID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生一个收集器，对将mapper应用到收集到的元素上之后产生的值计算总和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Long&gt;</span><br><span class="line">    summingLong(ToLongFunction&lt;? <span class="built_in">super</span> T&gt; mapper) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CollectorImpl</span>&lt;&gt;(</span><br><span class="line">                () -&gt; <span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">1</span>],</span><br><span class="line">                (a, t) -&gt; &#123; a[<span class="number">0</span>] += mapper.applyAsLong(t); &#125;,</span><br><span class="line">                (a, b) -&gt; &#123; a[<span class="number">0</span>] += b[<span class="number">0</span>]; <span class="keyword">return</span> a; &#125;,</span><br><span class="line">                a -&gt; a[<span class="number">0</span>], CH_NOID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生一个收集器，对将mapper应用到收集到的元素上之后产生的值计算总和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt;</span><br><span class="line">    summingDouble(ToDoubleFunction&lt;? <span class="built_in">super</span> T&gt; mapper) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * In the arrays allocated for the collect operation, index 0</span></span><br><span class="line"><span class="comment">         * holds the high-order bits of the running sum, index 1 holds</span></span><br><span class="line"><span class="comment">         * the low-order bits of the sum computed via compensated</span></span><br><span class="line"><span class="comment">         * summation, and index 2 holds the simple sum used to compute</span></span><br><span class="line"><span class="comment">         * the proper result if the stream contains infinite values of</span></span><br><span class="line"><span class="comment">         * the same sign.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CollectorImpl</span>&lt;&gt;(</span><br><span class="line">                () -&gt; <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">3</span>],</span><br><span class="line">                (a, t) -&gt; &#123; sumWithCompensation(a, mapper.applyAsDouble(t));</span><br><span class="line">                            a[<span class="number">2</span>] += mapper.applyAsDouble(t);&#125;,</span><br><span class="line">                (a, b) -&gt; &#123; sumWithCompensation(a, b[<span class="number">0</span>]);</span><br><span class="line">                            a[<span class="number">2</span>] += b[<span class="number">2</span>];</span><br><span class="line">                            <span class="keyword">return</span> sumWithCompensation(a, b[<span class="number">1</span>]); &#125;,</span><br><span class="line">                a -&gt; computeFinalSum(a),</span><br><span class="line">                CH_NOID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生一个收集器，使用comparator指定的排序方法，计算收集到的元素中的最大值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt;</span><br><span class="line">    maxBy(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator) &#123;</span><br><span class="line">        <span class="keyword">return</span> reducing(BinaryOperator.maxBy(comparator));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生一个收集器，使用comparator指定的排序方法，计算收集到的元素中的最小值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt;</span><br><span class="line">    minBy(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator) &#123;</span><br><span class="line">        <span class="keyword">return</span> reducing(BinaryOperator.minBy(comparator));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生一个收集器，它会产生一个映射表，其键是将mapper应用到收集到的数据上而产生的，</span></span><br><span class="line">    <span class="comment">//其值是使用downstream收集器收集到的具有相同键的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U, A, R&gt;</span><br><span class="line">    Collector&lt;T, ?, R&gt; mapping(Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">U</span>&gt; mapper,</span><br><span class="line">                               Collector&lt;? <span class="built_in">super</span> U, A, R&gt; downstream) &#123;</span><br><span class="line">        BiConsumer&lt;A, ? <span class="built_in">super</span> U&gt; downstreamAccumulator = downstream.accumulator();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CollectorImpl</span>&lt;&gt;(downstream.supplier(),</span><br><span class="line">                                   (r, t) -&gt; downstreamAccumulator.accept(r, mapper.apply(t)),</span><br><span class="line">                                   downstream.combiner(), downstream.finisher(),</span><br><span class="line">                                   downstream.characteristics());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/icarusliu/article/details/79504602">https://blog.csdn.net/icarusliu/article/details/79504602</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.yuque.com/chavy/kye3ke/cqbk2u#jz1we">https://www.yuque.com/chavy/kye3ke/cqbk2u#jz1we</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://fulsun.github.io">凉月</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://fulsun.github.io/p/c735a0b1">https://fulsun.github.io/p/c735a0b1</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://fulsun.github.io" target="_blank">凉月の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/medias/featureimages/006.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/4a17b156" title="Hello World"><img class="cover" src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/002.jpg" onerror="onerror=null;src='/medias/detail/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Hello World</div></div></a></div><div class="next-post pull-right"><a href="/p/638b4131" title="Jdk常见新特性"><img class="cover" src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/013.jpg" onerror="onerror=null;src='/medias/detail/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Jdk常见新特性</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/avatar.jpg" onerror="this.onerror=null;this.src='/medias/detail/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">凉月</div><div class="author-info__description">记录生活,分享知识。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/fulsun"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/fulsun" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:fl_6145@163.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">感谢访问本站，若喜欢请收藏 ^_^</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0"><span class="toc-text">简述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%81"><span class="toc-text">什么是流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%92%8C%E6%B5%81%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-text">集合和流的差异</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">流的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">流的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#filter%E3%80%81map%E3%80%81flatMap%E6%96%B9%E6%B3%95"><span class="toc-text">filter、map、flatMap方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E5%8F%96%E5%AD%90%E6%B5%81%E5%92%8C%E8%BF%9E%E6%8E%A5%E6%B5%81"><span class="toc-text">抽取子流和连接流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%9A%84%E6%B5%81%E8%BD%AC%E6%8D%A2"><span class="toc-text">其他的流转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E7%AE%80%E6%93%8D%E4%BD%9C"><span class="toc-text">约简操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reduce%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-text">reduce的说明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="toc-text">参数设置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84Reduce"><span class="toc-text">一个参数的Reduce</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84Reduce"><span class="toc-text">两个参数的Reduce</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84Reduce"><span class="toc-text">三个参数的Reduce</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0%E8%AF%AF%E8%A7%A3"><span class="toc-text">三个参数误解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#collect"><span class="toc-text">collect</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E7%A4%BA%E4%BE%8B"><span class="toc-text">并行示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E9%81%8D%E5%8E%86"><span class="toc-text">数据收集遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#iterator"><span class="toc-text">iterator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forEach"><span class="toc-text">forEach</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toArray%E6%96%B9%E6%B3%95"><span class="toc-text">toArray方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#collect%E5%85%83%E7%B4%A0%E6%94%B6%E9%9B%86%E5%88%B0%E9%9B%86%E5%90%88"><span class="toc-text">collect元素收集到集合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%B5%81"><span class="toc-text">基本类型流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E6%B5%81"><span class="toc-text">并行流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E6%B5%81%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">并行流的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E6%B5%81%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="toc-text">并行流的性能问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3Fork-Join-%E6%A1%86%E6%9E%B6"><span class="toc-text">简单了解Fork&#x2F;Join 框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ForkJoinPool"><span class="toc-text">ForkJoinPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E6%B5%81%E7%9A%84%E9%99%B7%E9%98%B1"><span class="toc-text">并行流的陷阱</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collectors%E7%B1%BB%E5%9E%8B"><span class="toc-text">Collectors类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B6%E9%9B%86%E7%BB%93%E6%9E%9CList-Set"><span class="toc-text">收集结果List|Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B6%E9%9B%86%E5%88%B0%E6%98%A0%E5%B0%84%E8%A1%A8Map"><span class="toc-text">收集到映射表Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">基础数据类型收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BE%A4%E7%BB%84%E5%92%8C%E5%88%86%E5%8C%BA"><span class="toc-text">群组和分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E6%B8%B8%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">下游收集器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="toc-text">参考文档</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/p/94e3914c" title="Import 注册组件"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/008.jpg" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Import 注册组件"/></a><div class="content"><a class="title" href="/p/94e3914c" title="Import 注册组件">Import 注册组件</a><time datetime="2024-07-15T22:24:08.000Z" title="发表于 2024-07-15 22:24:08">2024-07-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/a0c53761" title="Configuration Bean 注册组件"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/012.jpg" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Configuration Bean 注册组件"/></a><div class="content"><a class="title" href="/p/a0c53761" title="Configuration Bean 注册组件">Configuration Bean 注册组件</a><time datetime="2024-07-15T21:24:08.000Z" title="发表于 2024-07-15 21:24:08">2024-07-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/65826306" title="Spring5新功能"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/008.jpg" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Spring5新功能"/></a><div class="content"><a class="title" href="/p/65826306" title="Spring5新功能">Spring5新功能</a><time datetime="2024-07-14T17:24:08.000Z" title="发表于 2024-07-14 17:24:08">2024-07-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/40bb048a" title="JdbcTemplate与声明式事务"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/013.jpg" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="JdbcTemplate与声明式事务"/></a><div class="content"><a class="title" href="/p/40bb048a" title="JdbcTemplate与声明式事务">JdbcTemplate与声明式事务</a><time datetime="2024-07-14T11:24:08.000Z" title="发表于 2024-07-14 11:24:08">2024-07-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/92933cdb" title="Spring-AOP编程"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/012.jpg" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Spring-AOP编程"/></a><div class="content"><a class="title" href="/p/92933cdb" title="Spring-AOP编程">Spring-AOP编程</a><time datetime="2024-07-14T09:24:38.000Z" title="发表于 2024-07-14 09:24:38">2024-07-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 凉月</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://unpkg.com/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.js"></script><script src="https://unpkg.com/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null

  const initWaline = (Fn) => {
    const waline = Fn(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-fulsun.netlify.app/.netlify/functions/comment',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))

    const destroyWaline = () => {
      waline.destroy()
    }

    btf.addGlobalFn('pjax', destroyWaline, 'destroyWaline')
  }

  const loadWaline = async () => {
    if (initFn) initWaline(initFn)
    else {
      await getCSS('https://unpkg.com/@waline/client@3.1.2/dist/waline.css')
      const { init } = await import('https://unpkg.com/@waline/client@3.1.2/dist/waline.js')
      initFn = init || Waline.init
      initWaline(initFn)
      window.walineFn = initFn
    }
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://unpkg.com/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>