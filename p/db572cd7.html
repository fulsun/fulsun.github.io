<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java的单例模式,继承,多态，接口和抽象类 | 凉月の博客</title><meta name="author" content="凉月"><meta name="copyright" content="凉月"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java面向对象">
<meta property="og:type" content="article">
<meta property="og:title" content="Java的单例模式,继承,多态，接口和抽象类">
<meta property="og:url" content="https://fulsun.github.io/p/db572cd7">
<meta property="og:site_name" content="凉月の博客">
<meta property="og:description" content="Java面向对象">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fulsun.github.io/medias/featureimages/006.jpg">
<meta property="article:published_time" content="2018-08-07T01:08:28.000Z">
<meta property="article:modified_time" content="2024-10-17T07:06:55.386Z">
<meta property="article:author" content="凉月">
<meta property="article:tag" content="凉月">
<meta property="article:tag" content="凉月文">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="web网站">
<meta property="article:tag" content="经验分享">
<meta property="article:tag" content="hexo">
<meta property="article:tag" content="个人博客">
<meta property="article:tag" content="生活记录等">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fulsun.github.io/medias/featureimages/006.jpg"><link rel="shortcut icon" href="/medias/favicon.png"><link rel="canonical" href="https://fulsun.github.io/p/db572cd7"><link rel="preconnect" href="//unpkg.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"至上次更新后的","messageNext":"天,文章内容可能已过时。"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 凉月","link":"链接: ","source":"来源: 凉月の博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://unpkg.com/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java的单例模式,继承,多态，接口和抽象类',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-17 07:06:55'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/avatar.jpg" onerror="onerror=null;src='/medias/detail/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-heartbeat"></i><span> 我的</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> 联系</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user-circle"></i><span> 博主</span></a></li><li><a class="site-page child" href="/contact"><i class="fa-fw fas fa-comments"></i><span> 留言</span></a></li><li><a class="site-page child" href="/journal"><i class="fa-fw fas fa-cogs"></i><span> 日志</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> JS动画</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/snake/"><i class="fa-fw fas fa-gamepad"></i><span> 贪吃蛇</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/medias/featureimages/006.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="凉月の博客"><span class="site-name">凉月の博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-heartbeat"></i><span> 我的</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> 联系</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user-circle"></i><span> 博主</span></a></li><li><a class="site-page child" href="/contact"><i class="fa-fw fas fa-comments"></i><span> 留言</span></a></li><li><a class="site-page child" href="/journal"><i class="fa-fw fas fa-cogs"></i><span> 日志</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> JS动画</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/snake/"><i class="fa-fw fas fa-gamepad"></i><span> 贪吃蛇</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java的单例模式,继承,多态，接口和抽象类</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2018-08-07T01:08:28.000Z" title="发表于 2018-08-07 01:08:28">2018-08-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-17T07:06:55.386Z" title="更新于 2024-10-17 07:06:55">2024-10-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JavaSE/">JavaSE</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>34分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java的单例模式,继承,多态，接口和抽象类"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><span id="more"></span>

<h2 id="paivate关键字"><a href="#paivate关键字" class="headerlink" title="paivate关键字"></a>paivate关键字</h2><ul>
<li>private关键字特点<ul>
<li>是一个权限修饰符</li>
<li>可以修饰成员变量和成员方法</li>
<li>被其修饰的成员只能在本类中被访问</li>
</ul>
</li>
<li>private最常见的应用<ul>
<li>把成员变量用private修饰，提供对应的getXxx()和setXxx()方法</li>
</ul>
</li>
</ul>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul>
<li>保证创建的对象 始终是同一个</li>
</ul>
<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><ul>
<li><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Test2</span>  <span class="variable">t2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Test2</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pbulic <span class="keyword">static</span> Test2 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(t2==<span class="literal">null</span>)&#123;</span><br><span class="line">			t2 = <span class="keyword">new</span> <span class="title class_">Test2</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> t2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><ul>
<li><p>代码如下；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Test2</span> <span class="variable">t2</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test2</span>();</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Test2</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Test2 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> t2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h3><ol>
<li>饿汉类加载时对象就创建了,多线程访问，安全；</li>
<li>懒汉在使用时，才会创建对象；多线程访问，不妾全。</li>
</ol>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li><p>根据已有的类 派生出 新类的技术</p>
</li>
<li><p>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。</p>
</li>
<li><p>优点:</p>
<ul>
<li>代码重用；</li>
<li>方便维护，高耦合。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>破坏封装</li>
</ul>
</li>
<li><p>继承的注意事项：</p>
<ul>
<li>private 修饰的不能继承，<ul>
<li>private类型的方法默认是final类型</li>
</ul>
</li>
</ul>
</li>
<li><p>构造器不能继承,但能通过super调用</p>
</li>
<li><p>不在同一包下的子类可以使用父类使用默认修饰符的方法</p>
</li>
<li><p>继承遵循的原则:里氏替换原则(LSP):将父类用子类替换,程序不会出错</p>
</li>
<li><p>继承仅支持单继承，不支持多继承</p>
</li>
<li><p>继承的格式：通过extends关键字可以实现类与类的继承</p>
<ul>
<li><code> class 子类名 extends 父类名 &#123;&#125;</code></li>
<li>父类也叫基类或者超类</li>
<li>子类也叫派生类。</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">class</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Parent</span><span class="params">()</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;父类的无参构造被调用了。。。&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;子类的无参构造被调用了。。。&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  父类的无参构造别调用了。。。</span><br><span class="line">  子类的无参构造别调用了。。。</span><br><span class="line"></span><br><span class="line">### 子类继承的成员</span><br><span class="line"></span><br><span class="line">- 子类不能继承父类的构造方法，但是可以通过<span class="built_in">super</span>(待会儿讲)关键字去访问父类构造方法。</span><br><span class="line">- 子类和父类在同一个包中时，子类可以继承父类的除<span class="keyword">private</span>属性的所有方法和成员变量</span><br><span class="line">- 当子类与父类不在同一个包中时，子类只能继承父类的<span class="keyword">protected</span>和<span class="keyword">public</span>属性的成员变量和方法。</span><br><span class="line">- 子类中定义的成员变量和父类中的成员变量同名时，子类就隐藏了继承的成员变量；</span><br><span class="line">- 子类中定义一个方法，并且这个方法的名字、返回类型、参数个数和类型与从父类继承的方法完全相同，子类就隐藏从父类继承来的方法（方法的重写）。</span><br><span class="line">- <span class="keyword">final</span>类不能被继承，没有子类，<span class="keyword">final</span>类中的方法默认是<span class="keyword">final</span>的。<span class="keyword">final</span>方法不能被子类的方法覆盖，但可以被继承。<span class="keyword">final</span>不能用于修饰构造方法。</span><br><span class="line"></span><br><span class="line">### 子类访问父类的构造方法</span><br><span class="line"></span><br><span class="line">- **创建子类对象时 一定会先调用父类的无参构造。必须确保在执行派生类的构造函数时，从基类继承的私有数据成员已经被初始化了。**</span><br><span class="line"></span><br><span class="line">- 在子类的构造器中 ，如果没有显示的调用父类的构造器`<span class="built_in">super</span>()`,或者没有显示的调用本类构造 `<span class="built_in">this</span>()`,那么 编译器 一定会分配一个 <span class="built_in">super</span>() 调用父类的无参构造。</span><br><span class="line"></span><br><span class="line">- `<span class="built_in">super</span>() `位置在子类构造中 ，而且是**第一行**代码处。</span><br><span class="line"></span><br><span class="line">  - <span class="built_in">super</span>(); <span class="comment">// 无参</span></span><br><span class="line"></span><br><span class="line">- <span class="built_in">super</span>(参数); <span class="comment">//带参</span></span><br><span class="line">- 父类没有无参构造,只有带参构造,解决办法:</span><br><span class="line">  - 类通过<span class="built_in">super</span>去显示调用父类其他的带参的构造方法</span><br><span class="line">  - 在父类写上无参构造</span><br><span class="line">- 子类通过<span class="built_in">this</span>去调用本类的其他构造方法(本类其他构造也必须首先访问了父类构造)</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Parent</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.age = <span class="number">20</span>;</span><br><span class="line">          System.out.println(<span class="string">&quot;父类的无参构造被调用了。。。&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;hello:我是父类&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="built_in">super</span>(<span class="number">1</span>); <span class="comment">// 可以调用带参构造，否则编译报错</span></span><br><span class="line">          System.out.println(<span class="string">&quot;子类的无参构造被调用了。。。&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="comment">//调用父类的hello方法</span></span><br><span class="line">          <span class="comment">// super.hello();</span></span><br><span class="line">          System.out.println(<span class="string">&quot;hello:我是子类&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">### 不支持多继承影响</span><br><span class="line"></span><br><span class="line">- Java 不支持多继承影响</span><br><span class="line">  - Java 相比于其他面向对象语言，如 C++，设计上有一些基本区别，比如Java 不支持多继承。这种限制，在规范了代码实现的同时，也产生了一些局限性，影响着程序设计结构。Java 类可以实现多个接口，因为接口是抽象方法的集合，所以这是声明性的，但不能通过扩展多个抽象类来重用逻辑。</span><br><span class="line">  - 在一些情况下存在特定场景，需要抽象出与具体实现、实例化无关的通用逻辑，或者纯调用关系的逻辑，但是使用传统的抽象类会陷入到单继承的窘境。</span><br><span class="line">- 为什么是单继承而不能多继承呢？</span><br><span class="line">  - 若为多继承，那么当多个父类中有重复的属性或者方法时，子类的调用结果会含糊不清，因此用了单继承。</span><br><span class="line">  - 多继承虽然能使子类同时拥有多个父类的特征，但是其缺点也是很显著的，主要有两方面：</span><br><span class="line">    - 如果在一个子类继承的多个父类中拥有相同名字的实例变量，子类在引用该变量时将产生歧义，无法判断应该使用哪个父类的变量。</span><br><span class="line">    - 如果在一个子类继承的多个父类中拥有相同方法，子类中有没有覆盖该方法，那么调用该方法时将产生歧义，无法判断应该调用哪个父类的方法。</span><br><span class="line">  - Java是从C++语言上优化而来，而C++也是面向对象的，为什么它却可以多继承的呢？首先，C++语言是<span class="number">1983</span>年在C语言的基础上推出的，Java语言是<span class="number">1995</span>年推出的。其次，在C++被设计出来后，就会经常掉入多继承这个陷阱，虽然它也提出了相应的解决办法，但Java语言本着简单的原则舍弃了C++中的多继承，这样也会使程序更具安全性。</span><br><span class="line">- 为什么是多实现呢？</span><br><span class="line">  - 通过实现接口拓展了类的功能，若实现的多个接口中有重复的方法也没关系，因为实现类中必须重写接口中的方法，所以调用时还是调用的实现类中重写的方法。</span><br><span class="line"></span><br><span class="line">## 抽象类</span><br><span class="line"></span><br><span class="line">- 在面向对象的概念中，所有的对象都是通过类来描绘的。但并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类（Abstract）。</span><br><span class="line"></span><br><span class="line">- 只约定类所具有的抽象行为，没有具体实行对应的行为,提供一个模板的作用。</span><br><span class="line"></span><br><span class="line">- 用<span class="keyword">abstract</span>修饰的类，即抽象类</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="comment">// 这就是一个抽象类</span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">      String name;</span><br><span class="line">      <span class="type">int</span> age;</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 动物会叫</span></span><br><span class="line">      <span class="comment">// 不确定动物怎么叫的。定义成抽象方法，来解决父类方法的不确定性。</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 格式</span><br><span class="line"></span><br><span class="line">- 因为抽象类需要子类继承，子类创建对象的时候会默认调用父类的无参数构造函数。所以抽象类中必须有构造函数</span><br><span class="line"></span><br><span class="line">- 格式如下：</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="keyword">abstract</span> class 类名&#123;</span><br><span class="line">      构造方法</span><br><span class="line">  	常量；</span><br><span class="line">  	变量；</span><br><span class="line">  	访问修饰符 <span class="keyword">abstract</span> 返回类型 方法名（）；<span class="comment">//抽象方法</span></span><br><span class="line">  	普通方法；</span><br><span class="line">  	静态方法()；</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>抽象类不能创建对象</li>
<li>抽象方法不是必须定义</li>
<li>带有抽象方法类的必须是抽象类</li>
<li>构造方法不能是抽象的；</li>
<li>子类继承抽象类必须重写所有的抽象方法，除非子类是抽象类</li>
<li>abstract 不能与 private ,final,static 使用<ul>
<li>private 不能被继承，就不能重写<ul>
<li>final 不能被重写</li>
<li>static 方法没有方法体，无意义</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><ul>
<li><p>用abstract修饰的方法，即抽象方法。</p>
</li>
<li><p>抽象方法在父类中不能实现，所以没有函数体<code>&#123;&#125;</code>。</p>
<ul>
<li><code> public abstract void cry();</code></li>
</ul>
</li>
<li><p>子类必须实现父类的所有抽象方法</p>
<ul>
<li>重写父类的抽象方法</li>
<li>抽象子类除外</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动物会叫</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类可以被继承</span></span><br><span class="line"><span class="comment">// 当继承的父类是抽象类时，需要将抽象类中的所有抽象方法全部实现。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 实现父类的cry抽象方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫叫:&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><p>构造方法不能是抽象的,</p>
<ul>
<li>构造方法不能被继承</li>
<li>抽象的方法要子类重写，矛盾</li>
</ul>
</li>
<li><p>虽然抽象类不能被实例化，但可以有构造函数。由于抽象类的构造函数在实例化派生类之前发生，所以，可以在这个阶段初始化抽象类字段或执行其它与子类相关的代码。</p>
</li>
</ul>
<h3 id="抽象类名作为形参"><a href="#抽象类名作为形参" class="headerlink" title="抽象类名作为形参"></a>抽象类名作为形参</h3><ul>
<li><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*抽象类作为参数的时候如何进行调用*/</span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">      <span class="comment">// 定义一个抽象方法</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 定义一个类</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;吃.................&quot;</span>) ;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 定义一个类</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">AnimalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat() ;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 测试类</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">ArgsDemo2</span>  &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建AnimalDemo的对象</span></span><br><span class="line">        <span class="type">AnimalDemo</span> <span class="variable">ad</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnimalDemo</span>() ;</span><br><span class="line">        <span class="comment">// 对Animal进行间接实例化</span></span><br><span class="line">        <span class="comment">// Animal a = new Cat() ;</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>() ;</span><br><span class="line">        <span class="comment">// 调用method方法</span></span><br><span class="line">        ad.method(a) ;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ### 抽象类名作为返回值类型</span><br><span class="line"></span><br><span class="line">- 代码如下：</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="comment">/*抽象类作为返回值类型*/</span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 定义一个子类</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;吃..........................&quot;</span>) ;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 定义一个类</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">AnimalDemo</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> Animal <span class="title function_">getAnimal</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="comment">// Animal a = new Cat() ;</span></span><br><span class="line">          <span class="comment">// return a;</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>() ;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 测试类</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">ReturnDemo2</span>  &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          <span class="comment">// 调用AnimalDemo的getAnimal这个方法</span></span><br><span class="line">          <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span>  AnimalDemo.getAnimal() ;</span><br><span class="line">          <span class="comment">// 调用方法</span></span><br><span class="line">          a.eat() ;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## getSuperclass</span><br><span class="line"></span><br><span class="line">- 返回直接继承的父类（由于编译擦除，**没有显示泛型参数**）</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  Class&lt;? <span class="built_in">super</span> T&gt; getSuperclass()</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回表示此 <code>Class</code> 所表示的实体（类、接口、基本类型或 void）的超类的 <strong>Class</strong>。</p>
<ul>
<li>如果此 <code>Class</code> 表示 <code>Object</code> 类、一个接口、一个基本类型或 void，则返回 null。</li>
<li>如果此对象表示一个数组类，则返回表示该 <code>Object</code> 类的 <code>Class</code> 对象。</li>
</ul>
</li>
</ul>
<h2 id="getGenericSuperclass"><a href="#getGenericSuperclass" class="headerlink" title="getGenericSuperclass"></a>getGenericSuperclass</h2><ul>
<li><p>返回直接继承的父类（<strong>包含泛型参数</strong>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type <span class="title function_">getGenericSuperclass</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>返回表示此 <code>Class</code> 所表示的实体（类、接口、基本类型或 void）的直接超类的 <strong>Type</strong>。</p>
</li>
<li><p>如果超类是参数化类型，则返回的 <code>Type</code> 对象必须准确反映源代码中所使用的实际类型参数。</p>
</li>
<li><p>如果以前未曾创建表示超类的参数化类型，则创建这个类型。有关参数化类型创建过程的语义，请参阅 <code>ParameterizedType</code> 声明。</p>
</li>
<li><p>如果此 <code>Class</code> 表示 <code>Object</code> 类、接口、基本类型或 void，则返回 null。</p>
</li>
<li><p>如果此对象表示一个数组类，则返回表示 <code>Object</code> 类的 <code>Class</code> 对象。</p>
</li>
<li><p><strong>抛出：</strong></p>
<ul>
<li><code>GenericSignatureFormatError</code> 如果常规类签名不符合 Java Virtual Machine Specification, 3rd edition 规定的格式</li>
<li><code>TypeNotPresentException</code> - 如果常规超类引用不存在的类型声明</li>
<li><code>MalformedParameterizedTypeException</code> - 如果常规超类引用的参数化类型由于某种原因无法实例化</li>
</ul>
</li>
<li><p>代码实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student.class.getSuperclass()\t&quot;</span></span><br><span class="line">                           + Student.class.getSuperclass());</span><br><span class="line">        System.out.println(<span class="string">&quot;Student.class.getGenericSuperclass()\t&quot;</span></span><br><span class="line">                           + Student.class.getGenericSuperclass());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Test.class.getSuperclass()\t&quot;</span></span><br><span class="line">                           + Test.class.getSuperclass());</span><br><span class="line">        System.out.println(<span class="string">&quot;Test.class.getGenericSuperclass()\t&quot;</span></span><br><span class="line">                           + Test.class.getGenericSuperclass());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Object.class.getGenericSuperclass()\t&quot;</span></span><br><span class="line">                           + Object.class.getGenericSuperclass());</span><br><span class="line">        System.out.println(<span class="string">&quot;Object.class.getSuperclass()\t&quot;</span></span><br><span class="line">                           + Object.class.getSuperclass());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;void.class.getSuperclass()\t&quot;</span></span><br><span class="line">                           + <span class="keyword">void</span>.class.getSuperclass());</span><br><span class="line">        System.out.println(<span class="string">&quot;void.class.getGenericSuperclass()\t&quot;</span></span><br><span class="line">                           + <span class="keyword">void</span>.class.getGenericSuperclass());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;int[].class.getSuperclass()\t&quot;</span></span><br><span class="line">                           + <span class="type">int</span>[].class.getSuperclass());</span><br><span class="line">        System.out.println(<span class="string">&quot;int[].class.getGenericSuperclass()\t&quot;</span></span><br><span class="line">                           + <span class="type">int</span>[].class.getGenericSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&lt;Test&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Student.class.getSuperclass()			<span class="keyword">class</span> <span class="title class_">cn</span>.test.Person</span><br><span class="line">Student.class.getGenericSuperclass()	cn.test.Person&lt;cn.test.Test&gt;</span><br><span class="line">Test.class.getSuperclass()				<span class="keyword">class</span> <span class="title class_">java</span>.lang.Object</span><br><span class="line">Test.class.getGenericSuperclass()		<span class="keyword">class</span> <span class="title class_">java</span>.lang.Object</span><br><span class="line">Object.class.getGenericSuperclass()		<span class="literal">null</span></span><br><span class="line">Object.class.getSuperclass()			<span class="literal">null</span></span><br><span class="line"><span class="keyword">void</span>.class.getSuperclass()				<span class="literal">null</span></span><br><span class="line"><span class="keyword">void</span>.class.getGenericSuperclass()		<span class="literal">null</span></span><br><span class="line"><span class="type">int</span>[].class.getSuperclass()				<span class="keyword">class</span> <span class="title class_">java</span>.lang.Object</span><br><span class="line"><span class="type">int</span>[].class.getGenericSuperclass()		<span class="keyword">class</span> <span class="title class_">java</span>.lang.Object</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><ul>
<li><code>@override</code> 注解,给编译器提示信息,会检查重写规则的正误</li>
<li>重写是建立在java类的三大特性之一：继承性的基础之上的，没有继承性也就不能谈方法的重写。方法重写又称方法覆盖。</li>
<li><strong>方法的重写是当程序中父类的某一个方法并不能满足子类的需求时，子类可以重新定义该方法的内容与功能来满足子类的需求的一种操作</strong>。</li>
<li>如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类。</li>
</ul>
<h3 id="重写注意事项"><a href="#重写注意事项" class="headerlink" title="重写注意事项"></a>重写注意事项</h3><ul>
<li><p>子类中的方法与父类中的方法，有相同的<strong>返回类型</strong>、相同的<strong>方法名称</strong>、相同的<strong>参数列表</strong></p>
</li>
<li><p>子类中的方法的访问级别，不能低于父类中该方法的访问级别</p>
<ul>
<li><p>如果Child类的 outPut() 方法的访问级别为 private ，将会与 java 的多态机制发生冲突</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Parent</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="comment">// 编译器会认为以上是合法的，</span></span><br><span class="line"><span class="comment">// 但在运行时，根据动态绑定规则，Java虚拟机会调用 parent 变量所引用的 Child 实例的 outPut()  方法，</span></span><br><span class="line">parent.outPut();</span><br><span class="line"><span class="comment">//而 Child 的 outPut() 方法为 private，Java虚拟机无法访问。</span></span><br><span class="line"><span class="comment">//为了避免这样的矛盾， Java 虚拟机不允许子类方法缩小父类中被覆盖方法的访问权限。</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>子类中方法抛出的异常范围，不能大于父类中方法抛出的异常的范围</p>
</li>
<li><p>不能重写的情况</p>
<ul>
<li>如果父类中含有一个静态方法，且在子类中也含有一个返回类型、方法名、参数列表均与之相同的静态方法，那么该子类实际上只是将父类中的该同名方法进行了隐藏，而非重写。换句话说，父类和子类中含有的其实是两个没有关系的方法，它们的行为也并不具有多态性。</li>
<li>static方法和final方法（private方法属于final方法）是前期绑定，而其他所有的方法都是后期绑定了。</li>
<li>private 方法 可以被隐藏 不可以被重写</li>
<li>static 方法 可以被隐藏 不可以被重写</li>
<li>final 方法 不可以被重写</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Parent</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的无参构造被调用了。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello:我是父类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类的无参构造被调用了。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//调用父类的hello方法</span></span><br><span class="line">        <span class="comment">// super.hello();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hello:我是子类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Parent</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        System.out.println(parent.age);</span><br><span class="line">        parent.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">父类的无参构造被调用了。。。</span><br><span class="line">子类的无参构造被调用了。。。</span><br><span class="line"><span class="number">18</span></span><br><span class="line">hello:我是子类</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="父类的静态方法能否被子类重写"><a href="#父类的静态方法能否被子类重写" class="headerlink" title="父类的静态方法能否被子类重写"></a>父类的静态方法能否被子类重写</h3><ul>
<li>思考一下：父类的静态方法能否被子类重写？<ul>
<li>父类的静态方法是不能被子类重写的，其实重写只能适用于实例方法，不能用于静态方法，对于上面这种静态方法而言，我们应该称之为隐藏。</li>
<li>Java静态方法形式上可以重写，但从本质上来说不是Java的重写。因为静态方法只与类相关，不与具体实现相关。声明的是什么类，则引用相应类的静态方法(本来静态无需声明，可以直接引用)。并且static方法不是后期绑定的，它在编译期就绑定了。换句话说，这个方法不会进行多态的判断，只与声明的类有关。</li>
</ul>
</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul>
<li>接口（Interface）在Java语言中是一个抽象类型，是服务提供者和服务使用者之间的一个协议，在JDK1.8之前一直是抽象方法的集合，一个类通过实现接口从而来实现两者间的协议</li>
<li>接口可以定义字段和方法。在JDK1.8之前，接口中所有的方法都是抽象的，从JDK1.8开始，也可以在接口中编写默认的和静态的方法。除非显式指定，否则接口方法都是抽象的</li>
<li>简单解释：<ul>
<li>是一组公开的规则，是功能的组合。</li>
</ul>
</li>
<li>好处：<ul>
<li>降低了类之间的耦合连接</li>
<li>扩充了功能实现</li>
</ul>
</li>
<li>接口是隐式抽象的，当声明一个接口的时候，不必使用<strong>abstract</strong>关键字。</li>
<li>接口中每一个方法也是隐式抽象的，声明时同样不需要<strong>abstract</strong>关键字。</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。</li>
<li>接口的特点有哪些呢？<ul>
<li>接口没有构造方法</li>
<li>接口不能用于实例化对象</li>
<li>接口中的<strong>字段必须初始化</strong>，并且隐式地设置为<strong>公有的、静态的和fina</strong>l的。因此，为了符合规范，接口中的字段名要全部大写</li>
<li>接口不是被类继承，而是要被类实现，<strong>接口不能实现接口</strong></li>
<li>当类实现接口时，类要<strong>实现接口中所有的方法</strong>。否则，类必须声明为抽象的</li>
<li>接口中每一个方法默认是公有和抽象的，即接口中的方法会被隐式的指定为 <strong>public abstract</strong>。从JDK 1.8开始，可以在接口中编写默认的和静态的方法。声明默认方法需要使用关键字<strong>default</strong>。并且不允许定义为 private 或者 protected。</li>
<li>接口支持多重继承，即可以继承多个接口</li>
</ul>
</li>
</ul>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><ul>
<li><p>在 jdk1.8里面引入了新的关键字default，通过使用default修饰方法,可以让我们在接口里面定义具体的方法实现。Java 9 以后，甚至可以定义 private default method。Default method 提供了一种二进制兼容的扩展已有接口的办法。比如，我们熟知的 <code>java.util.Collection</code>，它是 collection 体系的 root interface，在 Java 8 中添加了一系列 default method，主要是增加 Lambda、Stream 相关的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterable</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">stream</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法的定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">CustomInterface</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span>;  <span class="comment">//抽象方法不能是私有的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面1.8之前报错</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">defaultMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        privateMethod(); <span class="comment">//可以调用接口中的私有方法</span></span><br><span class="line">        privateStaticMethod(); <span class="comment">//可以调用接口中的私有静态方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;普通方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        privateStaticMethod(); <span class="comment">//public静态方法可以调用private静态方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;静态方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面1.9之前报错</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">privateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private私有方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">privateStaticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private私有静态方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以有static修饰的实现方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 interface 接口名&#123;</span><br><span class="line">    <span class="comment">//java1.8之前，interface接口里面是只能有抽象方法和常量，不能有任何方法的实现</span></span><br><span class="line"> 	静态的常量；<span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">final</span></span><br><span class="line">	抽象方法；<span class="keyword">public</span> <span class="keyword">abstract</span></span><br><span class="line">    <span class="comment">// JDK 1.8 以后，接口里可以有静态方法和方法体了。</span></span><br><span class="line">	默认方法；(<span class="number">1.8</span>后支持)<span class="keyword">default</span>,可以有方法体</span><br><span class="line">	静态方法；(<span class="number">1.8</span>后支持)<span class="keyword">static</span></span><br><span class="line">	静态内部类型；<span class="keyword">public</span> <span class="keyword">static</span> 内部类，内部接口， 内部枚举<span class="keyword">enum</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IFood</span> &#123;</span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">eatDinner</span><span class="params">()</span>;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">feedPet</span><span class="params">()</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;记得给小泰迪吃晚餐&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">feedFood</span><span class="params">()</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;小泰迪晚上要吃肉&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IFruit</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dessert</span><span class="params">()</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span>  <span class="title function_">feedPet</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小泰迪不喜欢吃水果&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title function_">feedFood</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小泰迪晚晚餐不需要甜点&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">### Marker Interface</span><br><span class="line"></span><br><span class="line">- 接口的职责也不仅仅限于抽象方法的集合，其实有各种不同的实践。</span><br><span class="line">- 有一类没有任何方法的接口，通常叫作 Marker Interface，顾名思义，它的目的就是为了声明某些东西，比如我们熟知的 Cloneable、Serializable 等。这种用法，也存在于业界其他的 Java 产品代码中。</span><br><span class="line"></span><br><span class="line">### 默认方法</span><br><span class="line"></span><br><span class="line">- 之前开发中，接口实现了就不能更改，有新的需求，</span><br><span class="line"></span><br><span class="line">  - 写一个新的接口，</span><br><span class="line">  - 继承之前的接口，</span><br><span class="line">  - 添加新功能，</span><br><span class="line">  - 实现该类，</span><br><span class="line">  - 调用新类。</span><br><span class="line"></span><br><span class="line">- <span class="number">1.8</span>之后，可以在原来的接口中，</span><br><span class="line"></span><br><span class="line">  - 写入新的默认方法，</span><br><span class="line">  - 调用默认方法。</span><br><span class="line"></span><br><span class="line">### 静态方法</span><br><span class="line"></span><br><span class="line">- 只能通过**接口名调用**，不可以通过实现类的类名或者实现类的对象调用。</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span>  <span class="title function_">f2</span><span class="params">()</span>&#123;</span><br><span class="line">  		 System.out.println(<span class="string">&quot;A接口中的默认方法&quot;</span>);</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">  		System.out.println(<span class="string">&quot;A_静态方法！&quot;</span>);</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">B</span> &#123;</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span>  <span class="title function_">f2</span><span class="params">()</span>&#123;</span><br><span class="line">  		 System.out.println(<span class="string">&quot;B接口中的默认方法&quot;</span>);</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">  		System.out.println(<span class="string">&quot;B_静态方法！&quot;</span>);</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//==============重写同名的默认方法====================</span></span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span>,B&#123;</span><br><span class="line">  	<span class="meta">@Override</span></span><br><span class="line">  	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">  		B.<span class="built_in">super</span>.f2();		<span class="comment">//重写B接口的f2()方法</span></span><br><span class="line">  		B.<span class="built_in">super</span>.f2();		<span class="comment">//重写A接口的f2()方法</span></span><br><span class="line">  	<span class="comment">//可以使用内部类的分别重写A,B</span></span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ==============测试================</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">implements</span> <span class="title class_">C</span>&#123;</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  		A.f();		<span class="comment">//接口静态方法 通过接口名调用</span></span><br><span class="line">  		B.f();		<span class="comment">//接口静态方法 通过接口名调用</span></span><br><span class="line">  		<span class="type">Test</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();	<span class="comment">//接口默认方法 通过接口实现类的对象调用</span></span><br><span class="line">  		d1.f2();</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">### 接口的继承</span><br><span class="line"></span><br><span class="line">- 一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。</span><br><span class="line"></span><br><span class="line">- 下面的Sports接口被Hockey接口继承：</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Sports</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHomeTeam</span><span class="params">(String name)</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVisitingTeam</span><span class="params">(String name)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 文件名: Football.java</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Football</span> <span class="keyword">extends</span> <span class="title class_">Sports</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">homeTeamScored</span><span class="params">(<span class="type">int</span> points)</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitingTeamScored</span><span class="params">(<span class="type">int</span> points)</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">endOfQuarter</span><span class="params">(<span class="type">int</span> quarter)</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="接口的多继承"><a href="#接口的多继承" class="headerlink" title="接口的多继承"></a>接口的多继承</h3><ul>
<li><p>在Java中，类的多继承是不合法，但接口允许多继承。</p>
</li>
<li><p>在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。 如下所示：</p>
<p><code>public interface Hockey extends Sports, Event</code></p>
</li>
<li><p>以上的程序片段是合法定义的子接口，与类不同的是，接口允许多继承，而 Sports及 Event 可能定义或是继承相同的方法。</p>
</li>
</ul>
<h3 id="接口的多实现"><a href="#接口的多实现" class="headerlink" title="接口的多实现"></a>接口的多实现</h3><ul>
<li><p><code>　...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...</code></p>
</li>
<li><p>接口可以多实现,为解决这种多继承关系，Java8提供了下面三条规则：</p>
<ol>
<li>类中的方法优先级最高，类或父类中声明的方法的优先级高于任何声明为默认方法的优先级。</li>
<li>如果第一条无法判断，那么子接口的优先级更高：方法签名相同时，优先选择拥有最具体实现的默认方法的接口， 即如果B继承了A，那么B就比A更加具体。</li>
<li>最后，如果还是无法判断，继承了多个接口的类必须通过显式覆盖和调用期望的方法， 显式地选择使用哪一个默认方法的实现。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello from A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello from B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">implements</span> <span class="title class_">A</span>, B &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 因为B继承了A，所以B比A更具体</span></span><br><span class="line">        <span class="comment">// 所以应该选择B的hello()方法。</span></span><br><span class="line">        <span class="comment">// 所以，程序会打印输出&quot;hello from B&quot;。</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">C</span>().hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//============================================</span></span><br><span class="line"><span class="comment">// C像下面这样继承了D</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">implements</span> <span class="title class_">A</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">D</span> <span class="keyword">implements</span> <span class="title class_">A</span>, B &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// C虽然继承了D，但D中未覆盖A的默认方法。</span></span><br><span class="line">        <span class="comment">// 会在A和B中做选择，由于B更具体</span></span><br><span class="line">        <span class="comment">// 所以，程序会打印输出&quot;hello from B&quot;。</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">C</span>().hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//============================================</span></span><br><span class="line"><span class="comment">// 将上面的D稍作修改：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">implements</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//父类中声明的方法具有更高的优先级，所以程序会打印输出&quot;hello from D&quot;。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hello from D&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当一个实现类实现了多个接口，多个接口里都有相同的默认方法时，编译器无法识别谁的实现更加具体实现类必须重写该默认方法，否则编译错误,覆写有两种方式：</p>
<ul>
<li>实现类自己实现方法逻辑</li>
<li>采用super关键字来调用指定接口的默认方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">FoodFruit</span> <span class="keyword">implements</span> <span class="title class_">IFood</span>,IFruit &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eatDinner</span><span class="params">(IFoodTime  foodTime)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;晚餐&quot;</span>+foodTime.getFoodTime()+<span class="string">&quot;点吃土豆炖牛肉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dessert</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;饭后甜点吃点啥呢？葡萄还是草莓&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feedPet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 显式地选择调用接口IFood中的方法</span></span><br><span class="line">        <span class="comment">// 同理，要调用接口IFruit中的方法，可以这样：IFruit.super.feedFood()</span></span><br><span class="line">        IFood.<span class="built_in">super</span>.feedFood();</span><br><span class="line">        <span class="comment">//通过接口调用静态方法</span></span><br><span class="line">        IFood.feedFood();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="接口名作为形式参数"><a href="#接口名作为形式参数" class="headerlink" title="接口名作为形式参数"></a>接口名作为形式参数</h3><ul>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*接口作为参数的时候我们如何进行调用*/</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Jump</span> &#123;</span><br><span class="line">    <span class="comment">// 跳高接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">()</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JumpImpl</span> <span class="keyword">implements</span> <span class="title class_">Jump</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;jump.............................&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JumpDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Jump jump)</span> &#123;</span><br><span class="line">        jump.jump();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArgsDemo3</span>  &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建JumpDemo对象</span></span><br><span class="line">        <span class="type">JumpDemo</span> <span class="variable">jd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JumpDemo</span>() ;</span><br><span class="line">        <span class="comment">// 2. 调用method方法</span></span><br><span class="line">        <span class="comment">// 对Jump进行间接实例化</span></span><br><span class="line">        <span class="type">Jump</span> <span class="variable">jump</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JumpImpl</span>() ;</span><br><span class="line">        jd.method(jump) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="接口名作为返回值类型"><a href="#接口名作为返回值类型" class="headerlink" title="接口名作为返回值类型"></a>接口名作为返回值类型</h3><ul>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*接口作为返回值类型*/</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Jump</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">()</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JumpImpl</span> <span class="keyword">implements</span> <span class="title class_">Jump</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;jum....................&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JumpDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jump <span class="title function_">getJump</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JumpImpl</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReturnDemo3</span>  &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用getJump方法</span></span><br><span class="line">        <span class="type">Jump</span> <span class="variable">jump</span> <span class="operator">=</span> JumpDemo.getJump() ;</span><br><span class="line">        <span class="comment">// 调用</span></span><br><span class="line">        jump.jump() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h2><ul>
<li><p>相同</p>
<ol>
<li>都是引用数据类型</li>
<li>抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。</li>
<li>都能定义抽象方法</li>
<li>都是 用 子类继承 或 实现类 实现（重写） 来 使用。</li>
</ol>
</li>
<li><p>不同</p>
<ol>
<li>抽象类只能被单继承。</li>
<li>接口的实现类可以实现多个接口的功能</li>
<li>接口之间可以多继承</li>
</ol>
</li>
</ul>
<ol start="4">
<li>接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。</li>
<li>抽象类里可以没有抽象方法。</li>
<li>接口中没有 <code>this</code> 指针，没有构造函数，不能拥有实例字段（实例变量）或实例方法。</li>
<li>抽象类不能在Java 8 的 lambda 表达式中使用。</li>
<li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。</li>
<li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</li>
</ol>
<ul>
<li>二者的理解<ul>
<li>抽象类：为所有子类提供一个模板，半成品。子类在父抽象类的基础上扩展。</li>
<li>接口：提供一组公开的规则。同一个应用程序，接口将各个类（模块）耦合连接，（不使用继承）</li>
<li>接口是对动作的抽象，抽象类是对根源的抽象。从设计理念上，接口反映的是 <strong>“like-a”</strong> 关系，抽象类反映的是 <strong>“is-a”</strong> 关系。</li>
<li>比如鸟有<code>fly（）</code>；<ul>
<li><code>鸵鸟extends 鸟</code>：高耦合，父类有的子类也要有，鸵鸟也能飞，设计不合理</li>
<li>写一个<code>flyInterface</code>接口,提供<code>fly();</code>，如果需要鸵鸟飞就可以实现这个接口。</li>
<li><code>鸵鸟 extends 鸟 implements flyInterface;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="抽象和接口编程角度不同"><a href="#抽象和接口编程角度不同" class="headerlink" title="抽象和接口编程角度不同"></a>抽象和接口编程角度不同</h3><ul>
<li><p>abstract class在Java语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface。也许，这是Java语言的设计者在考虑Java对于多重继承的支持方面的一种折中考虑吧。</p>
</li>
<li><p>其次，在abstract class的定义中，我们可以赋予方法的默认行为。但是在interface的定义中，方法却不能拥有默认行为，不过在JDK1.8中可以使用<code>default</code>关键字实现默认方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceA</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;InterfaceA foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 Java 8 之前，接口与其实现类之间的 <strong>耦合度</strong> 太高了（<strong>tightly coupled</strong>），当需要为一个接口添加方法时，所有的实现类都必须随之修改。默认方法解决了这个问题，它可以为接口添加新的方法，而不会破坏已有的接口的实现。这在 lambda 表达式作为Java 8 语言的重要特性而出现之际，为升级旧接口且保持向后兼容（backward compatibility）提供了途径。</p>
</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li><p>多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，</p>
<ul>
<li>即一个引用变量倒底会指向哪个类的实例对象，</li>
<li>该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</li>
<li>因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</li>
</ul>
</li>
<li><p>简单解释：</p>
<ul>
<li>多态是同一个行为具有多个不同表现形式或形态的能力。</li>
<li>多态就是同一个接口，使用不同的实例而执行不同操作</li>
</ul>
</li>
<li><p>多态实现条件？</p>
<ul>
<li>Java实现多态有三个必要条件：继承、重写、向上转型。</li>
<li>继承：在多态中必须存在有继承关系的子类和父类。</li>
<li>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</li>
<li>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</li>
</ul>
</li>
<li><p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通类多态就是父类的引用变量指向子类对象</span></span><br><span class="line">父类类型 变量名 = <span class="keyword">new</span> 子类类型();</span><br><span class="line">变量名.方法名();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类多态定义格式</span></span><br><span class="line">抽象类 变量名 = <span class="keyword">new</span> 抽象类子类();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口多态定义的格式</span></span><br><span class="line">接口 变量名 = <span class="keyword">new</span> 接口实现类();</span><br></pre></td></tr></table></figure>
</li>
<li><p>多态的运行</p>
<ul>
<li>同一个父类的方法会被不同的子类重写。在调用方法时，调用的为各个子类重写后的方法。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 成员方法：编译看左边 运行看右边</span><br><span class="line">	父类有，子类没有，调用父类</span><br><span class="line">	父类有，子类有，调子类</span><br><span class="line"></span><br><span class="line">2. 成员变量：编译运行都看 左边</span><br><span class="line">	int a = f.num;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="多态的划分情况"><a href="#多态的划分情况" class="headerlink" title="多态的划分情况"></a>多态的划分情况</h3><ul>
<li>多态即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的哪个方法，必须在由程序运行期间才能决定。</li>
<li>要注意，对于面向对象而言，多态分为编译时多态和运行时多态这两个内容。<ul>
<li>其中编译时多态是<strong>静态</strong>的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编译之后会变成两个不同的函数。这个时候，在编译时候已经知道要运行哪个函数了。</li>
<li>而运行时多态（其实就是<strong>动态绑定</strong>）是动态的。他是指在执行期间（而不是编译期间）判断所引用对象的实际类型，并且根据其实际类型调用相应实际使用的方法。我们其实一般习惯上所说的多态，大部分时候都指的是运行时多态。在Java中，有两种形式可以实现多态，继承和接口。</li>
</ul>
</li>
<li>（1）编译时多态<ul>
<li>是通过方法重载实现的。</li>
<li>重载，是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同（就算是在一个继承链上下的类型，也认为是不同的），或许两者都不同）。其实严格来说，重载的概念并不属于“面向对象编程”，</li>
<li>重载的实现是：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。</li>
</ul>
</li>
<li>（2）运行时多态<ul>
<li>是通过覆盖（重写）实现的，也就是override。</li>
<li>覆盖，是指子类重新定义父类的函数。<ul>
<li>方法覆盖需要子类方法和父类方法的名称、参数类型和返回类型都完全一致（其实返回类型不一定要一致，子类的方法返回类型比父类缩小也允许）。</li>
<li>一般可以在子类的覆盖的方法前面加上@override来保证这个方法确实是覆盖。</li>
</ul>
</li>
<li>使用父类引用指向子类对象，再调用某一父类中的方法时，不同子类会表现出不同结果。<ul>
<li>如果通过一个父类的引用来调用某方法，实际上他会对应到内存中真正的对象，他会判断内存中真正的对象是子类对象还是父类对象，然后判断要调用哪个方法。</li>
<li>查找顺序是先在子类中找，有就使用，没有就在父类中找，有就使用，再没有就报错了。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="多态实现方式"><a href="#多态实现方式" class="headerlink" title="多态实现方式"></a>多态实现方式</h3><ul>
<li>多态作用：多态性就是相同的消息使得不同的类做出不同的响应。‘</li>
</ul>
<h4 id="基于继承实现的多态"><a href="#基于继承实现的多态" class="headerlink" title="基于继承实现的多态"></a>基于继承实现的多态</h4><ul>
<li><p>基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多个子类对同一方法的重写可以表现出不同的行为。多态的表现就是不同的对象可以执行相同的行为，但是他们都需要通过自己的实现方式来执行，这就要得益于向上转型了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainJava</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义父类数组</span></span><br><span class="line">        Wine[] wines = <span class="keyword">new</span> <span class="title class_">Wine</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//定义两个子类</span></span><br><span class="line">        <span class="type">Test1</span> <span class="variable">test1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test1</span>();</span><br><span class="line">        <span class="type">Test2</span> <span class="variable">test2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test2</span>();</span><br><span class="line">        Wine <span class="type">win</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Wine</span>();</span><br><span class="line">        <span class="comment">//父类引用子类对象</span></span><br><span class="line">        wines[<span class="number">0</span>] = test1;</span><br><span class="line">        wines[<span class="number">1</span>] = test2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">2</span> ; i++)&#123;</span><br><span class="line">            System.out.println(wines[i].toString() + <span class="string">&quot;--&quot;</span> + wines[i].drink());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------&quot;</span>);</span><br><span class="line">        System.out.println(test1.toString() + <span class="string">&quot;--&quot;</span> + test1.drink());</span><br><span class="line">        System.out.println(test2.toString() + <span class="string">&quot;--&quot;</span> + test2.drink());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Wine</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">drink</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;喝的是 &quot;</span> + getName();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test1</span> <span class="keyword">extends</span> <span class="title class_">Wine</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Test1</span><span class="params">()</span>&#123;</span><br><span class="line">            setName(<span class="string">&quot;Test1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">drink</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;喝的是 &quot;</span> + getName();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Wine : &quot;</span> + getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test2</span> <span class="keyword">extends</span> <span class="title class_">Wine</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Test2</span><span class="params">()</span>&#123;</span><br><span class="line">            setName(<span class="string">&quot;Test2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">drink</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;喝的是 &quot;</span> + getName();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Wine : &quot;</span> + getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="基于接口实现的多态"><a href="#基于接口实现的多态" class="headerlink" title="基于接口实现的多态"></a>基于接口实现的多态</h4><ul>
<li>继承是通过重写父类的同一方法的几个不同子类来体现的，那么就可就是通过实现接口并覆盖接口中同一方法的几不同的类体现的。</li>
<li>在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。</li>
<li>继承都是单继承，只能为一组相关的类提供一致的服务接口。但是接口可以是多继承多实现，它能够利用一组相关或者不相关的接口进行组合与扩充，能够对外提供一致的服务接口。所以它相对于继承来说有更好的灵活性。</li>
</ul>
<h3 id="多态中的类型转换"><a href="#多态中的类型转换" class="headerlink" title="多态中的类型转换"></a>多态中的类型转换</h3><ul>
<li><p>子类转父类: 向上类型转换</p>
</li>
<li><p>向下类型转换：一个已经向上转型的子类对象可以使用强制类型转换的格式，将父类引用转为子类引用，这个过程是向下转型。</p>
<ul>
<li>需要强制转换</li>
<li>如果是直接创建父类对象，是无法向下转型的！</li>
<li>注意类型不匹配:java.lang.ClassCastException</li>
<li><code> 子类类型 变量名 = (子类类型) 父类类型的变量;</code></li>
</ul>
</li>
</ul>
<h3 id="关键字-instanceof"><a href="#关键字-instanceof" class="headerlink" title="关键字:instanceof"></a>关键字:instanceof</h3><ul>
<li><p>可以通过instanceof关键字来判断某个对象是否属于某种数据类型。</p>
</li>
<li><p>如学生的对象属于学生类，学生的对象也属于人类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> pet <span class="keyword">instanceof</span> Cat<span class="comment">//判断传递的pet对象是不是Cat类类型</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul>
<li><p>定义一个宠物类，宠物有名字和吃的动作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Pet</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;吃东西&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写二个子类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;吃骨头&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;小狗跑了&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">=======================================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;吃鱼&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;小猫去玩儿了&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试多态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHospatil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PetHospatil</span> <span class="variable">hos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PetHospatil</span>();</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">wangwang</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;旺旺&quot;</span>);</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">xiaohua</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;小花&quot;</span>);</span><br><span class="line">        <span class="comment">//Pet pet = wangwang; 向上类型转换</span></span><br><span class="line">        hos.treatment(wangwang);</span><br><span class="line">        hos.treatment(xiaohua);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =======宠物医院==============================</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PetHospatil</span> &#123;</span><br><span class="line">    <span class="comment">// 类与类依赖关系</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">treatment</span><span class="params">(Pet pet)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;给&quot;</span> + pet.getName() + <span class="string">&quot;看病&quot;</span>);</span><br><span class="line">        pet.eat();</span><br><span class="line">        <span class="comment">// 向下类型转换：对类型进行判断</span></span><br><span class="line">        <span class="keyword">if</span> (pet <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">            <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) pet;</span><br><span class="line">            dog.run();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pet <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">            <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat) pet;</span><br><span class="line">            cat.play();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://fulsun.github.io">凉月</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://fulsun.github.io/p/db572cd7">https://fulsun.github.io/p/db572cd7</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://fulsun.github.io" target="_blank">凉月の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/medias/featureimages/006.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/42e10e0d" title="final,深浅拷贝,类的关系，正则和常用类"><img class="cover" src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/012.jpg" onerror="onerror=null;src='/medias/detail/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">final,深浅拷贝,类的关系，正则和常用类</div></div></a></div><div class="next-post pull-right"><a href="/p/5a30c1e7" title="Java的导包，封装,构造器,代码块,类权限修饰符,static"><img class="cover" src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/001.jpg" onerror="onerror=null;src='/medias/detail/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java的导包，封装,构造器,代码块,类权限修饰符,static</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/avatar.jpg" onerror="this.onerror=null;this.src='/medias/detail/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">凉月</div><div class="author-info__description">记录生活,分享知识。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/fulsun"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/fulsun" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:fl_6145@163.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">感谢访问本站，若喜欢请收藏 ^_^</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#paivate%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">paivate关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-text">懒汉式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="toc-text">饿汉式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%80%85%E5%8C%BA%E5%88%AB"><span class="toc-text">二者区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-text">抽象方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%90%8D%E4%BD%9C%E4%B8%BA%E5%BD%A2%E5%8F%82"><span class="toc-text">抽象类名作为形参</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getGenericSuperclass"><span class="toc-text">getGenericSuperclass</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-text">方法重写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">重写注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E8%83%BD%E5%90%A6%E8%A2%AB%E5%AD%90%E7%B1%BB%E9%87%8D%E5%86%99"><span class="toc-text">父类的静态方法能否被子类重写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-text">注意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F"><span class="toc-text">格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-text">接口的多继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A4%9A%E5%AE%9E%E7%8E%B0"><span class="toc-text">接口的多实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%90%8D%E4%BD%9C%E4%B8%BA%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0"><span class="toc-text">接口名作为形式参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%90%8D%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-text">接口名作为返回值类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">接口和抽象类的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B%E8%A7%92%E5%BA%A6%E4%B8%8D%E5%90%8C"><span class="toc-text">抽象和接口编程角度不同</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%88%92%E5%88%86%E6%83%85%E5%86%B5"><span class="toc-text">多态的划分情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">多态实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%A4%9A%E6%80%81"><span class="toc-text">基于继承实现的多态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%A4%9A%E6%80%81"><span class="toc-text">基于接口实现的多态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">多态中的类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97-instanceof"><span class="toc-text">关键字:instanceof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-text">示例</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/p/94e3914c" title="Import 注册组件"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/008.jpg" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Import 注册组件"/></a><div class="content"><a class="title" href="/p/94e3914c" title="Import 注册组件">Import 注册组件</a><time datetime="2024-07-15T22:24:08.000Z" title="发表于 2024-07-15 22:24:08">2024-07-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/a0c53761" title="Configuration Bean 注册组件"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/012.jpg" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Configuration Bean 注册组件"/></a><div class="content"><a class="title" href="/p/a0c53761" title="Configuration Bean 注册组件">Configuration Bean 注册组件</a><time datetime="2024-07-15T21:24:08.000Z" title="发表于 2024-07-15 21:24:08">2024-07-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/65826306" title="Spring5新功能"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/008.jpg" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Spring5新功能"/></a><div class="content"><a class="title" href="/p/65826306" title="Spring5新功能">Spring5新功能</a><time datetime="2024-07-14T17:24:08.000Z" title="发表于 2024-07-14 17:24:08">2024-07-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/40bb048a" title="JdbcTemplate与声明式事务"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/013.jpg" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="JdbcTemplate与声明式事务"/></a><div class="content"><a class="title" href="/p/40bb048a" title="JdbcTemplate与声明式事务">JdbcTemplate与声明式事务</a><time datetime="2024-07-14T11:24:08.000Z" title="发表于 2024-07-14 11:24:08">2024-07-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/92933cdb" title="Spring-AOP编程"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/012.jpg" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Spring-AOP编程"/></a><div class="content"><a class="title" href="/p/92933cdb" title="Spring-AOP编程">Spring-AOP编程</a><time datetime="2024-07-14T09:24:38.000Z" title="发表于 2024-07-14 09:24:38">2024-07-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 凉月</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://unpkg.com/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.js"></script><script src="https://unpkg.com/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null

  const initWaline = (Fn) => {
    const waline = Fn(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-fulsun.netlify.app/.netlify/functions/comment',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))

    const destroyWaline = () => {
      waline.destroy()
    }

    btf.addGlobalFn('pjax', destroyWaline, 'destroyWaline')
  }

  const loadWaline = async () => {
    if (initFn) initWaline(initFn)
    else {
      await getCSS('https://unpkg.com/@waline/client@3.1.2/dist/waline.css')
      const { init } = await import('https://unpkg.com/@waline/client@3.1.2/dist/waline.js')
      initFn = init || Waline.init
      initWaline(initFn)
      window.walineFn = initFn
    }
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://unpkg.com/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>