<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Map集合 | 凉月の博客</title><meta name="author" content="凉月"><meta name="copyright" content="凉月"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java面向对象">
<meta property="og:type" content="article">
<meta property="og:title" content="Map集合">
<meta property="og:url" content="https://fulsun.github.io/p/5b59a61f">
<meta property="og:site_name" content="凉月の博客">
<meta property="og:description" content="Java面向对象">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fulsun.github.io/medias/featureimages/007.jpg">
<meta property="article:published_time" content="2018-08-18T02:08:28.000Z">
<meta property="article:modified_time" content="2024-10-17T07:06:55.358Z">
<meta property="article:author" content="凉月">
<meta property="article:tag" content="凉月">
<meta property="article:tag" content="凉月文">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="web网站">
<meta property="article:tag" content="经验分享">
<meta property="article:tag" content="hexo">
<meta property="article:tag" content="个人博客">
<meta property="article:tag" content="生活记录等">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fulsun.github.io/medias/featureimages/007.jpg"><link rel="shortcut icon" href="/medias/favicon.png"><link rel="canonical" href="https://fulsun.github.io/p/5b59a61f"><link rel="preconnect" href="//unpkg.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"至上次更新后的","messageNext":"天,文章内容可能已过时。"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 凉月","link":"链接: ","source":"来源: 凉月の博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://unpkg.com/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Map集合',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-17 07:06:55'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/avatar.jpg" onerror="onerror=null;src='/medias/detail/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-heartbeat"></i><span> 我的</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> 联系</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user-circle"></i><span> 博主</span></a></li><li><a class="site-page child" href="/contact"><i class="fa-fw fas fa-comments"></i><span> 留言</span></a></li><li><a class="site-page child" href="/journal"><i class="fa-fw fas fa-cogs"></i><span> 日志</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> JS动画</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/snake/"><i class="fa-fw fas fa-gamepad"></i><span> 贪吃蛇</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/medias/featureimages/007.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="凉月の博客"><span class="site-name">凉月の博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-heartbeat"></i><span> 我的</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> 联系</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user-circle"></i><span> 博主</span></a></li><li><a class="site-page child" href="/contact"><i class="fa-fw fas fa-comments"></i><span> 留言</span></a></li><li><a class="site-page child" href="/journal"><i class="fa-fw fas fa-cogs"></i><span> 日志</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> JS动画</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/snake/"><i class="fa-fw fas fa-gamepad"></i><span> 贪吃蛇</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Map集合</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2018-08-18T02:08:28.000Z" title="发表于 2018-08-18 02:08:28">2018-08-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-17T07:06:55.358Z" title="更新于 2024-10-17 07:06:55">2024-10-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JavaSE/">JavaSE</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">23.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>94分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Map集合"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><span id="more"></span>

<h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li><p><strong>Map集合从何而来</strong></p>
</li>
<li><p>我们通过什么东西来标识我们的学生在班级的唯一性. 我们都每一个学生应该存在一个学号 , 而这个学号是唯一的。那么我们就可以通过这个学号来表示我们学生在班级的唯一性。那么也就说,我们的学号和学生的姓名之间应该存在一个对应关系吧</p>
</li>
<li><p>那么我们怎么存储这样对应关系的数据呢? 针对这个情况java就给我们提供了另外一种集合进行表示,而这个集合就是Map 。Map集合结构是由两列组成,第一列被称之为键 , 第二例被称之为值 ; 并且我们都知道键应该是唯一的,而对值没有要求。</p>
</li>
<li><p><strong>Map接口和Collection接口的区别</strong></p>
<ul>
<li>Map是双列的,Collection是单列的</li>
<li>Map的键唯一,Collection的子体系Set是唯一的</li>
<li>Map集合的数据结构值针对键有效，跟值无关</li>
<li>Collection集合的数据结构是针对元素有效</li>
</ul>
</li>
<li><p><strong>Map集合的特点</strong></p>
<ul>
<li>将键映射到值的对象</li>
<li>一个映射不能包含重复的键</li>
<li>每个键最多只能映射到一个值</li>
</ul>
</li>
</ul>
<h2 id="Map集合整体结构"><a href="#Map集合整体结构" class="headerlink" title="Map集合整体结构"></a>Map集合整体结构</h2><ul>
<li>HashMap 等其他 Map 实现则是都扩展了AbstractMap，里面包含了通用方法抽象。不同 Map的用途，从类图结构就能体现出来，设计目的已经体现在不同接口上。</li>
<li>Hashtable 比较特别，作为类似 Vector、Stack 的早期集合相关类型，它是扩展了 Dictionary 类的，类结构上与 HashMap 之类明显不同。</li>
<li>大部分使用 Map 的场景，通常就是放入、访问或者删除，而对顺序没有特别要求，HashMap 在这种情况下基本是最好的选择。HashMap的性能表现非常依赖于哈希码的有效性，请务必掌握hashCode 和 equals 的一些基本约定，比如：<ul>
<li>equals 相等，hashCode 一定要相等。</li>
<li>重写了 hashCode 也要重写 equals。</li>
<li>hashCode 需要保持一致性，状态改变返回的哈希值仍然要一致。</li>
<li>equals 的对称、反射、传递等特性。</li>
</ul>
</li>
</ul>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/5b59a61f/5ae05a98e465f897996fbc6782626956.png"></p>
<h2 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1:添加功能</span><br><span class="line">    V put(K key,V value):添加元素。</span><br><span class="line">    如果键是第一次存储，就直接存储元素，返回null</span><br><span class="line">    如果键不是第一次存在，就用值把以前的值替换掉，返回以前的值</span><br><span class="line">2:删除功能</span><br><span class="line">	void clear():移除所有的键值对元素</span><br><span class="line">	V remove(Object key)：根据键删除键值对元素，并把值返回</span><br><span class="line">3:判断功能</span><br><span class="line">	boolean containsKey(Object key)：判断集合是否包含指定的键</span><br><span class="line">	boolean containsValue(Object value):判断集合是否包含指定的值</span><br><span class="line">	boolean isEmpty()：判断集合是否为空</span><br><span class="line">4:获取功能</span><br><span class="line">	Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet():返回的是键值对对象的集合</span><br><span class="line">	V get(Object key):根据键获取值</span><br><span class="line">	Set&lt;K&gt; keySet():获取集合中所有键的集合</span><br><span class="line">	Collection&lt;V&gt; values():获取集合中所有值的集合</span><br><span class="line">5：长度功能</span><br><span class="line">	int size()：返回集合中的键值对的对数</span><br></pre></td></tr></table></figure>

<ul>
<li><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建集合对象</span></span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">System.out.println(<span class="string">&quot;put:&quot;</span> + map.put(<span class="string">&quot;0001&quot;</span>, <span class="string">&quot;麓殇&quot;</span>));		<span class="comment">//put:null</span></span><br><span class="line">System.out.println(<span class="string">&quot;put:&quot;</span> + map.put(<span class="string">&quot;0001&quot;</span>, <span class="string">&quot;旧青画&quot;</span>));		<span class="comment">//put:麓殇</span></span><br><span class="line">System.out.println(<span class="string">&quot;put:&quot;</span> + map.put(<span class="string">&quot;0002&quot;</span>, <span class="string">&quot;蓝奕世&quot;</span>));		<span class="comment">// put:null</span></span><br><span class="line">System.out.println(<span class="string">&quot;put:&quot;</span> + map.put(<span class="string">&quot;0003&quot;</span>, <span class="string">&quot;不可言&quot;</span>));		<span class="comment">// put:null</span></span><br><span class="line">System.out.println(<span class="string">&quot;put:&quot;</span> + map.put(<span class="string">&quot;0004&quot;</span>, <span class="string">&quot;苏莫晨&quot;</span>));		<span class="comment">// put:null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void clear():移除所有的键值对元素</span></span><br><span class="line">map.clear();</span><br><span class="line">System.out.println(<span class="string">&quot;size:&quot;</span>+map.size());		<span class="comment">//size:0</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;remove:&quot;</span> + map.remove(<span class="string">&quot;0001&quot;</span>));	<span class="comment">//remove:旧青画</span></span><br><span class="line">System.out.println(<span class="string">&quot;remove:&quot;</span> + map.remove(<span class="string">&quot;0005&quot;</span>));	<span class="comment">//remove:null</span></span><br><span class="line">System.out.println(<span class="string">&quot;map:&quot;</span> + map);		<span class="comment">//map:&#123;0004=苏莫晨, 0002=蓝奕世, 0003=不可言&#125;</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;isEmpty:&quot;</span>+map.isEmpty());		<span class="comment">//isEmpty:false</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;containsKey:&quot;</span> + map.containsKey(<span class="string">&quot;0004&quot;</span>));	<span class="comment">//containsKey:true</span></span><br><span class="line">System.out.println(<span class="string">&quot;containsKey:&quot;</span> + map.containsKey(<span class="string">&quot;0005&quot;</span>));	<span class="comment">//containsKey:false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取功能</span></span><br><span class="line"><span class="comment">// V get(Object key):根据键获取值</span></span><br><span class="line">System.out.println(<span class="string">&quot;get:&quot;</span> + map.get(<span class="string">&quot;0001&quot;</span>));	<span class="comment">//旧青画</span></span><br><span class="line">System.out.println(<span class="string">&quot;get:&quot;</span> + map.get(<span class="string">&quot;周杰&quot;</span>)); 	<span class="comment">// 返回null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set&lt;K&gt; keySet():获取集合中所有键的集合</span></span><br><span class="line">Set&lt;String&gt; set = map.keySet();</span><br><span class="line"><span class="keyword">for</span> (String key : set) &#123;</span><br><span class="line">	System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line">结果:</span><br><span class="line">	<span class="number">0004</span></span><br><span class="line">	<span class="number">0002</span></span><br><span class="line">	<span class="number">0003</span></span><br><span class="line">	<span class="number">0001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Collection&lt;V&gt; values():获取集合中所有值的集合</span></span><br><span class="line">Collection&lt;String&gt; con = map.values();</span><br><span class="line"><span class="keyword">for</span> (String value : con) &#123;</span><br><span class="line">	System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line">结果:</span><br><span class="line">	苏莫晨</span><br><span class="line">	蓝奕世</span><br><span class="line">	不可言</span><br><span class="line">	旧青画</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Map集合遍历"><a href="#Map集合遍历" class="headerlink" title="Map集合遍历"></a>Map集合遍历</h2><h3 id="根据键找值"><a href="#根据键找值" class="headerlink" title="根据键找值"></a>根据键找值</h3><ul>
<li><p>1: 获取所有的键对应的Set集合 ；2: 遍历Set获取每一个键 , 根据键找出对应的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">	A:把所有的丈夫给集中起来。</span><br><span class="line">	B:遍历丈夫的集合，获取得到每一个丈夫。</span><br><span class="line">	C:让丈夫去找自己的妻子。</span><br><span class="line">转换：</span><br><span class="line">	A:获取所有的键 keySet()</span><br><span class="line">	B:遍历键的集合，获取得到每一个键</span><br><span class="line">	C:根据键去找值</span><br></pre></td></tr></table></figure>


</li>
<li><p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建集合对象</span></span><br><span class="line">		Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建元素并添加到集合</span></span><br><span class="line">		map.put(<span class="string">&quot;杨过&quot;</span>, <span class="string">&quot;小龙女&quot;</span>);</span><br><span class="line">		map.put(<span class="string">&quot;郭靖&quot;</span>, <span class="string">&quot;黄蓉&quot;</span>);</span><br><span class="line">		map.put(<span class="string">&quot;杨康&quot;</span>, <span class="string">&quot;穆念慈&quot;</span>);</span><br><span class="line">		map.put(<span class="string">&quot;陈玄风&quot;</span>, <span class="string">&quot;梅超风&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 遍历</span></span><br><span class="line">		<span class="comment">// 获取所有的键</span></span><br><span class="line">		Set&lt;String&gt; set = map.keySet();</span><br><span class="line">		<span class="comment">// 遍历键的集合，获取得到每一个键</span></span><br><span class="line">		<span class="keyword">for</span> (String key : set) &#123;</span><br><span class="line">			<span class="comment">// 根据键去找值</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">			System.out.println(key + <span class="string">&quot;---&quot;</span> + value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="遍历根据键值对对象"><a href="#遍历根据键值对对象" class="headerlink" title="遍历根据键值对对象"></a>遍历根据键值对对象</h3><ul>
<li><p>遍历键值对对象，根据键值对对象获取键和值</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">	A:获取所有结婚证的集合</span><br><span class="line">	B:遍历结婚证的集合，得到每一个结婚证</span><br><span class="line">	C:根据结婚证获取丈夫和妻子</span><br><span class="line"></span><br><span class="line">转换：</span><br><span class="line">	A:获取所有键值对对象的Set集合 Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</span><br><span class="line">	B:遍历键值对对象的集合，得到每一个键值对对象</span><br><span class="line">	C:根据键值对对象获取键和值</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建集合对象</span></span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建元素并添加到集合</span></span><br><span class="line">map.put(<span class="string">&quot;杨过&quot;</span>, <span class="string">&quot;小龙女&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;郭靖&quot;</span>, <span class="string">&quot;黄蓉&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;杨康&quot;</span>, <span class="string">&quot;穆念慈&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;陈玄风&quot;</span>, <span class="string">&quot;梅超风&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有键值对对象的集合</span></span><br><span class="line">Set&lt;Map.Entry&lt;String, String&gt;&gt; set = map.entrySet();</span><br><span class="line"><span class="comment">// 遍历键值对对象的集合，得到每一个键值对对象</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; me : set) &#123;</span><br><span class="line">	<span class="comment">// 根据键值对对象获取键和值</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> me.getKey();</span><br><span class="line">	<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> me.getValue();</span><br><span class="line">	System.out.println(key + <span class="string">&quot;---&quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ul>
<li><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二种方式，使用迭代器</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    Map.Entry&lt;String, Integer&gt; next = iterator.next();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> next.getKey();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> next.getValue();</span><br><span class="line">    System.out.println(key + <span class="string">&quot;: &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    Map.Entry&lt;String, Integer&gt; next = iterator.next();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> next.getKey();</span><br><span class="line">    <span class="comment">//通过key找键，效率相比比较低</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">    System.out.println(key + <span class="string">&quot;: &quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><p>Hash table based <strong>implementation of the Map interface</strong>. This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it is<strong>unsynchronized</strong>and<strong>permits nulls</strong>.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time.</p>
</li>
<li><p>键是哈希表结构，可以保证键的唯一性</p>
</li>
<li><p>基于Map接口实现、允许null键&#x2F;值、是非同步(这点很重要，多线程注意)、不保证有序(比如插入的顺序)、也不保证序不随时间变化。</p>
<ul>
<li><p>允许插入最多一条<code>key</code>为<code>null</code>的记录，允许插入多条<code>value</code>为<code>null</code>的记录。</p>
</li>
<li><p>HashMap 不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此在不同时间段迭代同一个 HashMap 的顺序可能会不同。</p>
</li>
<li><p>HashMap 非线程安全，即任一时刻有多个线程同时写 HashMap 的话可能会导致数据的不一致</p>
</li>
</ul>
</li>
</ul>
<h3 id="HashMap-1"><a href="#HashMap-1" class="headerlink" title="HashMap&lt;String,String&gt;"></a>HashMap&lt;String,String&gt;</h3><ul>
<li><p>需求: 使用HashMap存储元素,键是String类型, 值也是String类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建集合对象</span></span><br><span class="line">HashMap&lt;String, String&gt; hm = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建元素并添加元素</span></span><br><span class="line"><span class="comment">// String key1 = &quot;001&quot;;</span></span><br><span class="line"><span class="comment">// String value1 = &quot;欧展鹏&quot;;</span></span><br><span class="line"></span><br><span class="line">hm.put(<span class="string">&quot;001&quot;</span>, <span class="string">&quot;欧展鹏&quot;</span>);</span><br><span class="line">hm.put(<span class="string">&quot;002&quot;</span>, <span class="string">&quot;嘉澜&quot;</span>);</span><br><span class="line">hm.put(<span class="string">&quot;002&quot;</span>, <span class="string">&quot;嘉澜&quot;</span>);</span><br><span class="line">hm.put(<span class="string">&quot;003&quot;</span>, <span class="string">&quot;丘黎&quot;</span>);</span><br><span class="line">hm.put(<span class="string">&quot;004&quot;</span>, <span class="string">&quot;如空月&quot;</span>);</span><br><span class="line">hm.put(<span class="string">&quot;005&quot;</span>, <span class="string">&quot;言思晴&quot;</span>);</span><br><span class="line">hm.put(<span class="string">&quot;001&quot;</span>, <span class="string">&quot;东方不败&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line">Set&lt;String&gt; set = hm.keySet();</span><br><span class="line"><span class="keyword">for</span> (String key : set) &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> hm.get(key);</span><br><span class="line">	System.out.println(key + <span class="string">&quot;---&quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line">结果:</span><br><span class="line">	<span class="number">001</span>---欧展鹏</span><br><span class="line">	<span class="number">002</span>---嘉澜</span><br><span class="line">	<span class="number">003</span>---丘黎</span><br><span class="line">	<span class="number">004</span>---如空月</span><br><span class="line">	<span class="number">005</span>---东方不败</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="HashMap-2"><a href="#HashMap-2" class="headerlink" title="HashMap&lt;Integer,String&gt;"></a>HashMap&lt;Integer,String&gt;</h3><ul>
<li><p>使用HashMap存储元素,键是String类型 ,值是Student类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建集合对象</span></span><br><span class="line">HashMap&lt;Integer, String&gt; hm = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建元素并添加元素</span></span><br><span class="line"><span class="comment">// Integer i = new Integer(27);</span></span><br><span class="line"><span class="comment">// Integer i = 27;</span></span><br><span class="line"><span class="comment">// String s = &quot;欧展鹏&quot;;</span></span><br><span class="line"><span class="comment">// hm.put(i, s);</span></span><br><span class="line"></span><br><span class="line">hm.put(<span class="number">27</span>, <span class="string">&quot;欧展鹏&quot;</span>);</span><br><span class="line">hm.put(<span class="number">30</span>, <span class="string">&quot;丘黎&quot;</span>);</span><br><span class="line">hm.put(<span class="number">28</span>, <span class="string">&quot;如空月&quot;</span>);</span><br><span class="line">hm.put(<span class="number">29</span>, <span class="string">&quot;嘉澜&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的写法是八进制，但是不能出现8以上的单个数据</span></span><br><span class="line"><span class="comment">// hm.put(003, &quot;hello&quot;);</span></span><br><span class="line"><span class="comment">// hm.put(006, &quot;hello&quot;);</span></span><br><span class="line"><span class="comment">// hm.put(007, &quot;hello&quot;);</span></span><br><span class="line"><span class="comment">// hm.put(008, &quot;hello&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历:获取所有的键值对对象对应的Set集合</span></span><br><span class="line">Set&lt;Integer&gt; set = hm.keySet();</span><br><span class="line"><span class="keyword">for</span> (Integer key : set) &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> hm.get(key);</span><br><span class="line">	System.out.println(key + <span class="string">&quot;---&quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这种方式仅仅是集合的元素的字符串表示</span></span><br><span class="line"><span class="comment">// System.out.println(&quot;hm:&quot; + hm);</span></span><br><span class="line">&#125;</span><br><span class="line">结果:</span><br><span class="line">	<span class="number">27</span>---欧展鹏</span><br><span class="line">	<span class="number">28</span>---如空月</span><br><span class="line">	<span class="number">29</span>---嘉澜</span><br><span class="line">	<span class="number">30</span>---丘黎</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="HashMap-3"><a href="#HashMap-3" class="headerlink" title="HashMap&lt;String,Student&gt;"></a>HashMap&lt;String,Student&gt;</h3><ul>
<li><p>使用HashMap存储元素,键是String类型 ,值是Student类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建集合对象</span></span><br><span class="line">HashMap&lt;String, Student&gt; hm = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Student&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建学生对象</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;欧展鹏&quot;</span>, <span class="number">58</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;如空月&quot;</span>, <span class="number">55</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;迦南&quot;</span>, <span class="number">54</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;球溪&quot;</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">hm.put(<span class="string">&quot;9527&quot;</span>, s1);</span><br><span class="line">hm.put(<span class="string">&quot;9522&quot;</span>, s2);</span><br><span class="line">hm.put(<span class="string">&quot;9524&quot;</span>, s3);</span><br><span class="line">hm.put(<span class="string">&quot;9529&quot;</span>, s4);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line">Set&lt;String&gt; set = hm.keySet();</span><br><span class="line"><span class="keyword">for</span> (String key : set) &#123;</span><br><span class="line">	<span class="comment">// 注意了：这次值不是字符串了</span></span><br><span class="line">	<span class="comment">// String value = hm.get(key);</span></span><br><span class="line">	<span class="type">Student</span> <span class="variable">value</span> <span class="operator">=</span> hm.get(key);</span><br><span class="line">	System.out.println(key + <span class="string">&quot;---&quot;</span> + value.getName() + <span class="string">&quot;---&quot;</span></span><br><span class="line">			+ value.getAge());</span><br><span class="line">&#125;</span><br><span class="line">结果:</span><br><span class="line">	<span class="number">9524</span>---迦南---<span class="number">54</span></span><br><span class="line">	<span class="number">9522</span>---如空月---<span class="number">55</span></span><br><span class="line">	<span class="number">9529</span>---球溪---<span class="number">50</span></span><br><span class="line">	<span class="number">9527</span>---欧展鹏---<span class="number">58</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="HashMap-4"><a href="#HashMap-4" class="headerlink" title="HashMap&lt;Student,String&gt;"></a>HashMap&lt;Student,String&gt;</h3><ul>
<li><p>使用HashMap存储元素,键是Student类型 , 值是String类型</p>
</li>
<li><p>如果两个对象的成员变量值是相同的,那么我们认为就是同一个对象,如果是同一个对象就不能添加到HashMap集合中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建集合对象</span></span><br><span class="line">HashMap&lt;Student, String&gt; hm = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Student, String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建学生对象</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;貂蝉&quot;</span>, <span class="number">27</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王昭君&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;西施&quot;</span>, <span class="number">33</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;杨玉环&quot;</span>, <span class="number">35</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;貂蝉&quot;</span>, <span class="number">27</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">hm.put(s1, <span class="string">&quot;8888&quot;</span>);</span><br><span class="line">hm.put(s2, <span class="string">&quot;6666&quot;</span>);</span><br><span class="line">hm.put(s3, <span class="string">&quot;5555&quot;</span>);</span><br><span class="line">hm.put(s4, <span class="string">&quot;7777&quot;</span>);</span><br><span class="line">hm.put(s5, <span class="string">&quot;9999&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line">Set&lt;Student&gt; set = hm.keySet();</span><br><span class="line"><span class="keyword">for</span> (Student key : set) &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> hm.get(key);</span><br><span class="line">	System.out.println(key.getName() + <span class="string">&quot;---&quot;</span> + key.getAge() + <span class="string">&quot;---&quot;</span></span><br><span class="line">			+ value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要求：如果两个对象的成员变量值都相同，则为同一个对象。</span></span><br><span class="line"><span class="comment">//哈希表作用是用来保证键的唯一性的。</span></span><br><span class="line"><span class="comment">//需要重写hashCode()和equals()方法</span></span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line">	王昭君---<span class="number">30</span>---<span class="number">6666</span></span><br><span class="line">	貂蝉---<span class="number">27</span>---<span class="number">9999</span></span><br><span class="line">	杨玉环---<span class="number">35</span>---<span class="number">7777</span></span><br><span class="line">	西施---<span class="number">33</span>---<span class="number">5555</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="HashMap原理"><a href="#HashMap原理" class="headerlink" title="HashMap原理"></a>HashMap原理</h2><ul>
<li>HashMap基于哈希思想，实现对数据的读写。<ul>
<li>put存储对象时，我们将K&#x2F;V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过<code>Load Facotr</code>则resize为原来的2倍)。</li>
<li>get获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。</li>
</ul>
</li>
<li>HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。<ul>
<li>如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。</li>
</ul>
</li>
</ul>
<h3 id="HashMap内部结构"><a href="#HashMap内部结构" class="headerlink" title="HashMap内部结构"></a>HashMap内部结构</h3><ul>
<li><p>HashMap 内部的结构，它可以看作是数组（Node[] table）和链表结合组成的复合结构，数组被分为一个个桶（bucket），通过哈希值决定了键值对在这个数组的寻址；哈希值相同的键值对，则以链表形式存储，你可以参考下面的示意图。</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/5b59a61f/12975148e69cf51e323c02174a59910e.png"></p>
</li>
<li><p>这里需要注意的是，如果链表大小超过阈值（TREEIFY_THRESHOLD, 8，图中的链表就会被改造为树形结构。</p>
</li>
</ul>
<h3 id="HashMap底层实现"><a href="#HashMap底层实现" class="headerlink" title="HashMap底层实现"></a>HashMap底层实现</h3><ul>
<li>底层是用什么实现的？<ul>
<li>HashMap 实际上是<strong>数组+链表+红黑树</strong>的结合体……</li>
</ul>
</li>
<li>为什么要使用链表？<ul>
<li>当发生碰撞了，对象将会储存在链表的下一个节点中</li>
</ul>
</li>
<li>为什么要使用红黑树？<ul>
<li>JDK1.8 开始 HashMap 通过使用红黑树来提高元素查找效率</li>
</ul>
</li>
</ul>
<h3 id="HashMap构造函数"><a href="#HashMap构造函数" class="headerlink" title="HashMap构造函数"></a>HashMap构造函数</h3><ul>
<li><p>HashMap构造函数如下所示</p>
<ul>
<li>默认装载因子0.75</li>
<li>数组的扩容临界点：当前容量 x 装载因子</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment"> * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><ul>
<li><p>成员变量如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希桶数组，在第一次使用时才初始化</span></span><br><span class="line"><span class="comment">//容量值应是2的整数倍</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K, V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment"> * for keySet() and values().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Map的大小</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每当Map的结构发生变化时，此参数就会递增</span></span><br><span class="line"><span class="comment">//当在对Map进行迭代操作时，迭代器会检查此参数值</span></span><br><span class="line"><span class="comment">//如果检查到此参数的值发生变化，就说明在迭代的过程中Map的结构发生了变化，因此会直接抛出异常</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组的扩容临界点，当数组的数据量达到这个值时就会进行扩容操作</span></span><br><span class="line"><span class="comment">//计算方法：当前容量 x 装载因子</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用的装载因子值</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put(K key, V value)"></a>put(K key, V value)</h3><ul>
<li><p>put函数大致的思路为：</p>
<ol>
<li>对key的hashCode()做hash，然后再计算index;<ul>
<li>putVal()方法的部分源码，可以看出，向集合中添加元素时，会使用(n - 1) &amp; hash的计算方法来得出该元素在集合中的位置</li>
<li>其中n是集合的容量，hash是添加的元素进过hash函数计算出来的hash值。</li>
</ul>
</li>
<li>如果没碰撞直接放到bucket里；</li>
<li>如果碰撞了，以链表的形式存在buckets后；</li>
<li>如果碰撞导致链表过长(大于等于<code>TREEIFY_THRESHOLD</code>(树阈))，就把链表转换成红黑树；</li>
<li>如果节点已经存在就替换old value(保证key的唯一性)</li>
<li>如果bucket满了(超过<code>load factor*current capacity</code>)，就要resize。</li>
</ol>
</li>
<li><p>put源码如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// tab为空则创建</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 计算index，并对null做处理</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 节点存在</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 该链为树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 该链为链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 写入</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 超过load factor*current capacity，resize</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>put源码解析大概如下所示</p>
<ul>
<li>如果表格是 null，resize 方法会负责初始化它，这从 tab &#x3D; resize() 可以看出。</li>
<li>resize 方法兼顾两个职责，创建初始存储表格，或者在容量不满足需求的时候，进行扩容（resize）。</li>
<li>在放置新的键值对的过程中，如果发生if (++size &gt; threshold)条件，就会发生扩容。</li>
<li>具体键值对在哈希表中的位置（数组 index）取决于下面的位运算：i &#x3D; (n - 1) &amp; hash</li>
<li>仔细观察哈希值的源头，我们会发现，它并不是 key 本身的hashCode，而是来自于 HashMap 内部的另外一个 hash 方法。注意，为什么这里需要将高位数据移位到低位进行异或运算呢？这是因为有些数据计算出的哈希值差异主要在高位，而 HashMap 里的哈希寻址是忽略容量以上的高位的，那么这种处理就可以有效避免类似情况下的哈希碰撞。</li>
</ul>
</li>
<li><p>当有键值对插入时，HashMap会发生什么 ?</p>
<ul>
<li>首先，键的哈希值被计算出来，然后这个值会赋给 Entry 类中对应的 hashCode 变量。</li>
<li>然后，使用这个哈希值找到它将要被存入的数组中“桶”的索引。</li>
<li>如果该位置的“桶”中已经有一个元素，那么新的元素会被插入到“桶”的头部，next 指向上一个元素——本质上使“桶”形成链表。</li>
</ul>
</li>
</ul>
<h3 id="get-Object-key"><a href="#get-Object-key" class="headerlink" title="get(Object key)"></a>get(Object key)</h3><ul>
<li><p>在理解了put之后，get就很简单了。大致思路如下：</p>
</li>
<li><p>具体代码的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 直接命中</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 未命中</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在树中get</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 在链表中get</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>大概的意思是</p>
<ul>
<li>bucket里的第一个节点，直接命中；</li>
<li>如果有冲突，则通过key.equals(k)去查找对应的entry<ul>
<li>若为树，则在树中通过key.equals(k)查找，O(logn)；</li>
<li>若为链表，则在链表中通过key.equals(k)查找，O(n)。</li>
</ul>
</li>
</ul>
</li>
<li><p>对于查找一个key时，HashMap会发生什么 ?</p>
<ul>
<li>键的哈希值先被计算出来</li>
<li>在 mHashes[] 数组中二分查找此哈希值。这表明查找的时间复杂度增加到了 O(logN)。</li>
<li>一旦得到了哈希值所对应的索引 index，键值对中的键就存储在 mArray[2index] ，值存储在 mArray[2index+1]。</li>
<li>这里的时间复杂度从 O(1) 上升到 O(logN)，但是内存效率提升了。当我们在 100 左右的数据量范围内尝试时，没有耗时的问题，察觉不到时间上的差异，但我们应用的内存效率获得了提高。</li>
</ul>
</li>
</ul>
<h3 id="remove-Object-key"><a href="#remove-Object-key" class="headerlink" title="remove(Object key)"></a>remove(Object key)</h3><ul>
<li><p>从 Map 中移除键值对的操作，在底层数据结构的体现就是移除对某个结点对象的引用，可能是从数组中、也可能是链表或者红黑树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K, V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">            <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.remove and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash       key 的哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key        the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value      key对应的值，只有当 matchValue 为 true 时才需要使用到，否则忽略该值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matchValue 如果为 true ，则只有当 Map 中存在某个键 equals key 且 value 相等时才会移除该元素，否则只要 key 的 hash 值相等就直接移除该元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> movable    if false do not move other nodes while removing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K, V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                            <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    Node&lt;K, V&gt;[] tab;</span><br><span class="line">    Node&lt;K, V&gt; p;</span><br><span class="line">    <span class="type">int</span> n, index;</span><br><span class="line">    <span class="comment">//只有当 table 不为空且 hash 对应的索引位置存在值时才有可移除的对象</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        Node&lt;K, V&gt; node = <span class="literal">null</span>, e;</span><br><span class="line">        K k;</span><br><span class="line">        V v;</span><br><span class="line">        <span class="comment">//如果与头结点的 key 相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123; <span class="comment">//存在哈希冲突</span></span><br><span class="line">            <span class="comment">//用红黑树来处理哈希冲突</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">//查找对应结点</span></span><br><span class="line">                node = ((TreeNode&lt;K, V&gt;) p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">//用链表来处理哈希冲突</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//node != null 说明存在相应结点</span></span><br><span class="line">        <span class="comment">//如果 matchValue 为 false ，则通过之前的判断可知查找到的结点的 key 与 参数 key 的哈希值一定相等，此处就可以直接移除结点 node</span></span><br><span class="line">        <span class="comment">//如果 matchValue 为 true ，则当 value 相等时才需要移除该结点</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value || (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode) <span class="comment">//对应红黑树</span></span><br><span class="line">                ((TreeNode&lt;K, V&gt;) node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p) <span class="comment">//对应 key 与头结点相等的情况，此时直接将指针移向下一位即可</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//对应的是链表的情况</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            <span class="comment">//用于 LinkedHashMap ，在 HashMap 中是空实现</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="resize-扩容"><a href="#resize-扩容" class="headerlink" title="resize()扩容"></a>resize()扩容</h3><ul>
<li><p>初始化或加倍表大小。</p>
<ul>
<li>如果为NULL，则按照在字段阈值中保持的初始容量目标分配。否则，由于我们使用的是二次幂展开，每个bin中的元素要么保持在相同的索引中，要么在新表中以两个偏移的幂移动。</li>
</ul>
</li>
<li><p>依据 resize 源码，不考虑极端情况（容量理论最大极限由MAXIMUM_CAPACITY 指定，数值为1&lt;&lt;30，也就是 2 的 30 次方），可以归纳为：</p>
<ul>
<li>门限值等于（负载因子）x（容量），如果构建 HashMap的时候没有指定它们，那么就是依据相应的默认常量值。</li>
<li>门限通常是以倍数进行调整 （newThr &#x3D; oldThr &lt;&lt; 1），我前面提到，根据 putVal 的逻辑，当元素个数超过门限大小时，则调整 Map 大小。</li>
<li>扩容后，需要将老的数组中的元素重新放置到新的数组，这是扩容的一个主要开销来源。</li>
</ul>
</li>
<li><p>HashMap的容量为什么是2的n次幂，和put的计算index方法((n - 1) &amp; hash)有着千丝万缕的关系，</p>
</li>
<li><p>符号&amp;是按位与的计算，这是位运算，计算机能直接运算，特别高效，</p>
</li>
<li><p>按位与&amp;的计算方法是，只有当对应位置的数据都为1时，运算结果也为1，</p>
</li>
<li><p>当HashMap的容量是2的n次幂时，(n-1)的2进制也就是1111111***111这样形式的，这样与添加元素的hash值进行位运算时，能够充分的散列，使得添加的元素均匀分布在HashMap的每个位置上，减少hash碰撞，下面举例进行说明。</p>
</li>
<li><p>HashMap的容量是16时，它的二进制是10000，(n-1)的二进制是01111，与hash值得计算结果如下：</p>
<ul>
<li>不同的hash值，和(n-1)进行位运算后，能够得出不同的值，使得添加的元素能够均匀分布在集合中不同的位置上，避免hash碰撞。</li>
<li>HashMap的初始容量是2的n次幂，扩容也是2倍的形式进行扩容，是因为容量是2的n次幂，可以使得添加的元素均匀分布在HashMap中的数组上，减少hash碰撞，避免形成链表的结构，使得查询效率降低！</li>
</ul>
</li>
<li><p>resize()源码如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当put时，如果发现目前的bucket占用程度已经超过了Load Factor所希望的比例，那么就会发生resize。</p>
<ul>
<li><p>在resize的过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中。resize的注释是这样描述的：</p>
</li>
<li><blockquote>
<p>Initializes or doubles table size. If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must either<strong>stay at same index</strong>, or<strong>move with a power of two offset</strong>in the new table.</p>
</blockquote>
</li>
<li><p>大致意思就是说，当超过限制的时候会resize，然而又因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。</p>
</li>
</ul>
</li>
<li><p>例如我们从16扩展为32时，<code>(n - 1) &amp; hash</code>表示计算元素在集合的位置具体的变化如下所示：</p>
<ul>
<li><p>长度为16的时候，n-1&#x3D;15&#x3D;1111</p>
<ul>
<li>hash1和hash2 与运算后的结果都为0101</li>
</ul>
</li>
<li><p>扩容后32，n-1: 31&#x3D;11111</p>
<ul>
<li>hash1与运算后的结果都为0101</li>
<li>hsh2 与运算后的结果都为10101</li>
</ul>
</li>
<li><p><img src= "/medias/detail/load.gif" data-lazy-src="/p/5b59a61f/da2df9ad67181daa328bb09515c1e1c8.png"></p>
</li>
<li><p>因此扩容后，那么n-1的mask范围在高位多1bit(红色)，因此新的index计算就会发生这样的变化：</p>
</li>
<li><p><img src= "/medias/detail/load.gif" data-lazy-src="/p/5b59a61f/8d3f779ad8dfcd685a538bbeb0b24cfe.png"></p>
</li>
<li><p>因此，我们在扩充HashMap的时候，不用重新计算hash值。只需要看看(hash&amp;n-1)值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。可以看看下图为16扩充为32的resize示意图：</p>
</li>
<li><p><img src= "/medias/detail/load.gif" data-lazy-src="/p/5b59a61f/10d36fdd4a1165bc6f75491f89cc3743.png"></p>
</li>
<li><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。</p>
</li>
</ul>
</li>
</ul>
<h3 id="Hash函数实现"><a href="#Hash函数实现" class="headerlink" title="Hash函数实现"></a>Hash函数实现</h3><ul>
<li><p>首先看下存储put代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">//高位运算</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以看到这个函数大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或。其中代码注释是这样写的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Computes key.hashCode() and spreads (XORs) higher bits of hash</span><br><span class="line"> * to lower.  Because the table uses power-of-two masking, sets of</span><br><span class="line"> * hashes that vary only in bits above the current mask will</span><br><span class="line"> * always collide. (Among known examples are sets of Float keys</span><br><span class="line"> * holding consecutive whole numbers in small tables.)  So we</span><br><span class="line"> * apply a transform that spreads the impact of higher bits</span><br><span class="line"> * downward. There is a tradeoff between speed, utility, and</span><br><span class="line"> * quality of bit-spreading. Because many common sets of hashes</span><br><span class="line"> * are already reasonably distributed (so don&#x27;t benefit from</span><br><span class="line"> * spreading), and because we use trees to handle large sets of</span><br><span class="line"> * collisions in bins, we just XOR some shifted bits in the</span><br><span class="line"> * cheapest possible way to reduce systematic lossage, as well as</span><br><span class="line"> * to incorporate impact of the highest bits that would otherwise</span><br><span class="line"> * never be used in index calculations because of table bounds.</span><br><span class="line">    */</span><br></pre></td></tr></table></figure>
</li>
<li><p>在get和put的过程中，计算下标时，先对hashCode进行hash操作，然后再通过hash值进一步计算下标，如下图所示：</p>
<ul>
<li><img src= "/medias/detail/load.gif" data-lazy-src="/p/5b59a61f/4acf898694b8fb53498542dc0c5f765a.png"></li>
</ul>
</li>
<li><p>在设计hash函数时，因为目前的table长度n为2的幂，而计算下标的时候，是这样实现的(使用<code>&amp;</code>位操作，而非<code>%</code>求余)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n - 1) &amp; hash</span><br></pre></td></tr></table></figure>
</li>
<li><p>设计者认为这方法很容易发生碰撞。为什么这么说呢？</p>
<ul>
<li>不妨思考一下，在n - 1为15(0x1111)时，其实散列真正生效的只是低4bit的有效位，当然容易碰撞了。</li>
<li>因此，设计者想了一个顾全大局的方法(综合考虑了速度、作用、质量)，就是把高16bit和低16bit异或了一下。设计者还解释到因为现在大多数的hashCode的分布已经很不错了，就算是发生了碰撞也用<code>O(logn)</code>的tree去做了。仅仅异或一下，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。</li>
</ul>
</li>
<li><p>如果还是产生了频繁的碰撞，会发生什么问题呢？</p>
<ul>
<li><p>作者注释说，他们使用树来处理频繁的碰撞(we use trees to handle large sets of collisions in bins)，在<a target="_blank" rel="noopener external nofollow noreferrer" href="http://openjdk.java.net/jeps/180">JEP-180</a>中，描述了这个问题：</p>
</li>
<li><blockquote>
<p>Improve the performance of java.util.HashMap under high hash-collision conditions by<strong>using balanced trees rather than linked lists to store map entries</strong>. Implement the same improvement in the LinkedHashMap class.</p>
</blockquote>
</li>
</ul>
</li>
<li><p>之前已经提过，在获取HashMap的元素时，基本分两步：</p>
<ul>
<li>1.首先根据hashCode()做hash，然后确定bucket的index；</li>
<li>2.如果bucket的节点的key不是我们需要的，则通过keys.equals()在链中找。</li>
</ul>
</li>
<li><p>在Java 8之前的实现中是用链表解决冲突的</p>
<ul>
<li>在产生碰撞的情况下，进行get时，两步的时间复杂度是O(1)+O(n)。因此，当碰撞很厉害的时候n很大，O(n)的速度显然是影响速度的。</li>
<li>因此在Java 8中，利用红黑树替换链表，这样复杂度就变成了O(1)+O(logn)了，这样在n很大的时候，能够比较理想的解决这个问题。</li>
</ul>
</li>
<li><p>为什么要这样实现hash？</p>
<ul>
<li>在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：<code>(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，主要是从<strong>速度、功效、质量</strong>来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。</li>
</ul>
</li>
</ul>
<h3 id="容量和装载因子"><a href="#容量和装载因子" class="headerlink" title="容量和装载因子"></a>容量和装载因子</h3><ul>
<li><p>在HashMap中有两个很重要的参数，容量(Capacity)和负载因子(Load factor)</p>
<ul>
<li>简单的说，Capacity就是bucket的大小，Loadfactor就是bucket填满程度的最大比例。</li>
<li>如果对迭代性能要求很高的话，不要把<code>capacity</code>设置过大，也不要把<code>load factor</code>设置过小。</li>
<li>当bucket中的entries的数目大于<code>capacity*load factor</code>时就需要调整bucket的大小为当前的2倍。</li>
</ul>
</li>
<li><p>什么是装载因子</p>
<ul>
<li>装载因子用于规定数组在自动扩容之前可以数据占有其容量的最高比例，即当数据量占有数组的容量达到这个比例后，数组将自动扩容。</li>
<li>装载因子衡量的是一个散列表的空间的使用程度，装载因子越大表示散列表的装填程度越高，反之愈小。因此如果装载因子越大，则对空间的利用程度更高，相对应的是查找效率的降低。</li>
<li>如果装载因子太小，那么数组的数据将过于稀疏，对空间的利用率低，官方默认的装载因子为0.75，是平衡空间利用率和运行效率两者之后的结果。</li>
<li>如果在实际情况中，内存空间较多而对时间效率要求很高，可以选择降低装载因子的值；如果内存空间紧张而对时间效率要求不高，则可以选择提高装载因子的值。</li>
<li>此外，即使装载因子和哈希算法设计得再合理，也不免会出现由于哈希冲突导致链表长度过长的情况，这将严重影响 HashMap 的性能。为了优化性能，从 JDK1.8 开始引入了红黑树，当链表长度超出 TREEIFY_THRESHOLD 规定的值时，链表就会被转换为红黑树，利用红黑树快速增删改查的特点以提高 HashMap 的性能。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化ID</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">362498820763181265L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希桶数组的默认容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//网上很多文章都说这个值是哈希桶数组能够达到的最大容量，其实这样说并不准确</span></span><br><span class="line"><span class="comment">//从 resize() 方法的扩容机制可以看出来，HashMap 每次扩容都是将数组的现有容量增大一倍</span></span><br><span class="line"><span class="comment">//如果现有容量已大于或等于 MAXIMUM_CAPACITY ，则不允许再次扩容</span></span><br><span class="line"><span class="comment">//否则即使此次扩容会导致容量超出 MAXIMUM_CAPACITY ，那也是允许的</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//装载因子的默认值</span></span><br><span class="line"><span class="comment">//装载因子用于规定数组在自动扩容之前可以数据占有其容量的最高比例，即当数据量占有数组的容量达到这个比例后，数组将自动扩容</span></span><br><span class="line"><span class="comment">//装载因子衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小</span></span><br><span class="line"><span class="comment">//对于使用链表的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，则对空间的利用程度更高，相对应的是查找效率的降低</span></span><br><span class="line"><span class="comment">//如果负载因子太小，那么数组的数据将过于稀疏，对空间的利用率低</span></span><br><span class="line"><span class="comment">//官方默认的负载因子为0.75，是平衡空间利用率和运行效率两者之后的结果</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了提高效率，当链表的长度超出这个值时，就将链表转换为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HashMap的大小超过了负载因子(<code>load factor</code>)定义的容量，怎么办？</p>
<ul>
<li>如果超过了负载因子(默认<strong>0.75</strong>)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。</li>
</ul>
</li>
</ul>
<h3 id="hashCode和equal"><a href="#hashCode和equal" class="headerlink" title="hashCode和equal"></a>hashCode和equal</h3><ul>
<li>get和put的中的equals()和hashCode()的都有什么作用？<ul>
<li>通过对key的hashCode()进行hashing，并计算下标( <code>(n-1) &amp; hash</code>)，从而获得buckets的位置。</li>
<li>如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点</li>
</ul>
</li>
</ul>
<h3 id="HashMap的table下标"><a href="#HashMap的table下标" class="headerlink" title="HashMap的table下标"></a>HashMap的table下标</h3><ul>
<li>它是用自己的hash方法确定下标<ul>
<li>HashMap自己实现了自己的hash()方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均；</li>
<li>在保证数组长度为2的幂次方的时候，使用hash()运算之后的值与运算（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题；</li>
</ul>
</li>
<li>不直接使用hashCode()处理后的哈希值<ul>
<li>hashCode()方法返回的是int整数类型，其范围为-(2^31)<del>(2^31-1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）</del>2 ^ 30，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过hashCode()计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；</li>
</ul>
</li>
<li>为什么数组长度要保证为2的幂次方呢？<ul>
<li>只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，即实现了key的定位，2的幂次方也可以减少冲突次数，提高HashMap的查询效率；</li>
<li>如果 length 为 2 的次幂 则 length-1 转化为二进制必定是 11111……的形式，在于 h 的二进制与操作效率会非常的快，而且空间不浪费；如果 length 不是 2 的次幂，比如 length 为 15，则 length - 1 为 14，对应的二进制为 1110，在于 h 与操作，最后一位都为 0 ，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这样就会造成空间的浪费。</li>
</ul>
</li>
</ul>
<h2 id="Key为何需要不可变"><a href="#Key为何需要不可变" class="headerlink" title="Key为何需要不可变"></a>Key为何需要不可变</h2><ul>
<li>为什么HashMap中String、Integer这样的包装类适合作为K？<ul>
<li>String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率<ul>
<li>都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况</li>
<li>内部已重写了equals()、hashCode()等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况</li>
<li>如果对象在创建后它的哈希值发生了变化，则Map对象很可能就定位不到映射的位置。</li>
</ul>
</li>
</ul>
</li>
<li>想要让自己的Object作为K应该怎么办呢？<ul>
<li>重写hashCode()和equals()方法<ul>
<li>重写hashCode()是因为需要计算存储数据的存储位置，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；</li>
<li>重写equals()方法，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，目的是为了保证key在哈希表中的唯一性；</li>
</ul>
</li>
</ul>
</li>
<li>总结<ul>
<li>采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获</li>
</ul>
</li>
</ul>
<h2 id="HashMap为啥要扩容"><a href="#HashMap为啥要扩容" class="headerlink" title="HashMap为啥要扩容"></a>HashMap为啥要扩容</h2><ul>
<li>HashMap是为啥要扩容<ul>
<li>当链表数组的容量超过初始容量*加载因子（默认0.75）时，再散列将链表数组扩大2倍，把原链表数组的搬移到新的数组中。为什么需要使用加载因子？为什么需要扩容呢？因为如果填充比很大，说明利用的空间很多，如果一直不进行扩容的话，链表就会越来越长，这样查找的效率很低，扩容之后，将原来链表数组的每一个链表分成奇偶两个子链表分别挂在新链表数组的散列位置，这样就<strong>减少了每个链表的长度，增加查找效率</strong>。</li>
</ul>
</li>
</ul>
<h2 id="HashMap扩容存在问题"><a href="#HashMap扩容存在问题" class="headerlink" title="HashMap扩容存在问题"></a>HashMap扩容存在问题</h2><ul>
<li><p>hashmap不能用于多线程场景中，并发环境下，需要扩容时候出现循环链表，通过get获取值造成死循环。多线程下推荐使用concurrentHashmap！</p>
</li>
<li><p>当多线程的情况下，可能产生条件竞争。当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来(<strong>jdk7 将遍历到的节点放入到链表头</strong>)，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。</p>
</li>
<li><p>jdk1.7及以前 扩容时使用的头插法 并发时可能会形成环状链表造成死循环</p>
</li>
<li><p>1.8改为了尾插法 可以避免这种问题 只是依然避免不了节点丢失的问题</p>
</li>
<li><p>简单说:<strong>扩容过程中使用头插法将oldTable中的单链表中的节点插入到newTable的单链表头中</strong>，所以newTable中的单链表会倒置oldTable中的单链表。那么在多个线程同时扩容的情况下就可能导致<strong>扩容后的HashMap中存在一个有环的单链表</strong>，从而导致后续执行get操作的时候，会触发死循环，引起CPU的100%问题。所以一定要避免在并发环境下使用HashMap。</p>
</li>
<li><p>JDK1.7复制表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span></span><br><span class="line">&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//创建一个新的Hash Table</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];</span><br><span class="line">    <span class="comment">//将Old Hash Table上的数据迁移到New Hash Table上</span></span><br><span class="line">    transfer(newTable);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="type">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重点在这里面的transfer()!</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable)</span></span><br><span class="line">&#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="comment">//下面这段代码的意思是：</span></span><br><span class="line">    <span class="comment">//  从OldTable里摘一个元素出来，然后放到NewTable中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>正常扩容</p>
<ul>
<li>倒置了key7 在 key3 前面了</li>
</ul>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/5b59a61f/d3d185462f35e8932ad4edcc7a05e68a.jpg"></p>
</li>
<li><p>并发下二个线程进行扩容</p>
<ul>
<li>线程1执行到<code>Entry&lt;K,V&gt; next = e.next;</code>后挂起，e指向元素3，e.next指向元素7</li>
<li>线程2在new table的数组3位置依次用头插法插入3个元素后如下图所示</li>
</ul>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/5b59a61f/cb4b944919bcd706d3440be83c28a518.jpg"></p>
<ul>
<li><p>线程2扩容完毕，线程1开始扩容，此时线程B继续执行以下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K,V&gt; next = e.next;   <span class="comment">//e=key3，next=key7</span></span><br><span class="line"><span class="comment">// 头插法，将key3放到数组3都头部</span></span><br><span class="line">e.next = newTable[i];    <span class="comment">//将数组3的地址赋予变量e.next</span></span><br><span class="line">newTable[i] = e; <span class="comment">//将3放到数组3的位置</span></span><br><span class="line">e = next;　　<span class="comment">//  e = next = key7</span></span><br></pre></td></tr></table></figure>

<ul>
<li><img src= "/medias/detail/load.gif" data-lazy-src="/p/5b59a61f/58b9984b1bdf9116019a1df3583b0bbb.jpg"></li>
</ul>
</li>
</ul>
</li>
<li><p>e !&#x3D; null 继续执行,这里由于线程2的扩容导致链表倒置，这里会在扩容后出现环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程2导致了key7的next变成了key3</span></span><br><span class="line">Entry&lt;K,V&gt; next = e.next;  <span class="comment">//  e=key7,next = key3</span></span><br><span class="line">e.next = newTable[i];　<span class="comment">// key7的下一个指向数组3的位置</span></span><br><span class="line">newTable[i] = e; <span class="comment">//将key7放到数组3的位置</span></span><br><span class="line">e = next;　　　　<span class="comment">//e =next = key3</span></span><br></pre></td></tr></table></figure>

<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/5b59a61f/67f2898dc61ab6d4c0c473187ed1ed28.jpg"></p>
</li>
<li><p>1.8后采用尾插法，可以避免这种问题 只是依然避免不了节点丢失的问题，如果最后用thead1的结果作为扩容结果，key5的节点就丢失了</p>
</li>
<li><p>1.8后的链表可能转换成树，可能会产生<em>红黑树成环</em>的场景导致死循环。</p>
</li>
</ul>
<h2 id="HashMap线程问题"><a href="#HashMap线程问题" class="headerlink" title="HashMap线程问题"></a>HashMap线程问题</h2><ul>
<li><p>HashMap是非线程安全的，那么测试一下，先看下测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                map.put(<span class="keyword">new</span> <span class="title class_">Integer</span>(i), i);</span><br><span class="line">            &#125;</span><br><span class="line">            LogUtils.d(<span class="string">&quot;yc-----执行结束----t1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                map.put(<span class="keyword">new</span> <span class="title class_">Integer</span>(i), i);</span><br><span class="line">            &#125;</span><br><span class="line">            LogUtils.d(<span class="string">&quot;yc-----执行结束----t2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                map.put(<span class="keyword">new</span> <span class="title class_">Integer</span>(i), i);</span><br><span class="line">            &#125;</span><br><span class="line">            LogUtils.d(<span class="string">&quot;yc-----执行结束----t2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                map.get(<span class="keyword">new</span> <span class="title class_">Integer</span>(i));</span><br><span class="line">            &#125;</span><br><span class="line">            LogUtils.d(<span class="string">&quot;yc-----执行结束----t2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                map.get(<span class="keyword">new</span> <span class="title class_">Integer</span>(i));</span><br><span class="line">            &#125;</span><br><span class="line">            LogUtils.d(<span class="string">&quot;yc-----执行结束----t2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                map.get(<span class="keyword">new</span> <span class="title class_">Integer</span>(i));</span><br><span class="line">            &#125;</span><br><span class="line">            LogUtils.d(<span class="string">&quot;yc-----执行结束----t2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line">    t4.start();</span><br><span class="line">    t5.start();</span><br><span class="line">    t6.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>就是启了6个线程，不断的往一个非线程安全的HashMap中put&#x2F;get内容，put的内容很简单，key和value都是从0自增的整数（这个put的内容做的并不好，以致于后来干扰了我分析问题的思路）。对HashMap做并发写操作，我原以为只不过会产生脏数据的情况，但反复运行这个程序，会出现线程t1、t2被卡住的情况，多数情况下是一个线程被卡住另一个成功结束，偶尔会6个线程都被卡住。</p>
<ul>
<li>多线程下直接使用ConcurrentHashMap，解决了这个问题。</li>
<li>CPU利用率过高一般是因为出现了出现了死循环，导致部分线程一直运行，占用cpu时间。问题原因就是HashMap是非线程安全的，多个线程put的时候造成了某个key值Entry key List的死循环，问题就这么产生了。</li>
<li>当另外一个线程get 这个Entry List 死循环的key的时候，这个get也会一直执行。最后结果是越来越多的线程死循环，最后导致卡住。我们一般认为HashMap重复插入某个值的时候，会覆盖之前的值，这个没错。但是对于多线程访问的时候，由于其内部实现机制(在多线程环境且未作同步的情况下，对同一个HashMap做put操作可能导致两个或以上线程同时做rehash动作，就可能导致循环键表出现，一旦出现线程将无法终止，持续占用CPU，导致CPU使用率居高不下)，就可能出现安全问题了。</li>
</ul>
</li>
</ul>
<h2 id="HashMap效率"><a href="#HashMap效率" class="headerlink" title="HashMap效率"></a>HashMap效率</h2><ul>
<li><p>需求：测试下不同的初始化大小以及 key 值的 HashCode 值的分布情况的不同对 HashMap 效率的影响</p>
</li>
<li><p>测试初始化大小对 HashMap 的性能影响！！！</p>
<ul>
<li><p>首先来定义作为 Key 的类，<code>hashCode()</code> 方法直接返回其包含的属性 value。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Key</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Key</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span> == o) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Key</span> <span class="variable">key</span> <span class="operator">=</span> (Key) o;</span><br><span class="line">            <span class="keyword">return</span> value == key.value;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_KEY</span> <span class="operator">=</span> <span class="number">20000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Key[] KEYS = <span class="keyword">new</span> <span class="title class_">Key</span>[MAX_KEY];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">testHashMap</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX_KEY; i++) &#123;</span><br><span class="line">            KEYS[i] = <span class="keyword">new</span> <span class="title class_">Key</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>; i &lt;= MAX_KEY; i *= <span class="number">10</span>) &#123;</span><br><span class="line">            test(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        Map&lt;Key, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(size);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX_KEY; i++) &#123;</span><br><span class="line">            map.put(KEYS[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;yc---初始化大小是：&quot;</span> + size + <span class="string">&quot; , 所用时间：&quot;</span> + (endTime - startTime) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">- 初始化大小从 <span class="number">100</span> 到 <span class="number">100000</span> 之间以 <span class="number">10</span> 倍的倍数递增，向 HashMap 存入同等数据量的数据，观察不同 HashMap 存入数据消耗的总时间。例子中，各个Key对象之间的哈希码值各不相同，所以键值对在哈希桶数组中的分布可以说是很均匀的了，此时主要影响性能的就是扩容机制了,可以看出各个初始化大小对 HashMap 的性能影响还是很大的。</span><br><span class="line"></span><br><span class="line">    ```java</span><br><span class="line">    yc---初始化大小是：<span class="number">20</span> , 所用时间：<span class="number">20</span>毫秒</span><br><span class="line">    yc---初始化大小是：<span class="number">200</span> , 所用时间：<span class="number">5</span>毫秒</span><br><span class="line">    yc---初始化大小是：<span class="number">2000</span> , 所用时间：<span class="number">0</span>毫秒</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>然后测试Key对象之间频繁发生哈希冲突时HashMap的性能</p>
<ul>
<li><p>令 Key 类的 <code>hashCode()</code> 方法固定返回 100，则每个键值对在存入 HashMap 时，一定会发生哈希冲突。可以看到此时存入同等数据量的数据所用时间呈几何数增长了，此时主要影响性能的点就在于对哈希冲突的处理</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashMap性能分析yc---初始化大小是：20 , 所用时间：281毫秒</span><br><span class="line">yc---初始化大小是：200 , 所用时间：246毫秒</span><br><span class="line">yc---初始化大小是：2000 , 所用时间：213毫秒</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="HashMap性能分析"><a href="#HashMap性能分析" class="headerlink" title="HashMap性能分析"></a>HashMap性能分析</h2><ul>
<li>查找key的时候，时间复杂度是 O(1)，同时它也花费了更多的内存空间。<ul>
<li>缺点:</li>
<li>自动装箱的存在意味着每一次插入都会有额外的对象创建。这跟垃圾回收机制一样也会影响到内存的利用。</li>
<li>HashMap.Entry 对象本身是一层额外需要被创建以及被垃圾回收的对象。</li>
<li>“桶” 在 HashMap 每次被压缩或扩容的时候都会被重新安排。这个操作会随着对象数量的增长而变得开销极大。</li>
</ul>
</li>
<li>对于查找一个key时，HashMap会发生什么 ?<ul>
<li>键的哈希值先被计算出来</li>
<li>在 mHashes[] 数组中二分查找此哈希值。这表明查找的时间复杂度增加到了 O(logN)。</li>
<li>一旦得到了哈希值所对应的索引 index，键值对中的键就存储在 mArray[2index] ，值存储在 mArray[2index+1]。</li>
<li>这里的时间复杂度从 O(1) 上升到 O(logN)，但是内存效率提升了。当我们在 100 左右的数据量范围内尝试时，没有耗时的问题，察觉不到时间上的差异，但我们应用的内存效率获得了提高。</li>
</ul>
</li>
<li>Android中推荐使用ArrayMap或者SparseArray替代HashMap<ul>
<li>在Android中，当涉及到快速响应的应用时，内存至关重要，因为持续地分发和释放内存会出发垃圾回收机制，这会拖慢应用运行。</li>
<li>垃圾回收时间段内，应用程序是不会运行的，最终应用使用上就显得卡顿。</li>
<li>ArrayMap 使用2个数组。它的对象实例内部有用来存储对象的 Object[] mArray 和 存储哈希值的 int[] mHashes。当插入一个键值对时：<ul>
<li>键&#x2F;值被自动装箱。</li>
<li>键对象被插入到 mArray[] 数组中的下一个空闲位置。</li>
<li>值对象也会被插入到 mArray[] 数组中与键对象相邻的位置。</li>
<li>键的哈希值会被计算出来并被插入到 mHashes[] 数组中的下一个空闲位置。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="HashTable和HashMap"><a href="#HashTable和HashMap" class="headerlink" title="HashTable和HashMap"></a>HashTable和HashMap</h2><ul>
<li>HashTable和HashMap初始化与增长方式<ul>
<li>初始化时：<ul>
<li>HashTable在不指定容量的情况下的默认容量为11，且不要求底层数组的容量一定要为2的整数次幂；</li>
<li>HashMap默认容量为16，且要求容量一定为2的整数次幂。</li>
</ul>
</li>
<li>扩容时：<ul>
<li>Hashtable将容量变为原来的2倍加1；</li>
<li>HashMap扩容将容量变为原来的2倍。</li>
</ul>
</li>
</ul>
</li>
<li>HashTable和HashMap线程安全性<ul>
<li>HashTable其方法函数都是同步的（采用synchronized修饰），不会出现两个线程同时对数据进行操作的情况，因此保证了线程安全性。也正因为如此，在多线程运行环境下效率表现非常低下。因为当一个线程访问HashTable的同步方法时，其他线程也访问同步方法就会进入阻塞状态。比如当一个线程在添加数据时候，另外一个线程即使执行获取其他数据的操作也必须被阻塞，大大降低了程序的运行效率，在新版本中已被废弃，不推荐使用。</li>
<li>HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步（1）可以用Collections的synchronizedMap方法；（2）使用ConcurrentHashMap类，相较于HashTable锁住的是对象整体，ConcurrentHashMap基于lock实现锁分段技术。首先将Map存放的数据分成一段一段的存储方式，然后给每一段数据分配一把锁，当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访问。ConcurrentHashMap不仅保证了多线程运行环境下的数据访问安全性，而且性能上有长足的提升。</li>
</ul>
</li>
</ul>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><ul>
<li><p>概述</p>
<ul>
<li>底层的数据结构是链表和哈希表，元素有序(具有可预知的迭代顺序)并且唯一。</li>
<li>由哈希表保证键的唯一性</li>
<li>由链表保证键盘的有序(存储和取出的顺序一致)</li>
</ul>
</li>
<li><p>示例</p>
<ul>
<li>LinkedHashMap的迭代输出的结果保持了插入顺序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashMap&lt;String, Integer&gt; lmap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String, Integer&gt;();</span><br><span class="line">lmap.put(<span class="string">&quot;语文&quot;</span>, <span class="number">1</span>);</span><br><span class="line">lmap.put(<span class="string">&quot;数学&quot;</span>, <span class="number">2</span>);</span><br><span class="line">lmap.put(<span class="string">&quot;英语&quot;</span>, <span class="number">3</span>);</span><br><span class="line">lmap.put(<span class="string">&quot;历史&quot;</span>, <span class="number">4</span>);</span><br><span class="line">lmap.put(<span class="string">&quot;政治&quot;</span>, <span class="number">5</span>);</span><br><span class="line">lmap.put(<span class="string">&quot;地理&quot;</span>, <span class="number">6</span>);</span><br><span class="line">lmap.put(<span class="string">&quot;生物&quot;</span>, <span class="number">7</span>);</span><br><span class="line">lmap.put(<span class="string">&quot;化学&quot;</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;String, Integer&gt; entry : lmap.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果是：</span></span><br><span class="line"></span><br><span class="line">语文: <span class="number">1</span></span><br><span class="line">数学: <span class="number">2</span></span><br><span class="line">英语: <span class="number">3</span></span><br><span class="line">历史: <span class="number">4</span></span><br><span class="line">政治: <span class="number">5</span></span><br><span class="line">地理: <span class="number">6</span></span><br><span class="line">生物: <span class="number">7</span></span><br><span class="line">化学: <span class="number">8</span></span><br></pre></td></tr></table></figure>

<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/5b59a61f/168fb7335dd7b37c92cce97443538460.png"></p>
</li>
</ul>
<h3 id="LinkedHashMap特点"><a href="#LinkedHashMap特点" class="headerlink" title="LinkedHashMap特点"></a>LinkedHashMap特点</h3><ul>
<li><p>官方文档所说：</p>
<p><strong>Hash table</strong> and <strong>linked list</strong> implementation of the Map interface, with predictable iteration order. This implementation differs from HashMap in that it maintains a <strong>doubly-linked list</strong> running through all of its entries. This linked list defines the iteration ordering, which is normally the order in which keys were inserted into the map (<strong>insertion-order</strong>).</p>
</li>
<li><p>具备特点</p>
<ul>
<li>LinkedHashMap是Hash表和链表的实现，并且依靠着双向链表保证了迭代顺序是插入的顺序。</li>
</ul>
</li>
<li><p>为何有LinkedHashMap</p>
<ul>
<li>HashMap 是用于映射(键值对)处理的数据类型，不保证元素的顺序按照插入顺序来排列，为了解决这一问题，Java 在 JDK1.4 以后提供了 LinkedHashMap 来实现有序的 HashMap。</li>
</ul>
</li>
<li><p>LinkedHashMap 是 HashMap 的子类</p>
<ul>
<li>它保留了元素的插入顺序，在内部维护着一个按照元素插入顺序或者元素访问顺序来排列的链表，默认是按照元素的插入顺序来排列，就像使用 ArrayList 一样；</li>
<li>如果是按照元素的访问顺序来排列，则访问元素后该元素将移至链表的尾部，可以以此来实现 LRUcache 缓存算法。</li>
</ul>
</li>
</ul>
<h2 id="LinkedHashMap的Entry-节点类"><a href="#LinkedHashMap的Entry-节点类" class="headerlink" title="LinkedHashMap的Entry 节点类"></a>LinkedHashMap的Entry 节点类</h2><ul>
<li><p>前面说了，LinkedHashMap 是 HashMap 的子类</p>
<ul>
<li>即 LinkedHashMap 的主要数据结构实现还是依靠 HashMap 来实现，LinkedHashMap 只是对 HashMap 做的一层外部包装，这个从 LinkedHashMap 内声明的结点类就可以看出来。</li>
<li>Entry 类在 Node 类的基础上扩展了两个新的成员变量，这两个成员变量就是 LinkedHashMap 来实现有序访问的关键，不管结点对象在 HashMap 内部为了解决哈希冲突采用的是链表还是红黑树，这两个变量的指向都不受数据结构的变化而影响</li>
</ul>
</li>
<li><p>从这也可以看出集合框架在设计时一个很巧妙的地方</p>
<ul>
<li>LinkedHashMap 内部没有新建一个链表用来维护元素的插入顺序，而是通过扩展父类来实现自身的功能</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkedHashMap 扩展了 HashMap.Node 类</span></span><br><span class="line"><span class="comment">//在其基础上新增了两个成员变量用于指定上一个结点 before 和下一个结点 after</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="LinkedHashMap的实现函数"><a href="#LinkedHashMap的实现函数" class="headerlink" title="LinkedHashMap的实现函数"></a>LinkedHashMap的实现函数</h2><ul>
<li><p>在HashMap中提到了下面的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> &#123; &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123; &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>LinkedHashMap继承于HashMap，因此也重新实现了这3个函数，顾名思义这三个函数的作用分别是：节点访问后、节点插入后、节点移除后做一些事情。</p>
</li>
<li><p>从下面3个函数看出来，基本上都是为了<strong>保证双向链表中的节点次序或者双向链表容量</strong>所做的一些额外的事情，目的就是保持双向链表中节点的顺序要从eldest到youngest。</p>
</li>
</ul>
<h4 id="afterNodeAccess函数"><a href="#afterNodeAccess函数" class="headerlink" title="afterNodeAccess函数"></a>afterNodeAccess函数</h4><ul>
<li><p>afterNodeAccess函数如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="comment">// 如果定义了accessOrder，那么就保证最近访问节点放到最后</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="literal">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>就是说在进行put之后就算是对节点的访问了，那么这个时候就会更新链表，把最近访问的放到最后，保证链表。</p>
</li>
</ul>
<h4 id="afterNodeInsertion函数"><a href="#afterNodeInsertion函数" class="headerlink" title="afterNodeInsertion函数"></a>afterNodeInsertion函数</h4><ul>
<li><p>代码如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="comment">// 如果定义了溢出规则，则执行相应的溢出</span></span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="literal">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果用户定义了<code>removeEldestEntry</code>的规则，那么便可以执行相应的移除操作。</p>
</li>
</ul>
<h4 id="afterNodeRemoval函数"><a href="#afterNodeRemoval函数" class="headerlink" title="afterNodeRemoval函数"></a>afterNodeRemoval函数</h4><ul>
<li><p>代码如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123; <span class="comment">// unlink</span></span><br><span class="line">    <span class="comment">// 从链表中移除节点</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.before = p.after = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个函数是在移除节点后调用的，就是将节点从双向链表中删除。</p>
</li>
</ul>
<h2 id="LinkedHashMap成员变量"><a href="#LinkedHashMap成员变量" class="headerlink" title="LinkedHashMap成员变量"></a>LinkedHashMap成员变量</h2><ul>
<li><p>变量 <strong>accessOrder</strong> 用于决定 LinkedHashMap 中元素的排序方式，变量 <strong>tail</strong> 则用于帮助当 accessOrder 为 true 时最新使用的一个结点的指向。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化ID</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">3801124242820219131L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指向双向链表的头结点</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指向最新插入的一个结点</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果为true，则内部元素按照访问顺序排序</span></span><br><span class="line"><span class="comment">//如果为false，则内部元素按照插入顺序排序</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="LinkedHashMap构造函数"><a href="#LinkedHashMap构造函数" class="headerlink" title="LinkedHashMap构造函数"></a>LinkedHashMap构造函数</h2><ul>
<li><p>构造函数如下所示，一般用无参构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义初始容量与装载因子</span></span><br><span class="line"><span class="comment">//内部元素按照插入顺序进行排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义装载因子</span></span><br><span class="line"><span class="comment">//内部元素按照插入顺序进行排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity);</span><br><span class="line">    accessOrder = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用默认的初始容量以及装载因子</span></span><br><span class="line"><span class="comment">//内部元素按照插入顺序进行排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    accessOrder = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用初始数据</span></span><br><span class="line"><span class="comment">//内部元素按照插入顺序进行排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    accessOrder = <span class="literal">false</span>;</span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity 初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  loadFactor      装载因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  accessOrder     如果为true，则内部元素按照访问顺序排序；如果为false，则内部元素按照插入顺序排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> accessOrder)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="LinkedHashMap方法源码"><a href="#LinkedHashMap方法源码" class="headerlink" title="LinkedHashMap方法源码"></a>LinkedHashMap方法源码</h2><h3 id="put插入元素分析"><a href="#put插入元素分析" class="headerlink" title="put插入元素分析"></a>put插入元素分析</h3><ul>
<li><p>在 HashMap 中有三个空实现的函数，源码注释中也写明这三个函数是准备由 LinkedHashMap 来实现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> &#123; &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123; &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当中，如果在调用 <code>put(K key, V value)</code> 方法插入元素时覆盖了原有值，则<code>afterNodeAccess</code> 方法会被调用，该方法用于将最新访问的键值对移至链表的尾部，其在 LinkedHashMap 的实现如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当访问了结点 e 时调用</span></span><br><span class="line"><span class="comment">//结点 e 是最新访问的一个结点，此处将结点 e 置为链表的尾结点</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123;</span><br><span class="line">    <span class="comment">//last 用来指向链表的尾结点</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="comment">//只有当上一次访问的结点不是结点 e 时（(last = tail) != e），才需要进行下一步操作</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        <span class="comment">//p 是最新访问的一个结点，b 是结点 p 的上一个结点，a 是结点 p 的下一个结点</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        <span class="comment">//因为结点 p 将成为尾结点，所以 after 置为null</span></span><br><span class="line">        p.after = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//如果 b == null ，说明结点 p 是原链表的头结点，则此时将 head 指向下一个结点 a</span></span><br><span class="line">        <span class="comment">//如果 b != null ，则移除结点 b 对结点 p 的引用</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="comment">//如果 a !=null，说明结点 p 不是原链表的尾结点，则移除结点 a 对结点 p 的引用</span></span><br><span class="line">        <span class="comment">//如果 a == null，则说明结点 p 是原链表的尾结点，则让 last 指向结点 b</span></span><br><span class="line">        <span class="keyword">if</span> (a != <span class="literal">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="comment">//如果 last == null，说明原链表为空，则此时头结点就是结点 p</span></span><br><span class="line">        <span class="comment">//如果 last != null，则建立 last 和实际尾结点 p 之间的引用</span></span><br><span class="line">        <span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最新一个引用到的结点就是 tail</span></span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>此外，当 put 方法调用结束时，<code>afterNodeInsertion</code> 方法会被调用，用于判断是否移除最近最少使用的元素，依此可以来构建 LRUcache 缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在插入元素后调用，此方法可用于 LRUcache 算法中移除最近最少使用的元素</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="literal">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果在构造函数中参数 accessOrder 传入了 true ，则链表将按照访问顺序来排列</span></span><br><span class="line"><span class="comment">//即最新访问的结点将处于链表的尾部，依此可以来构建 LRUcache 缓存</span></span><br><span class="line"><span class="comment">//此方法就用于决定是否移除最旧的缓存，默认返回 false</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="get访问元素"><a href="#get访问元素" class="headerlink" title="get访问元素"></a>get访问元素</h3><ul>
<li><p>在访问元素时，如果 accessOrder 为 true ，则会将访问的元素移至链表的尾部，由于链表内结点位置的改变仅仅是修改几个引用即可，所以这个操作还是非常轻量级的 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取键值为 key 的键值对的 value</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取键值为 key 的键值对的 value，如果 key 不存在，则返回默认值 defaultValue</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> &#123;</span><br><span class="line">   Node&lt;K,V&gt; e;</span><br><span class="line">   <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="literal">null</span>)</span><br><span class="line">       <span class="keyword">return</span> defaultValue;</span><br><span class="line">   <span class="keyword">if</span> (accessOrder)</span><br><span class="line">       afterNodeAccess(e);</span><br><span class="line">   <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="移除元素源码分析"><a href="#移除元素源码分析" class="headerlink" title="移除元素源码分析"></a>移除元素源码分析</h3><ul>
<li><p>当 HashMap 内部移除了某个结点时，LinkedHashMap 也要移除维护的链表中对该结点的引用，对应的是以下方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在移除结点 e 后调用</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123;</span><br><span class="line">    <span class="comment">//结点 b 指向结点 e 的上一个结点，结点 a 指向结点 e 的下一个结点</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    <span class="comment">//移除结点 p 对相邻结点的引用</span></span><br><span class="line">    p.before = p.after = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//如果 b == null，说明结点 p 是原链表的头结点，则移除结点 p 后新的头结点是 a</span></span><br><span class="line">    <span class="comment">//如果 b != null，则更新结点间的引用</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="comment">//如果 a == null，说明结点 a 是尾结点，则移除结点 p 后最新一个访问的结点就是原倒数第二的结点</span></span><br><span class="line">    <span class="comment">//如果 a != null，则更新结点间的引用</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="LRUCache拓展训练"><a href="#LRUCache拓展训练" class="headerlink" title="LRUCache拓展训练"></a>LRUCache拓展训练</h3><ul>
<li><p>在 Android 的实际应用开发中，LRUCache 算法是很常见的，一种典型的用途就是用来在内存中缓存 Bitmap，因为从 IO 流中读取 Bitmap 的代价很大，为了防止多次从磁盘中读取某张图片，所以可以选择在内存中缓存 Bitmap。但内存空间也是有限的，所以也不能每张图片都进行缓存，需要有选择性地缓存一定数量的图片，而最近最少使用算法（LRUCache）是一个可行的选择</p>
</li>
<li><p>这里利用 LinkedHashMap 可以按照元素使用顺序进行排列的特点，来实现一个 LRUCache 策略的缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LRUCacheMap</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最大的缓存数量</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxCacheSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">LRUCacheMap</span><span class="params">(<span class="type">int</span> maxCacheSize)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="number">16</span>, <span class="number">0.75F</span>, <span class="literal">true</span>);</span><br><span class="line">            <span class="built_in">this</span>.maxCacheSize = maxCacheSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> size() &gt; maxCacheSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//最大的缓存数量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">maxCacheSize</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        LRUCacheMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LRUCacheMap</span>&lt;&gt;(maxCacheSize);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxCacheSize; i++) &#123;</span><br><span class="line">            map.put(<span class="string">&quot;leavesC_&quot;</span> + i, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出结果是：leavesC_0 leavesC_1 leavesC_2 leavesC_3 leavesC_4</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line">        keySet.forEach(key -&gt; System.out.print(key + <span class="string">&quot; &quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取链表的头结点的值，使之移动到链表尾部</span></span><br><span class="line">        map.get(<span class="string">&quot;leavesC_0&quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        keySet = map.keySet();</span><br><span class="line">        <span class="comment">//输出结果是：//leavesC_1 leavesC_2 leavesC_3 leavesC_4 leavesC_0</span></span><br><span class="line">        keySet.forEach(key -&gt; System.out.print(key + <span class="string">&quot; &quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向链表添加元素，使用达到缓存的最大数量</span></span><br><span class="line">        map.put(<span class="string">&quot;leavesC_5&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//输出结果是：//leavesC_2 leavesC_3 leavesC_4 leavesC_0 leavesC_5</span></span><br><span class="line">        <span class="comment">//最近最少使用的元素 leavesC_1 被移除了</span></span><br><span class="line">        keySet.forEach(key -&gt; System.out.print(key + <span class="string">&quot; &quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><ul>
<li><p>结构特点</p>
<ul>
<li>键的数据结构是红黑树,可保证键的排序和唯一性</li>
<li>排序分为自然排序和比较器排序，如果使用的是自然排序,对元素有要求,要求这个元素需要实现 Comparable 接口</li>
<li>线程是不安全的效率比较高</li>
</ul>
</li>
<li><p>排序通过构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">()</span>: 自然排序</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> K&gt; comparator)</span>:  使用的是比较器排序</span><br></pre></td></tr></table></figure>
</li>
<li><p>何时用TreeMap</p>
<ul>
<li>HashMap不保证数据有序，LinkedHashMap保证数据可以保持插入顺序，而如果我们希望Map可以<strong>保持key的大小顺序</strong>的时候，我们就需要利用TreeMap了。</li>
</ul>
</li>
</ul>
<h2 id="TreeMap的构造函数和类成员变量"><a href="#TreeMap的构造函数和类成员变量" class="headerlink" title="TreeMap的构造函数和类成员变量"></a>TreeMap的构造函数和类成员变量</h2><ul>
<li><p>构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数。使用该构造函数，TreeMap中的元素按照自然排序进行排列。</span></span><br><span class="line">TreeMap()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建的TreeMap包含Map</span></span><br><span class="line">TreeMap(Map&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; copyFrom)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定Tree的比较器</span></span><br><span class="line">TreeMap(Comparator&lt;? <span class="built_in">super</span> K&gt; comparator)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建的TreeSet包含copyFrom</span></span><br><span class="line">TreeMap(SortedMap&lt;K, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; copyFrom)</span><br></pre></td></tr></table></figure>
</li>
<li><p>类成员变量</p>
<ul>
<li>我们可以看到 TreeMap 有一个 Entry 类型的 root 节点，而 Entry 则是 TreeMap 的内部类。</li>
<li>从 TreeMap.Entry 的属性我们可以知道其实一个红黑树节点的实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较器。根据这个比较器决定TreeMap的排序。</span></span><br><span class="line"><span class="comment">// 如果为空，表示按照key做自然排序（最小的在根节点）。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br><span class="line"><span class="comment">// 根节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"><span class="comment">// 大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// Node节点声明</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">color</span> <span class="operator">=</span> BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="TreeMap简单使用"><a href="#TreeMap简单使用" class="headerlink" title="TreeMap简单使用"></a>TreeMap简单使用</h2><h3 id="TreeMap-1"><a href="#TreeMap-1" class="headerlink" title="TreeMap&lt;String,String&gt;"></a>TreeMap&lt;String,String&gt;</h3><ul>
<li>TreeMap集合键是String值是String的案例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建集合对象</span></span><br><span class="line">TreeMap&lt;String, String&gt; tm = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建元素并添加元素</span></span><br><span class="line">tm.put(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;你好&quot;</span>);</span><br><span class="line">tm.put(<span class="string">&quot;world&quot;</span>, <span class="string">&quot;世界&quot;</span>);</span><br><span class="line">tm.put(<span class="string">&quot;java&quot;</span>, <span class="string">&quot;爪哇&quot;</span>);</span><br><span class="line">tm.put(<span class="string">&quot;world&quot;</span>, <span class="string">&quot;世界2&quot;</span>);</span><br><span class="line">tm.put(<span class="string">&quot;javaee&quot;</span>, <span class="string">&quot;爪哇EE&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历集合</span></span><br><span class="line"><span class="comment">// 获取键</span></span><br><span class="line">Set&lt;String&gt; set = tm.keySet();</span><br><span class="line"><span class="keyword">for</span> (String key : set) &#123;</span><br><span class="line">    <span class="comment">// 获取值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> tm.get(key);</span><br><span class="line">    System.out.println(key + <span class="string">&quot;---&quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line">hello---你好</span><br><span class="line">java---爪哇</span><br><span class="line">javaee---爪哇EE</span><br><span class="line">world---世界<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="TreeMap-2"><a href="#TreeMap-2" class="headerlink" title="TreeMap&lt;Student,String&gt;"></a>TreeMap&lt;Student,String&gt;</h3><ul>
<li><p>TreeMap集合键是Student值是String的案例,按照年龄大小进行排序,年龄相等根据名字排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建集合对象</span></span><br><span class="line">TreeMap&lt;Student, String&gt; tm = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Student, String&gt;(</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student s1, Student s2)</span> &#123;</span><br><span class="line">				<span class="comment">// 主要条件</span></span><br><span class="line">				<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> s1.getAge() - s2.getAge();</span><br><span class="line">				<span class="comment">// 次要条件</span></span><br><span class="line">				<span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> num == <span class="number">0</span> ? s1.getName().compareTo(</span><br><span class="line">						s2.getName()) : num;</span><br><span class="line">				<span class="keyword">return</span> num2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建学生对象</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;潘安&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;柳下惠&quot;</span>, <span class="number">35</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;唐伯虎&quot;</span>, <span class="number">33</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;燕青&quot;</span>, <span class="number">32</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;唐伯虎&quot;</span>, <span class="number">33</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储元素</span></span><br><span class="line">tm.put(s1, <span class="string">&quot;宋朝&quot;</span>);</span><br><span class="line">tm.put(s2, <span class="string">&quot;元朝&quot;</span>);</span><br><span class="line">tm.put(s3, <span class="string">&quot;明朝&quot;</span>);</span><br><span class="line">tm.put(s4, <span class="string">&quot;清朝&quot;</span>);</span><br><span class="line">tm.put(s5, <span class="string">&quot;汉朝&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line">Set&lt;Student&gt; set = tm.keySet();</span><br><span class="line"><span class="keyword">for</span> (Student key : set) &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> tm.get(key);</span><br><span class="line">	System.out.println(key.getName() + <span class="string">&quot;---&quot;</span> + key.getAge() + <span class="string">&quot;---&quot;</span></span><br><span class="line">			+ value);</span><br><span class="line">&#125;</span><br><span class="line">结果:</span><br><span class="line">	潘安---<span class="number">30</span>---宋朝</span><br><span class="line">	燕青---<span class="number">32</span>---清朝</span><br><span class="line">	唐伯虎---<span class="number">33</span>---汉朝</span><br><span class="line">	柳下惠---<span class="number">35</span>---元朝</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="获取字符串字母出现的次数"><a href="#获取字符串字母出现的次数" class="headerlink" title="获取字符串字母出现的次数"></a>获取字符串字母出现的次数</h3><ul>
<li><p>“aababcabcdabcde”，要求结果:a(5)b(4)c(3)d(2)e(1)</p>
</li>
<li><p>分析:</p>
<pre><code>1. 遍历字符串,获取每一个字符,然后将当前的字符作为键 , 上map集合中查找对应的值
</code></pre>
<ol start="2">
<li>如果返回的值不是null 对值进行+1 , 在把当前的元素作为键 , 值是+1以后的结果存储到集合中</li>
<li>如果返回的是是null , 不存在 , 就把当前遍历的元素作为键 , 1 作为值,添加到集合中</li>
</ol>
</li>
<li><p>代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;aababcabcdabcde&quot;</span> ;</span><br><span class="line">    <span class="comment">// 创建TreeMap集合对象</span></span><br><span class="line">    TreeMap&lt;Character , Integer&gt; tm = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Character , Integer&gt;() ;</span><br><span class="line">    <span class="comment">// 遍历字符串</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; s.length() ; x++) &#123;</span><br><span class="line">        <span class="comment">// 获取当前索引出对应的字符</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(x) ;</span><br><span class="line">        <span class="comment">// 找值</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> tm.get(ch) ;</span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="keyword">if</span>(value == <span class="literal">null</span>) &#123;</span><br><span class="line">            tm.put(ch, <span class="number">1</span>) ;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            value += <span class="number">1</span> ;</span><br><span class="line">            tm.put(ch, value) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历Map集合按照指定的形式拼接字符串</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>() ;</span><br><span class="line">    Set&lt;Entry&lt;Character,Integer&gt;&gt; entrySet = tm.entrySet() ;</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;Character,Integer&gt; en : entrySet) &#123;</span><br><span class="line">        <span class="comment">// 获取键</span></span><br><span class="line">        <span class="type">Character</span> <span class="variable">key</span> <span class="operator">=</span> en.getKey() ;</span><br><span class="line">        <span class="comment">// 获取值</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> en.getValue() ;</span><br><span class="line">        <span class="comment">// a(5)b(4)c(3)d(2)e(1)</span></span><br><span class="line">        <span class="comment">// 拼接</span></span><br><span class="line">        sb.append(key).append(<span class="string">&quot;(&quot;</span>).append(value).append(<span class="string">&quot;)&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把sb转换成String</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> sb.toString() ;</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="TreeMap方法源码"><a href="#TreeMap方法源码" class="headerlink" title="TreeMap方法源码"></a>TreeMap方法源码</h2><h3 id="put函数源码"><a href="#put函数源码" class="headerlink" title="put函数源码"></a>put函数源码</h3><ul>
<li><p>如果存在的话，old value被替换；如果不存在的话，则新添一个节点，然后对做红黑树的平衡操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, <span class="literal">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">// split comparator and comparable paths</span></span><br><span class="line">    Comparator&lt;? <span class="built_in">super</span> K&gt; cpr = comparator;</span><br><span class="line">        <span class="comment">// 如果该节点存在，则替换值直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果该节点未存在，则新建</span></span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 红黑树平衡调整</span></span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="get获取函数源码"><a href="#get获取函数源码" class="headerlink" title="get获取函数源码"></a>get获取函数源码</h3><ul>
<li><p>get函数则相对来说比较简单，以log(n)的复杂度进行get。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">getEntry</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="comment">// Offload comparator-based version for sake of performance</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">        <span class="comment">// 按照二叉树搜索的方式进行搜索，搜到返回</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> k.compareTo(p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">return</span> (p==<span class="literal">null</span> ? <span class="literal">null</span> : p.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="remove删除"><a href="#remove删除" class="headerlink" title="remove删除"></a>remove删除</h3><ul>
<li><p>TreeMap 的删除其实就是红黑树的删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> p.value;</span><br><span class="line">    deleteEntry(p);</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 1. 如果 p 有两个孩子节点，则找到后继节点，</span></span><br><span class="line"><span class="comment">     * 并把后继节点的值复制到节点 P 中，并让 p 指向其后继节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="literal">null</span> &amp;&amp; p.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; s = successor(p);</span><br><span class="line">        p.key = s.key;</span><br><span class="line">        p.value = s.value;</span><br><span class="line">        p = s;</span><br><span class="line">    &#125; <span class="comment">// p has 2 children</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start fixup at replacement node, if it exists.</span></span><br><span class="line">    Entry&lt;K,V&gt; replacement = (p.left != <span class="literal">null</span> ? p.left : p.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 2. 将 replacement parent 引用指向新的父节点，</span></span><br><span class="line"><span class="comment">         * 同时让新的父节点指向 replacement。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="literal">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">            p.parent.left  = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = replacement;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Null out links so they are OK to use by fixAfterDeletion.</span></span><br><span class="line">        p.left = p.right = p.parent = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 如果删除的节点 p 是黑色节点，则需要进行调整</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(replacement);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="literal">null</span>) &#123; <span class="comment">// 删除的是根节点，且树中当前只有一个节点</span></span><br><span class="line">        root = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 删除的节点没有孩子节点</span></span><br><span class="line">        <span class="comment">// p 是黑色，则需要进行调整</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(p);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 P 从树中移除</span></span><br><span class="line">        <span class="keyword">if</span> (p.parent != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">                p.parent.left = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</span><br><span class="line">                p.parent.right = <span class="literal">null</span>;</span><br><span class="line">            p.parent = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="keySet-遍历"><a href="#keySet-遍历" class="headerlink" title="keySet 遍历"></a>keySet 遍历</h3><ul>
<li><p>TreeMap 会从小到大输出键的值。那么，接下来就来分析一下keySet方法，以及在遍历 keySet 方法产生的集合时，TreeMap 是如何保证键的有序性的。</p>
<ul>
<li>核心代码还是 KeySet 类和 PrivateEntryIterator 类的 nextEntry方法。</li>
<li>在初始化 KeyIterator 时，默认情况下会将 TreeMap 中包含最小键或最大值（取决于传入的比较器）的 Entry 传给 PrivateEntryIterator。</li>
<li>当调用 nextEntry 方法时，通过调用 successor 方法找到当前 entry 的后继，并让 next 指向后继，最后返回当前的 entry。通过这种方式即可实现按正序返回键值的的逻辑。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> navigableKeySet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> NavigableSet&lt;K&gt; <span class="title function_">navigableKeySet</span><span class="params">()</span> &#123;</span><br><span class="line">    KeySet&lt;K&gt; nks = navigableKeySet;</span><br><span class="line">    <span class="keyword">return</span> (nks != <span class="literal">null</span>) ? nks : (navigableKeySet = <span class="keyword">new</span> <span class="title class_">KeySet</span>&lt;&gt;(<span class="built_in">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">KeySet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">NavigableSet</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NavigableMap&lt;E, ?&gt; m;</span><br><span class="line">    KeySet(NavigableMap&lt;E,?&gt; map) &#123; m = map; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (m <span class="keyword">instanceof</span> TreeMap)</span><br><span class="line">            <span class="keyword">return</span> ((TreeMap&lt;E,?&gt;)m).keyIterator();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> ((TreeMap.NavigableSubMap&lt;E,?&gt;)m).keyIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略非关键代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Iterator&lt;K&gt; <span class="title function_">keyIterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeyIterator</span>(getFirstEntry());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">KeyIterator</span> <span class="keyword">extends</span> <span class="title class_">PrivateEntryIterator</span>&lt;K&gt; &#123;</span><br><span class="line">    KeyIterator(Entry&lt;K,V&gt; first) &#123;</span><br><span class="line">        <span class="built_in">super</span>(first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextEntry().key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">PrivateEntryIterator</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    Entry&lt;K,V&gt; lastReturned;</span><br><span class="line">    <span class="type">int</span> expectedModCount;</span><br><span class="line"></span><br><span class="line">    PrivateEntryIterator(Entry&lt;K,V&gt; first) &#123;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        lastReturned = <span class="literal">null</span>;</span><br><span class="line">        next = first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">nextEntry</span><span class="params">()</span> &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        <span class="comment">// 寻找节点 e 的后继节点</span></span><br><span class="line">        next = successor(e);</span><br><span class="line">        lastReturned = e;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="TreeMap如何保证有序性"><a href="#TreeMap如何保证有序性" class="headerlink" title="TreeMap如何保证有序性"></a>TreeMap如何保证有序性</h2><ul>
<li><p>TreeMap是如何保证其迭代输出是有序的呢？</p>
<ul>
<li>其实从宏观上来讲，就相当于树的中序遍历(LDR)。我们先看一下迭代输出的步骤</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Entry&lt;Integer, String&gt; entry : tmap.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for语句会做如下转换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = tmap.entrySet().iterator() ; tmap.hasNext(); ) &#123;</span><br><span class="line">    Entry&lt;Integer, String&gt; entry = it.next();</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<strong>it.next()</strong>的调用中会使用<strong>nextEntry</strong>调用<code>successor</code>这个是过的后继的重点。</p>
</li>
<li><p>然后看一下successor函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; <span class="title function_">successor</span><span class="params">(Entry&lt;K,V&gt; t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 有右子树的节点，后继节点就是右子树的“最左节点”</span></span><br><span class="line">        <span class="comment">// 因为“最左子树”是右子树的最小节点</span></span><br><span class="line">        Entry&lt;K,V&gt; p = t.right;</span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="literal">null</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果右子树为空，则寻找当前节点所在左子树的第一个祖先节点</span></span><br><span class="line">        <span class="comment">// 因为左子树找完了，根据LDR该D了</span></span><br><span class="line">        Entry&lt;K,V&gt; p = t.parent;</span><br><span class="line">        Entry&lt;K,V&gt; ch = t;</span><br><span class="line">        <span class="comment">// 保证左子树</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; ch == p.right) &#123;</span><br><span class="line">            ch = p;</span><br><span class="line">            p = p.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>怎么理解这个successor呢？只要记住，这个是中序遍历就好了，L-D-R。具体细节如下：</p>
<ul>
<li><strong>a. 空节点，没有后继</strong></li>
<li><strong>b. 有右子树的节点，后继就是右子树的“最左节点”</strong></li>
<li><strong>c. 无右子树的节点，后继就是该节点所在左子树的第一个祖先节点</strong></li>
</ul>
</li>
<li><p>理解</p>
<ul>
<li><strong>有右子树的节点</strong>，节点的下一个节点，肯定在右子树中，而右子树中“最左”的那个节点则是右树中最小的一个，那么当然是<strong>右子树的“最左节点”</strong>，就好像下图所示：</li>
<li><img src= "/medias/detail/load.gif" data-lazy-src="/p/5b59a61f/9d1eea6b23b85458c0a0395053b1f7b4.png"></li>
<li><strong>无右子树的节点</strong>，先找到这个节点所在的左子树(右图)，那么这个节点所在的左子树的父节点(绿色节点)，就是下一个节点。</li>
<li><img src= "/medias/detail/load.gif" data-lazy-src="/p/5b59a61f/ec479e76d59cd63c9d07f55a1b94c190.png"></li>
</ul>
</li>
</ul>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="HashMap使用的弊端"><a href="#HashMap使用的弊端" class="headerlink" title="HashMap使用的弊端"></a>HashMap使用的弊端</h3><ul>
<li><p>HashMap是我们平时开发过程中用的比较多的集合，但它是非线程安全的，在涉及到多线程并发的情况，进行put操作有可能会引起死循环，导致CPU利用率接近100%。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            map.put(UUID.randomUUID().toString(), <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决方案有Hashtable和Collections.synchronizedMap(hashMap)，不过这两个方案基本上是对读写进行加锁操作，一个线程在读写元素，其余线程必须等待，性能可想而知。</p>
</li>
</ul>
<h2 id="ConcurrentHashMap底层知识点"><a href="#ConcurrentHashMap底层知识点" class="headerlink" title="ConcurrentHashMap底层知识点"></a>ConcurrentHashMap底层知识点</h2><ul>
<li><p>并发安全的ConcurrentHashMap，它的实现是依赖于 Java 内存模型，所以我们在了解 ConcurrentHashMap 的之前必须了解一些底层的知识：</p>
</li>
<li><p>1.java内存模型</p>
</li>
<li><p>2.java中的CAS</p>
</li>
<li><p>3.AbstractQueuedSynchronizer</p>
</li>
<li><p>4.ReentrantLock</p>
</li>
</ul>
<h2 id="ConcurrentHashMap-JDK-1-6和JDK1-8区分"><a href="#ConcurrentHashMap-JDK-1-6和JDK1-8区分" class="headerlink" title="ConcurrentHashMap JDK 1.6和JDK1.8区分"></a>ConcurrentHashMap JDK 1.6和JDK1.8区分</h2><h3 id="JDK1-6分析"><a href="#JDK1-6分析" class="headerlink" title="JDK1.6分析"></a>JDK1.6分析</h3><ul>
<li><p>ConcurrentHashMap采用 <strong>分段锁</strong>的机制，实现并发的更新操作，底层采用<strong>数组+链表+红黑树</strong>的存储结构。</p>
</li>
<li><p>其包含两个核心静态内部类 Segment和HashEntry。</p>
<ul>
<li>1.Segment继承ReentrantLock用来充当锁的角色，每个 Segment 对象守护每个散列映射表的若干个桶。</li>
<li>2.HashEntry 用来封装映射表的键 &#x2F; 值对；</li>
<li>3.每个桶是由若干个 HashEntry 对象链接起来的链表。</li>
</ul>
</li>
<li><p>一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组，下面我们通过一个图来演示一下 ConcurrentHashMap 的结构：</p>
<p> <img src= "/medias/detail/load.gif" data-lazy-src="/p/5b59a61f/9031fb446feb6b4d735dbf248c60ffec.png"></p>
</li>
</ul>
<h3 id="JDK1-8分析"><a href="#JDK1-8分析" class="headerlink" title="JDK1.8分析"></a>JDK1.8分析</h3><ul>
<li>1.8的实现已经抛弃了Segment分段锁机制，利用CAS+Synchronized来保证并发更新的安全，底层依然采用数组+链表+红黑树的存储结构。</li>
</ul>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/5b59a61f/ee28cba8e48d7c12b5905a3723a45fe3.png"></p>
<ul>
<li><p>概念介绍</p>
<ul>
<li><p><strong>table</strong>：默认为null，初始化发生在第一次插入操作，默认大小为16的数组，用来存储Node节点数据，扩容时大小总是2的幂次方。</p>
</li>
<li><p><strong>nextTable</strong>：默认为null，扩容时新生成的数组，其大小为原数组的两倍。</p>
</li>
<li><p>sizeCtl</p>
<ul>
<li>默认为0，用来控制table的初始化和扩容操作，具体应用在后续会体现出来。</li>
<li>**-1 **代表table正在初始化</li>
<li>**-N **表示有N-1个线程正在进行扩容操作</li>
<li>其余情况：<ul>
<li>如果table未初始化，表示table需要初始化的大小。</li>
<li>如果table初始化完成，表示table的容量，默认是table大小的0.75倍，居然用这个公式算0.75（n - (n &gt;&gt;&gt; 2)）。</li>
</ul>
</li>
</ul>
</li>
<li><p>Node</p>
<ul>
<li>保存key，value及key的hash值的数据结构。其中value和next都用volatile修饰，保证并发的可见性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line"> <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line"> <span class="keyword">final</span> K key;</span><br><span class="line"> <span class="keyword">volatile</span> V val;</span><br><span class="line"> <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line"> ... 省略部分代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ForwardingNode</p>
<ul>
<li>一个特殊的Node节点，hash值为-1，其中存储nextTable的引用。只有table发生扩容的时候，ForwardingNode才会发挥作用，作为一个占位符放在table中表示当前节点为null或则已经被移动。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">  ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">      <span class="built_in">super</span>(MOVED, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">      <span class="built_in">this</span>.nextTable = tab;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="ConcurrentHashMap原理"><a href="#ConcurrentHashMap原理" class="headerlink" title="ConcurrentHashMap原理"></a>ConcurrentHashMap原理</h2><h3 id="实例初始化-构造函数"><a href="#实例初始化-构造函数" class="headerlink" title="实例初始化 构造函数"></a>实例初始化 构造函数</h3><ul>
<li><p>实例化ConcurrentHashMap时带参数时，会根据参数调整table的大小，假设参数为100，最终会调整成256，确保table的大小总是2的幂次方，算法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, String&gt; hashMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> c - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意</strong></p>
<ul>
<li>ConcurrentHashMap在构造函数中只会初始化sizeCtl值，并不会直接初始化table，而是延缓到第一次put操作。</li>
</ul>
</li>
</ul>
<h3 id="table初始化-initTable"><a href="#table初始化-initTable" class="headerlink" title="table初始化 initTable()"></a>table初始化 initTable()</h3><ul>
<li><p>前面已经提到过，table初始化操作会延缓到第一次put行为。</p>
</li>
<li><p>但是put是可以并发执行的，Doug Lea是如何实现table只初始化一次的？让我们来看看源码的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果一个线程发现sizeCtl&lt;0，意味着另外的线程执行CAS操作成功，当前线程只需要让出cpu时间片</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.<span class="keyword">yield</span>(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>sizeCtl默认为0，如果ConcurrentHashMap实例化时有传参数，sizeCtl会是一个2的幂次方的值。</p>
<ul>
<li>所以执行第一次put操作的线程会执行Unsafe.compareAndSwapInt方法修改sizeCtl为-1，有且只有一个线程能够修改成功，其它线程通过Thread.yield()让出CPU时间片等待table初始化完成。</li>
</ul>
</li>
</ul>
<h3 id="put插入数据操作"><a href="#put插入数据操作" class="headerlink" title="put插入数据操作"></a>put插入数据操作</h3><ul>
<li><p>假设table已经初始化完成，put操作采用CAS+synchronized实现并发插入或更新操作，具体实现如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        ...省略部分代码</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>1.hash算法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">spread</span><span class="params">(<span class="type">int</span> h)</span> &#123;<span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.table中定位索引位置，n是table的大小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.获取table中对应索引的元素f。</p>
<ul>
<li>Doug Lea采用Unsafe.getObjectVolatile来获取，也许有人质疑，直接table[index]不可以么，为什么要这么复杂？</li>
<li>在java内存模型中，我们已经知道每个线程都有一个工作内存，里面存储着table的副本，虽然table是volatile修饰的，但不能保证线程每次都拿到table中的最新元素，Unsafe.getObjectVolatile可以直接获取指定内存的数据，保证了每次拿到数据都是最新的。</li>
</ul>
</li>
<li><p>4.如果f为null，说明table中这个位置第一次插入元素，利用Unsafe.compareAndSwapObject方法插入Node节点。</p>
<ul>
<li>如果CAS成功，说明Node节点已经插入，随后addCount(1L, binCount)方法会检查当前容量是否需要进行扩容。</li>
<li>如果CAS失败，说明有其它线程提前插入了节点，自旋重新尝试在这个位置插入节点。</li>
</ul>
</li>
<li><p>5.如果f的hash值为-1，说明当前f是ForwardingNode节点，意味有其它线程正在扩容，则一起进行扩容操作。</p>
</li>
<li><p>6.其余情况把新的Node节点按链表或红黑树的方式插入到合适的位置，这个过程采用同步内置锁实现并发，代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line"> <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">     <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">         binCount = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">             K ek;</span><br><span class="line">             <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                 ((ek = e.key) == key ||</span><br><span class="line">                  (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                 oldVal = e.val;</span><br><span class="line">                 <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                     e.val = value;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             Node&lt;K,V&gt; pred = e;</span><br><span class="line">             <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                 pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                           value, <span class="literal">null</span>);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">         Node&lt;K,V&gt; p;</span><br><span class="line">         binCount = <span class="number">2</span>;</span><br><span class="line">         <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                        value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">             oldVal = p.val;</span><br><span class="line">             <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                 p.val = value;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在节点f上进行同步，节点插入之前，再次利用tabAt(tab, i) &#x3D;&#x3D; f判断，防止被其它线程修改。<ul>
<li><ol>
<li>如果f.hash &gt;&#x3D; 0，说明f是链表结构的头结点，遍历链表，如果找到对应的node节点，则修改value，否则在链表尾部加入节点。</li>
</ol>
</li>
<li><ol start="2">
<li>如果f是TreeBin类型节点，说明f是红黑树根节点，则在树结构上遍历元素，更新或增加节点。</li>
</ol>
</li>
<li><ol start="3">
<li>如果链表中节点数binCount &gt;&#x3D; TREEIFY_THRESHOLD(默认是8)，则把链表转化为红黑树结构。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="table扩容"><a href="#table扩容" class="headerlink" title="table扩容"></a>table扩容</h3><ul>
<li><p>当table容量不足的时候，即table的元素数量达到容量阈值sizeCtl，需要对table进行扩容。</p>
</li>
<li><p>整个扩容分为两部分：</p>
<ol>
<li>构建一个nextTable，大小为table的两倍。</li>
<li>把table的数据复制到nextTable中。</li>
</ol>
</li>
<li><p>这两个过程在单线程下实现很简单，但是ConcurrentHashMap是支持并发插入的，扩容操作自然也会有并发的出现，这种情况下，第二步可以支持节点的并发复制，这样性能自然提升不少，但实现的复杂度也上升了一个台阶。</p>
</li>
<li><p>先看第一步，构建nextTable，毫无疑问，这个过程只能只有单个线程进行nextTable的初始化，具体实现如下：</p>
<ul>
<li>通过Unsafe.compareAndSwapInt修改sizeCtl值，保证只有一个线程能够初始化nextTable，扩容后的数组长度为原来的两倍，但是容量是原来的1.5。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addCount</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> check)</span> &#123;</span><br><span class="line">    ... 省略部分代码</span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="type">int</span> n, sc;</span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="type">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="literal">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>节点从table移动到nextTable，大体思想是遍历、复制的过程。</p>
<ol>
<li>首先根据运算得到需要遍历的次数i，然后利用tabAt方法获得i位置的元素f，初始化一个forwardNode实例fwd。</li>
<li>如果f &#x3D;&#x3D; null，则在table中的i位置放入fwd，这个过程是采用Unsafe.compareAndSwapObjectf方法实现的，很巧妙的实现了节点的并发移动。</li>
<li>如果f是链表的头节点，就构造一个反序链表，把他们分别放在nextTable的i和i+n的位置上，移动完成，采用Unsafe.putObjectVolatile方法给table原位置赋值fwd。</li>
<li>如果f是TreeBin节点，也做一个反序处理，并判断是否需要untreeify，把处理的结果分别放在nextTable的i和i+n的位置上，移动完成，同样采用Unsafe.putObjectVolatile方法给table原位置赋值fwd。</li>
</ol>
</li>
<li><p>遍历过所有的节点以后就完成了复制工作，把table指向nextTable，并更新sizeCtl为新数组大小的0.75倍 ，扩容完成。</p>
</li>
</ul>
<h3 id="红黑树构造"><a href="#红黑树构造" class="headerlink" title="红黑树构造"></a>红黑树构造</h3><p><strong>注意</strong>：如果链表结构中元素超过TREEIFY_THRESHOLD阈值，默认为8个，则把链表转化为红黑树，提高遍历查询效率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">        treeifyBin(tab, i);</span><br><span class="line">    <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接下来我们看看如何构造树结构，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; b; <span class="type">int</span> n, sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="literal">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                              <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="literal">null</span>)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    setTabAt(tab, index, <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，生成树节点的代码块是同步的，进入同步代码块之后，再次验证table中index位置元素是否被修改过。<br>1、根据table中index位置Node链表，重新生成一个hd为头结点的TreeNode链表。<br>2、根据hd头结点，生成TreeBin树结构，并把树结构的root节点写到table的index位置的内存中，具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">TreeBin(TreeNode&lt;K,V&gt; b) &#123;</span><br><span class="line">    <span class="built_in">super</span>(TREEBIN, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="built_in">this</span>.first = b;</span><br><span class="line">    TreeNode&lt;K,V&gt; r = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = b, next; x != <span class="literal">null</span>; x = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        x.left = x.right = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">            x.parent = <span class="literal">null</span>;</span><br><span class="line">            x.red = <span class="literal">false</span>;</span><br><span class="line">            r = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> x.key;</span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> x.hash;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = r;;) &#123;</span><br><span class="line">                <span class="type">int</span> dir, ph;</span><br><span class="line">                <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                    TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    r = balanceInsertion(r, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.root = r;</span><br><span class="line">    <span class="keyword">assert</span> <span class="title function_">checkInvariants</span><span class="params">(root)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要根据Node节点的hash值大小构建二叉树。这个红黑树的构造过程实在有点复杂，感兴趣的同学可以看看源码。</p>
<h3 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h3><p>get操作和put操作相比，显得简单了许多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>判断table是否为空，如果为空，直接返回null。</li>
<li>计算key的hash值，并获取指定table中指定位置的Node节点，通过遍历链表或则树结构找到对应的节点，返回value值。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ConcurrentHashMap 是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。相比于 HashTable 和同步包装器包装的 HashMap，使用一个全局的锁来同步不同线程间的并发访问，同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器，这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成串行化的了。</p>
<h2 id="集合嵌套"><a href="#集合嵌套" class="headerlink" title="集合嵌套"></a>集合嵌套</h2><h3 id="HashMap嵌套HashMap"><a href="#HashMap嵌套HashMap" class="headerlink" title="HashMap嵌套HashMap"></a>HashMap嵌套HashMap</h3><ul>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建大的集合对象</span></span><br><span class="line">    HashMap&lt;String , HashMap&lt;String , Integer&gt;&gt; czbkMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String , HashMap&lt;String , Integer&gt;&gt;() ;</span><br><span class="line">    <span class="comment">// 创建基础班的HashMap集合</span></span><br><span class="line">    HashMap&lt;String , Integer&gt; jcHashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String , Integer&gt;() ;</span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    jcHashMap.put(<span class="string">&quot;陈玉楼&quot;</span>, <span class="number">20</span>) ;</span><br><span class="line">    jcHashMap.put(<span class="string">&quot;高跃&quot;</span>, <span class="number">22</span>) ;</span><br><span class="line">    <span class="comment">// 把jcHashMap存储到czbkMap</span></span><br><span class="line">    czbkMap.put(<span class="string">&quot;jc&quot;</span>, jcHashMap) ;</span><br><span class="line">    <span class="comment">// 创建就业班的HashMap集合</span></span><br><span class="line">    HashMap&lt;String , Integer&gt; jyHashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String , Integer&gt;() ;</span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    jyHashMap.put(<span class="string">&quot;李杰&quot;</span>, <span class="number">21</span>) ;</span><br><span class="line">    jyHashMap.put(<span class="string">&quot;曹石磊&quot;</span>, <span class="number">23</span>) ;</span><br><span class="line">    <span class="comment">// 把jcHashMap存储到czbkMap</span></span><br><span class="line">    czbkMap.put(<span class="string">&quot;jy&quot;</span>, jyHashMap) ;</span><br><span class="line">    System.out.println(<span class="string">&quot;-------------------------------------------------------------------------------&quot;</span>);</span><br><span class="line">    <span class="comment">// HashMap&lt;String , HashMap&lt;String , Integer&gt;&gt; czbkMap = new HashMap&lt;String , HashMap&lt;String , Integer&gt;&gt;() ;</span></span><br><span class="line">    Set&lt;Entry&lt;String,HashMap&lt;String,Integer&gt;&gt;&gt; entrySet = czbkMap.entrySet() ;</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;String,HashMap&lt;String,Integer&gt;&gt; en : entrySet) &#123;</span><br><span class="line">        <span class="comment">// 获取键</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> en.getKey() ;</span><br><span class="line">        System.out.println(key);</span><br><span class="line">        <span class="comment">// 获取值</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; hashMap = en.getValue() ;</span><br><span class="line">        <span class="comment">// 遍历hashMap</span></span><br><span class="line">        Set&lt;String&gt; keySet = hashMap.keySet() ;</span><br><span class="line">        <span class="keyword">for</span>(String hashMapkey : keySet)&#123;</span><br><span class="line">            <span class="comment">// 根据键找值</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> hashMap.get(hashMapkey) ;</span><br><span class="line">            <span class="comment">// 输出</span></span><br><span class="line">            System.out.println(<span class="string">&quot;\t&quot;</span> + hashMapkey + <span class="string">&quot;\t&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 换行</span></span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="HashMap嵌套ArrayList"><a href="#HashMap嵌套ArrayList" class="headerlink" title="HashMap嵌套ArrayList"></a>HashMap嵌套ArrayList</h3><ul>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建大的集合对象</span></span><br><span class="line">    HashMap&lt;String , ArrayList&lt;String&gt;&gt; xiaoShuoMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String , ArrayList&lt;String&gt;&gt;() ;</span><br><span class="line">    <span class="comment">// 创建三国演义的List集合</span></span><br><span class="line">    ArrayList&lt;String&gt; sgList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;() ;</span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    sgList.add(<span class="string">&quot;吕布&quot;</span>) ;</span><br><span class="line">    sgList.add(<span class="string">&quot;周瑜&quot;</span>) ;</span><br><span class="line">    <span class="comment">// 把sgList添加到xiaoShuoMap中</span></span><br><span class="line">    xiaoShuoMap.put(<span class="string">&quot;三国演义&quot;</span>, sgList) ;</span><br><span class="line">    <span class="comment">// 创建笑傲江湖的List集合</span></span><br><span class="line">    ArrayList&lt;String&gt; xaList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;() ;</span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    xaList.add(<span class="string">&quot;林平之&quot;</span>) ;</span><br><span class="line">    xaList.add(<span class="string">&quot;令狐冲&quot;</span>) ;</span><br><span class="line">    <span class="comment">// 把sgList添加到xiaoShuoMap中</span></span><br><span class="line">    xiaoShuoMap.put(<span class="string">&quot;笑傲江湖&quot;</span>, xaList) ;</span><br><span class="line">    <span class="comment">// 创建神雕侠侣的List集合</span></span><br><span class="line">    ArrayList&lt;String&gt; sdList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;() ;</span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    sdList.add(<span class="string">&quot;杨过&quot;</span>) ;</span><br><span class="line">    sdList.add(<span class="string">&quot;郭靖&quot;</span>) ;</span><br><span class="line">    <span class="comment">// 把sgList添加到xiaoShuoMap中</span></span><br><span class="line">    xiaoShuoMap.put(<span class="string">&quot;神雕侠侣&quot;</span>, sdList) ;</span><br><span class="line">    <span class="comment">// HashMap&lt;String , ArrayList&lt;String&gt;&gt; xiaoShuoMap = new HashMap&lt;String , ArrayList&lt;String&gt;&gt;() ;</span></span><br><span class="line">    Set&lt;Entry&lt;String,ArrayList&lt;String&gt;&gt;&gt; entrySet = xiaoShuoMap.entrySet() ;</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;String,ArrayList&lt;String&gt;&gt; en : entrySet) &#123;</span><br><span class="line">        <span class="comment">// 获取键</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> en.getKey() ;</span><br><span class="line">        System.out.println(key);</span><br><span class="line">        <span class="comment">// 获取值</span></span><br><span class="line">        ArrayList&lt;String&gt; value = en.getValue() ;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span>(String name : value) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;\t&quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="ArrayList嵌套HashMap"><a href="#ArrayList嵌套HashMap" class="headerlink" title="ArrayList嵌套HashMap"></a>ArrayList嵌套HashMap</h3><ul>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建大的集合对象</span></span><br><span class="line">    ArrayList&lt;HashMap&lt;String , String&gt;&gt; al = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;HashMap&lt;String , String&gt;&gt;() ;</span><br><span class="line">    <span class="comment">// 创建小的HashMap集合</span></span><br><span class="line">    HashMap&lt;String , String&gt; sgHashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String , String&gt;() ;</span><br><span class="line">    HashMap&lt;String , String&gt; xaHashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String , String&gt;() ;</span><br><span class="line">    HashMap&lt;String , String&gt; sdHashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String , String&gt;() ;</span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    sgHashMap.put(<span class="string">&quot;吕布&quot;</span>, <span class="string">&quot;貂蝉&quot;</span>) ;</span><br><span class="line">    sgHashMap.put(<span class="string">&quot;周瑜&quot;</span>, <span class="string">&quot;小乔&quot;</span>) ;</span><br><span class="line">    xaHashMap.put(<span class="string">&quot;林平之&quot;</span>, <span class="string">&quot;岳灵珊&quot;</span>) ;</span><br><span class="line">    xaHashMap.put(<span class="string">&quot;令狐冲&quot;</span>, <span class="string">&quot;任盈盈&quot;</span>) ;</span><br><span class="line">    sdHashMap.put(<span class="string">&quot;郭靖&quot;</span>, <span class="string">&quot;黄蓉&quot;</span>) ;</span><br><span class="line">    sdHashMap.put(<span class="string">&quot;杨过&quot;</span>, <span class="string">&quot;小龙女&quot;</span>) ;</span><br><span class="line">    <span class="comment">// 把小的HashMap添加到al中</span></span><br><span class="line">    al.add(sgHashMap) ;</span><br><span class="line">    al.add(xaHashMap) ;</span><br><span class="line">    al.add(sdHashMap) ;</span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="comment">// ArrayList&lt;HashMap&lt;String , String&gt;&gt; al = new ArrayList&lt;HashMap&lt;String , String&gt;&gt;() ;</span></span><br><span class="line">    <span class="keyword">for</span>(HashMap&lt;String , String&gt; hm : al) &#123;</span><br><span class="line">        <span class="comment">// 根据键值对对象进行遍历</span></span><br><span class="line">        Set&lt;Entry&lt;String,String&gt;&gt; entrySet = hm.entrySet() ;</span><br><span class="line">        <span class="keyword">for</span>(Entry&lt;String,String&gt;  en : entrySet) &#123;</span><br><span class="line">            <span class="comment">// 获取键</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> en.getKey() ;</span><br><span class="line">            <span class="comment">// 获取值</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> en.getValue() ;</span><br><span class="line">            <span class="comment">// 输出</span></span><br><span class="line">            System.out.println(key + <span class="string">&quot;---&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://fulsun.github.io">凉月</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://fulsun.github.io/p/5b59a61f">https://fulsun.github.io/p/5b59a61f</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://fulsun.github.io" target="_blank">凉月の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/medias/featureimages/007.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/b781faed" title="队列接口与Stream流操作"><img class="cover" src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/006.jpg" onerror="onerror=null;src='/medias/detail/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">队列接口与Stream流操作</div></div></a></div><div class="next-post pull-right"><a href="/p/4f5e1515" title="Set集合"><img class="cover" src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/007.jpg" onerror="onerror=null;src='/medias/detail/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Set集合</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/avatar.jpg" onerror="this.onerror=null;this.src='/medias/detail/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">凉月</div><div class="author-info__description">记录生活,分享知识。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/fulsun"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/fulsun" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:fl_6145@163.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">感谢访问本站，若喜欢请收藏 ^_^</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Map%E6%8E%A5%E5%8F%A3"><span class="toc-text">Map接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map%E9%9B%86%E5%90%88%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-text">Map集合整体结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E6%A6%82%E8%BF%B0"><span class="toc-text">功能概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86"><span class="toc-text">Map集合遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E9%94%AE%E6%89%BE%E5%80%BC"><span class="toc-text">根据键找值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%A0%B9%E6%8D%AE%E9%94%AE%E5%80%BC%E5%AF%B9%E5%AF%B9%E8%B1%A1"><span class="toc-text">遍历根据键值对对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">迭代器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap"><span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-1"><span class="toc-text">HashMap&lt;String,String&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-2"><span class="toc-text">HashMap&lt;Integer,String&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-3"><span class="toc-text">HashMap&lt;String,Student&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-4"><span class="toc-text">HashMap&lt;Student,String&gt;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E5%8E%9F%E7%90%86"><span class="toc-text">HashMap原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-text">HashMap内部结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-text">HashMap底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">HashMap构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#put-K-key-V-value"><span class="toc-text">put(K key, V value)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get-Object-key"><span class="toc-text">get(Object key)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#remove-Object-key"><span class="toc-text">remove(Object key)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#resize-%E6%89%A9%E5%AE%B9"><span class="toc-text">resize()扩容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-text">Hash函数实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E9%87%8F%E5%92%8C%E8%A3%85%E8%BD%BD%E5%9B%A0%E5%AD%90"><span class="toc-text">容量和装载因子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashCode%E5%92%8Cequal"><span class="toc-text">hashCode和equal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E7%9A%84table%E4%B8%8B%E6%A0%87"><span class="toc-text">HashMap的table下标</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-text">Key为何需要不可变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E4%B8%BA%E5%95%A5%E8%A6%81%E6%89%A9%E5%AE%B9"><span class="toc-text">HashMap为啥要扩容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E6%89%A9%E5%AE%B9%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98"><span class="toc-text">HashMap扩容存在问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98"><span class="toc-text">HashMap线程问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E6%95%88%E7%8E%87"><span class="toc-text">HashMap效率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">HashMap性能分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashTable%E5%92%8CHashMap"><span class="toc-text">HashTable和HashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedHashMap"><span class="toc-text">LinkedHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashMap%E7%89%B9%E7%82%B9"><span class="toc-text">LinkedHashMap特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedHashMap%E7%9A%84Entry-%E8%8A%82%E7%82%B9%E7%B1%BB"><span class="toc-text">LinkedHashMap的Entry 节点类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedHashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0"><span class="toc-text">LinkedHashMap的实现函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#afterNodeAccess%E5%87%BD%E6%95%B0"><span class="toc-text">afterNodeAccess函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#afterNodeInsertion%E5%87%BD%E6%95%B0"><span class="toc-text">afterNodeInsertion函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#afterNodeRemoval%E5%87%BD%E6%95%B0"><span class="toc-text">afterNodeRemoval函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedHashMap%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">LinkedHashMap成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedHashMap%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">LinkedHashMap构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedHashMap%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81"><span class="toc-text">LinkedHashMap方法源码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#put%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0%E5%88%86%E6%9E%90"><span class="toc-text">put插入元素分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0"><span class="toc-text">get访问元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">移除元素源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LRUCache%E6%8B%93%E5%B1%95%E8%AE%AD%E7%BB%83"><span class="toc-text">LRUCache拓展训练</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeMap"><span class="toc-text">TreeMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeMap%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">TreeMap的构造函数和类成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeMap%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-text">TreeMap简单使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeMap-1"><span class="toc-text">TreeMap&lt;String,String&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeMap-2"><span class="toc-text">TreeMap&lt;Student,String&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AF%8D%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="toc-text">获取字符串字母出现的次数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeMap%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81"><span class="toc-text">TreeMap方法源码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#put%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81"><span class="toc-text">put函数源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81"><span class="toc-text">get获取函数源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#remove%E5%88%A0%E9%99%A4"><span class="toc-text">remove删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#keySet-%E9%81%8D%E5%8E%86"><span class="toc-text">keySet 遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeMap%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-text">TreeMap如何保证有序性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-text">ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E4%BD%BF%E7%94%A8%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-text">HashMap使用的弊端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-text">ConcurrentHashMap底层知识点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap-JDK-1-6%E5%92%8CJDK1-8%E5%8C%BA%E5%88%86"><span class="toc-text">ConcurrentHashMap JDK 1.6和JDK1.8区分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK1-6%E5%88%86%E6%9E%90"><span class="toc-text">JDK1.6分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK1-8%E5%88%86%E6%9E%90"><span class="toc-text">JDK1.8分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap%E5%8E%9F%E7%90%86"><span class="toc-text">ConcurrentHashMap原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">实例初始化 构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#table%E5%88%9D%E5%A7%8B%E5%8C%96-initTable"><span class="toc-text">table初始化 initTable()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#put%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C"><span class="toc-text">put插入数据操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#table%E6%89%A9%E5%AE%B9"><span class="toc-text">table扩容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E6%9E%84%E9%80%A0"><span class="toc-text">红黑树构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get%E6%93%8D%E4%BD%9C"><span class="toc-text">get操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%B5%8C%E5%A5%97"><span class="toc-text">集合嵌套</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E5%B5%8C%E5%A5%97HashMap"><span class="toc-text">HashMap嵌套HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E5%B5%8C%E5%A5%97ArrayList"><span class="toc-text">HashMap嵌套ArrayList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E5%B5%8C%E5%A5%97HashMap"><span class="toc-text">ArrayList嵌套HashMap</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/p/94e3914c" title="Import 注册组件"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/008.jpg" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Import 注册组件"/></a><div class="content"><a class="title" href="/p/94e3914c" title="Import 注册组件">Import 注册组件</a><time datetime="2024-07-15T22:24:08.000Z" title="发表于 2024-07-15 22:24:08">2024-07-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/a0c53761" title="Configuration Bean 注册组件"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/012.jpg" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Configuration Bean 注册组件"/></a><div class="content"><a class="title" href="/p/a0c53761" title="Configuration Bean 注册组件">Configuration Bean 注册组件</a><time datetime="2024-07-15T21:24:08.000Z" title="发表于 2024-07-15 21:24:08">2024-07-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/65826306" title="Spring5新功能"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/008.jpg" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Spring5新功能"/></a><div class="content"><a class="title" href="/p/65826306" title="Spring5新功能">Spring5新功能</a><time datetime="2024-07-14T17:24:08.000Z" title="发表于 2024-07-14 17:24:08">2024-07-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/40bb048a" title="JdbcTemplate与声明式事务"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/013.jpg" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="JdbcTemplate与声明式事务"/></a><div class="content"><a class="title" href="/p/40bb048a" title="JdbcTemplate与声明式事务">JdbcTemplate与声明式事务</a><time datetime="2024-07-14T11:24:08.000Z" title="发表于 2024-07-14 11:24:08">2024-07-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/92933cdb" title="Spring-AOP编程"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/012.jpg" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Spring-AOP编程"/></a><div class="content"><a class="title" href="/p/92933cdb" title="Spring-AOP编程">Spring-AOP编程</a><time datetime="2024-07-14T09:24:38.000Z" title="发表于 2024-07-14 09:24:38">2024-07-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 凉月</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://unpkg.com/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.js"></script><script src="https://unpkg.com/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null

  const initWaline = (Fn) => {
    const waline = Fn(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-fulsun.netlify.app/.netlify/functions/comment',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))

    const destroyWaline = () => {
      waline.destroy()
    }

    btf.addGlobalFn('pjax', destroyWaline, 'destroyWaline')
  }

  const loadWaline = async () => {
    if (initFn) initWaline(initFn)
    else {
      await getCSS('https://unpkg.com/@waline/client@3.1.2/dist/waline.css')
      const { init } = await import('https://unpkg.com/@waline/client@3.1.2/dist/waline.js')
      initFn = init || Waline.init
      initWaline(initFn)
      window.walineFn = initFn
    }
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://unpkg.com/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>