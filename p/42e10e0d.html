<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>final,深浅拷贝,类的关系，正则和常用类 | 凉月の博客</title><meta name="author" content="凉月"><meta name="copyright" content="凉月"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java面向对象">
<meta property="og:type" content="article">
<meta property="og:title" content="final,深浅拷贝,类的关系，正则和常用类">
<meta property="og:url" content="https://fulsun.github.io/p/42e10e0d">
<meta property="og:site_name" content="凉月の博客">
<meta property="og:description" content="Java面向对象">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fulsun.github.io/medias/featureimages/012.jpg">
<meta property="article:published_time" content="2018-08-08T01:08:28.000Z">
<meta property="article:modified_time" content="2024-10-17T07:06:55.386Z">
<meta property="article:author" content="凉月">
<meta property="article:tag" content="凉月">
<meta property="article:tag" content="凉月文">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="web网站">
<meta property="article:tag" content="经验分享">
<meta property="article:tag" content="hexo">
<meta property="article:tag" content="个人博客">
<meta property="article:tag" content="生活记录等">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fulsun.github.io/medias/featureimages/012.jpg"><link rel="shortcut icon" href="/medias/favicon.png"><link rel="canonical" href="https://fulsun.github.io/p/42e10e0d"><link rel="preconnect" href="//unpkg.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"至上次更新后的","messageNext":"天,文章内容可能已过时。"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 凉月","link":"链接: ","source":"来源: 凉月の博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://unpkg.com/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'final,深浅拷贝,类的关系，正则和常用类',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-17 07:06:55'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/avatar.jpg" onerror="onerror=null;src='/medias/detail/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-heartbeat"></i><span> 我的</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> 联系</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user-circle"></i><span> 博主</span></a></li><li><a class="site-page child" href="/contact"><i class="fa-fw fas fa-comments"></i><span> 留言</span></a></li><li><a class="site-page child" href="/journal"><i class="fa-fw fas fa-cogs"></i><span> 日志</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> JS动画</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/snake/"><i class="fa-fw fas fa-gamepad"></i><span> 贪吃蛇</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/medias/featureimages/012.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="凉月の博客"><span class="site-name">凉月の博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-heartbeat"></i><span> 我的</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> 联系</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user-circle"></i><span> 博主</span></a></li><li><a class="site-page child" href="/contact"><i class="fa-fw fas fa-comments"></i><span> 留言</span></a></li><li><a class="site-page child" href="/journal"><i class="fa-fw fas fa-cogs"></i><span> 日志</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> JS动画</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/snake/"><i class="fa-fw fas fa-gamepad"></i><span> 贪吃蛇</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">final,深浅拷贝,类的关系，正则和常用类</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2018-08-08T01:08:28.000Z" title="发表于 2018-08-08 01:08:28">2018-08-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-17T07:06:55.386Z" title="更新于 2024-10-17 07:06:55">2024-10-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JavaSE/">JavaSE</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>61分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="final,深浅拷贝,类的关系，正则和常用类"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><span id="more"></span>

<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><ul>
<li>final 变量定义：<ul>
<li>自定义常量： 如PI,<ul>
<li><code>final 数据类型 变量名 =值</code></li>
<li>常量的变量名大写 ，多个单词用_连接</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li><strong>A:为什么会有final</strong><ul>
<li>由于继承中有一个方法重写的现象,而有时候我们不想让子类去重写父类的方法.这对这种情况java就给我们提供了一个关键字: final</li>
</ul>
</li>
<li><strong>B:final概述</strong><ul>
<li>final关键字是最终的意思，可以修饰类，变量，成员方法。</li>
</ul>
</li>
<li><strong>C:final修饰特点</strong><ul>
<li>修饰类: 被修饰类不能被继承</li>
<li>修饰方法: 被修饰的方法不能被重写</li>
<li>修饰变量: 被修饰的变量不能被重新赋值,因为这个量其实是一个常量</li>
</ul>
</li>
<li>**D:final关键字修饰局部变量 **<ul>
<li>基本类型，是值不能被改变</li>
<li>引用类型，是地址值不能被改变</li>
</ul>
</li>
</ul>
<h3 id="final，finally，finalize有什么不同？"><a href="#final，finally，finalize有什么不同？" class="headerlink" title="final，finally，finalize有什么不同？"></a>final，finally，finalize有什么不同？</h3><ul>
<li><strong>final可以修饰类，方法，变量</strong><ul>
<li>final修饰类代表类不可以继承拓展</li>
<li>final修饰变量表示变量不可以修改</li>
<li>final修饰方法表示方法不可以被重写</li>
</ul>
</li>
<li><strong>finally则是Java保证重点代码一定要被执行的一种机制</strong><ul>
<li>可以使用 try-finally 或者 try-catch-finally 来进行类似关闭 JDBC连接、保证 unlock 锁等动作。</li>
<li><strong>在以下4种特殊情况下，finally块不会被执行：</strong> 1. 在finally语句块中发生了异常。2. 在前面的代码中用了System.exit()退出程序。3. 程序所在的线程死亡。4. 关闭CPU。</li>
</ul>
</li>
<li><strong>finalize 是基础类 java.lang.Object的一个方法</strong><ul>
<li>它的设计目的是保证对象在<strong>被垃圾收集前</strong>完成特定资源的回收。finalize 机制现在已经不推荐使用，并且在 JDK 9开始被标记为 deprecated。</li>
</ul>
</li>
</ul>
<h3 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h3><ul>
<li>可以将方法或者类声明为 final，这样就可以明确告知别人，这些行为是不许修改的。</li>
<li>如果你关注过 Java 核心类库的定义或源码， 有没有发现java.lang 包下面的很多类，相当一部分都被声明成为final class？在第三方类库的一些基础类中同样如此，这可以有效避免 API 使用者更改基础功能，某种程度上，这是保证平台安全的必要手段。</li>
<li>使用 final 修饰参数或者变量，也可以清楚地避免意外赋值导致的编程错误，甚至，有人明确推荐将所有方法参数、本地变量、成员变量声明成 final。</li>
<li>final 变量产生了某种程度的不可变（immutable）的效果，所以，可以用于保护只读数据，尤其是在并发编程中，因为明确地不能再赋值 final 变量，有利于减少额外的同步开销，也可以省去一些防御性拷贝的必要。</li>
</ul>
<h2 id="Objecg类"><a href="#Objecg类" class="headerlink" title="Objecg类"></a>Objecg类</h2><ul>
<li>java.lang包下，是所有类的父类</li>
</ul>
<h3 id="公用方法"><a href="#公用方法" class="headerlink" title="公用方法"></a>公用方法</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>System.gc();</td>
<td>强制垃圾回收(只是通知)</td>
</tr>
<tr>
<td>finalize();</td>
<td>回收之前调用的方法,需要在对象的类中重写，该方法中的this表示回收的垃圾对象</td>
</tr>
<tr>
<td>equals()</td>
<td>比较对象地址值是否相等</td>
</tr>
<tr>
<td>clone()</td>
<td>克隆一个新的对象</td>
</tr>
<tr>
<td>toString()</td>
<td>返回对象的字符串形式</td>
</tr>
<tr>
<td>getClass()</td>
<td>返回和当前对象相关的Class对象.getName 获取对象的类型</td>
</tr>
<tr>
<td>hashCode()</td>
<td>获取对象的哈希值，用于equeal比较，建议重写</td>
</tr>
<tr>
<td>notify,notifyall,wait</td>
<td>用来对给定对象进行线程同步的</td>
</tr>
</tbody></table>
<h2 id="Java-拷贝"><a href="#Java-拷贝" class="headerlink" title="Java 拷贝"></a>Java 拷贝</h2><ul>
<li><p>java的赋值都是传值的，对于基础类型来说，会拷贝具体的内容，但是对于引用对象来说，存储的这个值只是指向实际对象的地址，拷贝也只会拷贝引用地址。</p>
</li>
<li><p>java中所有的对象都是继承自<code>java.lang.Object</code>。Object对象中提供了一个clone方法，来供我们对java对象进行拷贝。<code>protected native Object clone() throws CloneNotSupportedException;</code></p>
<ul>
<li><p>方法是native的，所以不需要我们来实现</p>
</li>
<li><p>clone方法还是protected，这意味着clone方法只能在<code>java.lang</code>包或者<code>其子类</code>可见。</p>
</li>
<li><p>如果我们想要在一个程序中调用某个对象的clone方法则是不可以的。因为clone方法是定义在Object中的，该对象并没有对外可见的clone方法。</p>
</li>
<li><p>JDK的建议是让我们去实现接口Cloneable，实现了这个接口就表示这个对象可以调用Object的clone方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cloneable是空的，明没有强制要你去实现clone方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>clone</code>只是对象的拷贝，它只是简单的拷贝对象，而不会去执行对象的构造函数。clone会导致浅拷贝的问题。</p>
</li>
</ul>
</li>
<li><p>根据对对象属性的拷贝程度（基本数据类和引用类型），会分为两种：</p>
<ul>
<li>浅拷贝 (<code>Shallow Copy</code>)</li>
<li>深拷贝 (<code>Deep Copy</code>)</li>
</ul>
</li>
</ul>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><ul>
<li>只是增加了一个指针指向已存在的内存地址<ul>
<li>基本类型，拷贝的就是基本类型的值；</li>
<li>如果属性是内存地址（引用类型），拷贝的就是内存地址，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。</li>
<li>即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。</li>
</ul>
</li>
</ul>
<h4 id="浅拷贝的实现"><a href="#浅拷贝的实现" class="headerlink" title="浅拷贝的实现"></a>浅拷贝的实现</h4><ul>
<li><p>实现对象拷贝的类，需要实现 <code>Cloneable</code> 接口，并覆写 <code>clone()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">      <span class="comment">//引用类型</span></span><br><span class="line">      <span class="keyword">private</span> Teacher teacher;</span><br><span class="line">      <span class="comment">//基础数据类型</span></span><br><span class="line">      <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">public</span> Teacher <span class="title function_">getTeacher</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> teacher;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTeacher</span><span class="params">(Teacher teacher)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.teacher = teacher;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> name;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.name = name;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 浅拷贝:直接调用父类的clone()方法</span></span><br><span class="line">              <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;[Student: &quot;</span> + <span class="built_in">this</span>.hashCode()</span><br><span class="line">                  + <span class="string">&quot;,Teacher:&quot;</span> + <span class="built_in">this</span>.getTeacher() + <span class="string">&quot;:&quot;</span></span><br><span class="line">                  + <span class="built_in">this</span>.getTeacher().getName()</span><br><span class="line">                  + <span class="string">&quot;,name:&quot;</span> + <span class="built_in">this</span>.getName() + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> name;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">(String name)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.name = name;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">- 测试clone结果</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Student</span> <span class="variable">studentA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">      studentA.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">      studentA.setTeacher(<span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;老师1&quot;</span>));</span><br><span class="line">      <span class="comment">//克隆</span></span><br><span class="line">      <span class="type">Student</span> <span class="variable">studentB</span> <span class="operator">=</span> (Student) studentA.clone();</span><br><span class="line">      studentB.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;studentA:&quot;</span> + studentA.toString());</span><br><span class="line">      System.out.println(<span class="string">&quot;studentB:&quot;</span> + studentB.toString());</span><br><span class="line">      <span class="comment">// 修改引用数据类型</span></span><br><span class="line">      studentA.getTeacher().setName(<span class="string">&quot;张老师&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;studentB:&quot;</span> + studentB.toString());</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  studentA:[Student: <span class="number">1531448569</span>,Teacher:pers.fulsun.Teacher@1e80bfe8:老师<span class="number">1</span>,name:张三]</span><br><span class="line">  studentB:[Student: <span class="number">1198108795</span>,Teacher:pers.fulsun.Teacher@1e80bfe8:老师<span class="number">1</span>,name:李四]</span><br><span class="line">  studentB:[Student: <span class="number">1198108795</span>,Teacher:pers.fulsun.Teacher@1e80bfe8:张老师,name:李四]</span><br><span class="line">  </span><br><span class="line">  - 输出的结果可见，通过 `studentA.clone()` 拷贝对象后得到的 `studentB`，和 `studentA` 是两个不同的对象。</span><br><span class="line">  - `studentA` 和 `studentB` 的基础数据类型的修改互不影响，而引用类型 `subject` 修改后是会有影响的。</span><br><span class="line">  - 对于基本数据类型的成员对象，因为基础数据类型是值传递的，所以是直接将属性值赋值给新的对象。基础类型的拷贝，其中一个对象修改该值，不会影响另外一个。</span><br><span class="line">  - 对于引用类型，比如数组或者类对象，因为引用类型是引用传递，所以浅拷贝只是把内存地址赋值给了成员变量，它们指向了同一内存空间。改变其中一个，会对另外一个也产生影响。</span><br><span class="line"></span><br><span class="line">### 深拷贝</span><br><span class="line"></span><br><span class="line">- 可以看到，浅拷贝会带来数据安全方面的隐患，例如我们只是想修改了 `studentA` 的 `name`，但是 `studentB` 的 `name` 也被修改了，因为它们都是指向的同一个地址。所以，此种情况下，我们需要用到深拷贝。</span><br><span class="line"></span><br><span class="line">- 深拷贝，**在拷贝引用类型成员变量时，为引用类型的数据成员另辟了一个独立的内存空间**，实现真正内容上的拷贝。</span><br><span class="line"></span><br><span class="line">#### 深拷贝特点</span><br><span class="line"></span><br><span class="line">- 对于基本数据类型的成员对象，因为基础数据类型是值传递的，所以是直接将属性值赋值给新的对象。</span><br><span class="line">  - 基础类型的拷贝，其中一个对象修改该值，不会影响另外一个（和浅拷贝一样）。</span><br><span class="line">- 对于引用类型，比如数组或者类对象，深拷贝会新建一个对象空间，然后拷贝里面的内容，所以它们指向了不同的内存空间。</span><br><span class="line">  - 改变其中一个，不会对另外一个也产生影响。</span><br><span class="line">- 对于有多层对象的，每个对象都需要实现 `Cloneable` 并重写 `clone()` 方法，进而实现了对象的串行层层拷贝。</span><br><span class="line">- 深拷贝相比于浅拷贝速度较慢并且花销较大。</span><br><span class="line"></span><br><span class="line">#### 拷贝的实现</span><br><span class="line"></span><br><span class="line">- 在 `Student` 的 `clone()` 方法中，需要拿到拷贝自己后产生的新的对象，然后对新的对象的引用类型再调用拷贝操作，实现对引用类型成员变量的深拷贝。</span><br><span class="line"></span><br><span class="line">- 对于 `Student` 的引用类型的成员变量 `Teacher` ，需要实现 `Cloneable` 并重写 `clone()` 方法。</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">      <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> name;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.name = name;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">(String name)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.name = name;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">          <span class="comment">//如果也有引用类型的成员属性，也应该和 Student 类一样实现</span></span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写clone()方法，对克隆对象的应用对象进行克隆</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 浅拷贝:直接调用父类的clone()方法</span></span><br><span class="line">            <span class="type">Student</span> <span class="variable">clone</span> <span class="operator">=</span> (Student) <span class="built_in">super</span>.clone();</span><br><span class="line">            <span class="comment">// 对新的对象的引用类型再调用拷贝操作</span></span><br><span class="line">            clone.teacher = (Teacher) teacher.clone();</span><br><span class="line">            <span class="keyword">return</span> clone;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><ul>
<li><p><strong>String类的一些特性</strong></p>
<ul>
<li>String 类代表字符串。Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。</li>
<li>字符串是常量；它们的<strong>值在创建之后不能更改</strong>。字符串缓冲区支持可变的字符串。因为 String 对象是不可变的，所以可以共享。</li>
<li>Java 语言提供对字符串串联符号（”+”）以及将其他对象转换为字符串的特殊支持。字符串串联是通过 StringBuilder（或 StringBuffer）类及其 append 方法实现的。</li>
<li>字符串相加：多个常量相加没有性能问题，在编译期就优化了, <strong>常量相加，是先加，然后在常量池找，如果有就直接返回，否则，就创建。</strong></li>
<li>变量与常量相加，会产生多个垃圾对象，<strong>变量相加，先开空间，在拼接。</strong></li>
<li>String 的演化，Java 9 中底层把 char 数组换成了 byte 数组，占用更少的空间</li>
</ul>
</li>
<li><p><strong>一旦被创建就不能改变</strong>，这样设计有很多好处，比如可以缓存hashcode、使用更加便利以及更加安全等。</p>
<ul>
<li><p>在JVM里，考虑到垃圾回收（Garbage Collection）的方便，将heap(堆)划分为三部分：young generation(新生代)、tenured generation （old generation）（旧生代）、permanent generation（永生代）。String字符串缓存 intern()方法，由永久代移到堆中。</p>
</li>
<li><p>字符串为了解决字符串重复问题，生命周期长，存于pergmen中。</p>
</li>
<li><p>String直接赋值和使用new的区别</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(“hello”);</span><br><span class="line"><span class="comment">// 至少创建一个对象，也可能两个。</span></span><br><span class="line">	<span class="comment">// 因为用到new关键字，肯定会在heap中创建一个str2的String对象，它的value是“ABC”。</span></span><br><span class="line">    <span class="comment">// 同时如果这个字符串在java String池里不存在，会在java池里创建这个String对象“ABC”。</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> “hello”;</span><br><span class="line"><span class="comment">// 可能创建一个或者不创建对象</span></span><br><span class="line"><span class="comment">// 如果”ABC”这个字符串在java String池里不存在，会在JVM的字符串池里]创建一个String对象(“ABC”)，然后str1指向这个内存地址</span></span><br><span class="line"><span class="comment">// 无论以后用这种方式创建多少个值为”ABC”的字符串对象，始终只有一个内存地址被分配，之后的都是String的拷贝，Java中称为“字符串驻留”，所有的字符串常量都会在编译之后自动地驻留。</span></span><br></pre></td></tr></table></figure>

<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/42e10e0d/d3129dbdd2a94a832be7f3ce7aaca991.png"></p>
</li>
<li><p>String的特点一旦被创建就不能改变【内容不能变，引用可以变】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s1.equals(s2));<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意： 创建不能给是指内容不能变</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span> ;</span><br><span class="line">    <span class="comment">// 其实堆中存在 &quot;hello&quot; &quot;world&quot; &quot;worldjava&quot; 三个字符串</span></span><br><span class="line">    <span class="comment">// 这里将s的引用指向了&quot;worldjava&quot;字符串</span></span><br><span class="line">    s =  <span class="string">&quot;world&quot;</span> + <span class="string">&quot;java&quot;</span>;</span><br><span class="line">    System.out.println(s); <span class="comment">// worldjava</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><h4 id="使用-拼接"><a href="#使用-拼接" class="headerlink" title="使用+拼接"></a>使用<code>+</code>拼接</h4><ul>
<li><p>在Java中，拼接字符串最简单的方式就是直接使用符号<code>+</code>来拼接。String字符串拼接通过StringBuilder走中间过程，通过append方法实现。null拼接会变成字符串”null”，程序有大量字符串拼接时，建议考虑直接写StringBuilder实现，就不需要底层new很多临时sb对象了</p>
</li>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">msg2</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">hollis</span> <span class="operator">=</span> msg + <span class="string">&quot;,&quot;</span> + msg2;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里要特别说明一点，有人把Java中使用<code>+</code>拼接字符串的功能理解为<strong>运算符重载</strong>。</p>
<ul>
<li>其实并不是，<strong>Java是不支持运算符重载的</strong>。这其实只是Java提供的一个<strong>语法糖</strong>。</li>
</ul>
</li>
<li><p>运算符重载：</p>
<ul>
<li>在计算机程序设计中，运算符重载（英语：operator overloading）是多态的一种。运算符重载，就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。</li>
</ul>
</li>
<li><p>语法糖：</p>
<ul>
<li>语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·兰丁发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能没有影响，但是更方便程序员使用。语法糖让程序更加简洁，有更高的可读性。</li>
</ul>
</li>
<li><p><strong>问答题</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">下面这条语句一共创建了多少个对象:String s = “a”+“b”+”c”; 分别都是什么？</span><br><span class="line">答案：5个对象</span><br><span class="line">分别是 &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , &quot;ab&quot; , &quot;abc&quot;</span><br><span class="line">因为字符串的特点是一旦被创建就不能被改变,所有在使用常量进行相加的时候,都是在创建新的字符串对象</span><br><span class="line">最后在把字符串&quot;abc&quot;这个常量值赋值给引用变量s</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码输出的结果是：”111111222222”，但是它工作原理是怎样的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;111111&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;222222&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> str1 + str2;</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>其真正实现的原理是中间通过建立临时的StringBuilder对象，然后调用append方法实现</strong>。如何验证呢？<br>上述代码文件写在Test.java main方法中，使用<b>javac Test.java</b>编译，在执行<b>javap -verbose Test</b>，可以看到如下信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String 111111</span></span><br><span class="line"><span class="number">2</span>: astore_1</span><br><span class="line"><span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String 222222</span></span><br><span class="line"><span class="number">5</span>: astore_2</span><br><span class="line"><span class="number">6</span>: <span class="keyword">new</span>           #<span class="number">4</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line"><span class="number">9</span>: dup</span><br><span class="line"><span class="number">10</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&quot;:()V</span></span><br><span class="line"><span class="number">13</span>: aload_1</span><br><span class="line"><span class="number">14</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line"><span class="number">17</span>: aload_2</span><br><span class="line"><span class="number">18</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line"><span class="number">21</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line"><span class="number">24</span>: astore_3</span><br><span class="line"><span class="number">25</span>: getstatic     #<span class="number">8</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"><span class="number">28</span>: aload_3</span><br><span class="line"><span class="number">29</span>: invokevirtual #<span class="number">9</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line"><span class="number">32</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于java来说，这段代码原理上应该是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;111111&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;222222&quot;</span>;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">sb.append(str1);</span><br><span class="line">sb.append(str2);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="NULL-拼接"><a href="#NULL-拼接" class="headerlink" title="NULL+拼接"></a>NULL+拼接</h4><ul>
<li><p>如下代码的执行结果是什么？是报错，还是”null222222”  正确答案是：”null222222”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;222222&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> str1 + str2;</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码原理如下所示</p>
<ul>
<li><p>这段代码，StringBuilder对象append一个null字符串会怎么处理呢，这就要去查看源码了。</p>
</li>
<li><p>然后看super.append(sb)，该方法继承了父类的方法，父类为AbstractStringBuilder，再去父类中查看append方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    sb.append(str1 );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> StringBuilder <span class="title function_">append</span><span class="params">(StringBuffer sb)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.append(sb);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//看AbstractStringBuilder类中append方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(CharSequence s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="keyword">if</span> (s <span class="keyword">instanceof</span> String)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.append((String)s);</span><br><span class="line">        <span class="keyword">if</span> (s <span class="keyword">instanceof</span> AbstractStringBuilder)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.append((AbstractStringBuilder)s);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.append(s, <span class="number">0</span>, s.length());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> AbstractStringBuilder <span class="title function_">appendNull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> count;</span><br><span class="line">        ensureCapacityInternal(c + <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">char</span>[] value = <span class="built_in">this</span>.value;</span><br><span class="line">        value[c++] = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">        value[c++] = <span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">        value[c++] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">        value[c++] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">        count = c;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 使用concat拼接</span><br><span class="line"></span><br><span class="line">- 除了使用`+`拼接字符串之外，还可以使用String类中的方法concat方法来拼接字符串。如：</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="type">String</span> <span class="variable">country</span> <span class="operator">=</span> <span class="string">&quot;china&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">city</span> <span class="operator">=</span> <span class="string">&quot;Shanghai&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> country.concat(<span class="string">&quot;,&quot;</span>).concat(city);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="创建机理"><a href="#创建机理" class="headerlink" title="创建机理"></a>创建机理</h3><ul>
<li><p>由于String在Java世界中使用过于频繁，Java为了避免在一个系统中产生大量的String对象，引入了字符串常量池。</p>
</li>
<li><p>其运行机制是：创建一个字符串时，首先检查池中是否有值相同的字符串对象</p>
<ul>
<li>如果有则不需要创建直接从池中刚查找到的对象引用；</li>
<li>如果没有则新建字符串对象，返回对象引用，并且将新创建的对象放入池中。</li>
</ul>
</li>
<li><p>但是，通过new方法创建的String对象是不检查字符串池的，而是直接在堆区或栈区创建一个新的对象，也不会把对象放入池中。</p>
</li>
<li><p>上述原则只适用于通过直接量给String对象引用赋值的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>; <span class="comment">//通过直接量赋值方式，放入字符串常量池</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(“<span class="number">123</span>”);<span class="comment">//通过new方式赋值方式，不放入字符串常量池</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>String提供了inter()方法。调用该方法时，如果常量池中包括了一个等于此String对象的字符串（由equals方法确定），则返回池中的字符串。否则，将此String对象添加到池中，并且返回此池中对象的引用。</p>
</li>
</ul>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">String()</td>
<td align="left">创建一个内容为空的字符串</td>
</tr>
<tr>
<td align="left">String(byte[])</td>
<td align="left">根据指定的字节数组创建对象</td>
</tr>
<tr>
<td align="left">String(byte[]，int，int)</td>
<td align="left">根据字节数组的一部分创建对象</td>
</tr>
<tr>
<td align="left">String(char[])</td>
<td align="left">根据指定的字符数组创建对象</td>
</tr>
<tr>
<td align="left">String(char[]，int，int)</td>
<td align="left">根据字符数组的一部分创建对象</td>
</tr>
<tr>
<td align="left">String(String)</td>
<td align="left">根据指定的字符串内容创建对象</td>
</tr>
<tr>
<td align="left">String(byte[] bytes, Charset charset)</td>
<td align="left">使用指定的编码构造字符串对象</td>
</tr>
</tbody></table>
<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>concat(str)</td>
<td>字符串连接字符串str</td>
</tr>
<tr>
<td>length()</td>
<td>判断字符串的长度</td>
</tr>
<tr>
<td>equals()</td>
<td>比较二个字符串是否相等,区分大小写</td>
</tr>
<tr>
<td>equalsIgnorceCase()</td>
<td>不区分大小写</td>
</tr>
<tr>
<td>toUpperCase</td>
<td>转换为大写</td>
</tr>
<tr>
<td>toLowerCase</td>
<td>转换为小写</td>
</tr>
<tr>
<td>indexOf(String str)</td>
<td>查找 参数 字符串 在原始 字符串中第一次 出现的位置索引，没有找到: 返回 -1</td>
</tr>
<tr>
<td>lastIndexOf(String str)</td>
<td>查找 参数 字符串 在原始 字符串中最后一次 出现的位置索引 没有找到: 返回 -1</td>
</tr>
<tr>
<td>charAt(index)</td>
<td>获得指定索引的字符</td>
</tr>
<tr>
<td>subString(int start)</td>
<td>获取从索引开始截取字符串</td>
</tr>
<tr>
<td>subString(int Start ,int end)</td>
<td>截取[start,end)范围的字符串</td>
</tr>
<tr>
<td>trim(String str)</td>
<td>去掉字符串的前后空格</td>
</tr>
<tr>
<td>replace(old,new)</td>
<td>使用new 替换 old，可以替换空格等特殊字符</td>
</tr>
<tr>
<td>startsWith()</td>
<td>判断是否指定的参数开头</td>
</tr>
<tr>
<td>endsWith()</td>
<td>判断是否指定的参数结尾</td>
</tr>
<tr>
<td>comparreTo(参数对象)</td>
<td>与参数对象比较大小，<br>相等:0<br>小:负数,比较的在参考的ASCII前 (根据厂商的不同,值不同) <br>大:正数,比较的在参考的ASCII前 (根据厂商的不同,值不同)</td>
</tr>
<tr>
<td>split(“ “)</td>
<td>用参数&#x2F;(空格,正则)字符串风格为一个字符串数组</td>
</tr>
<tr>
<td>toCharArray()</td>
<td>将字符串转换为字符串数组</td>
</tr>
<tr>
<td>contains(String)</td>
<td>指定的参数的字符串在原字符串中是否存在,不存在为false</td>
</tr>
</tbody></table>
<h3 id="String和数字转换"><a href="#String和数字转换" class="headerlink" title="String和数字转换"></a>String和数字转换</h3><ul>
<li><p>String – &gt; 数字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Ingetger</span>(String str).intValue();</span><br><span class="line">Integer.parseInt(String str);</span><br><span class="line">num = Integer.valueof(String);</span><br><span class="line"></span><br><span class="line"><span class="comment">// String ---&gt; Integer ---&gt;int</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">ii</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(str);</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> ii.intValue();</span><br></pre></td></tr></table></figure>
</li>
<li><p>数字 –&gt; String</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = num + <span class="string">&quot;&quot;</span>;</span><br><span class="line">s = String.valueof(num);</span><br><span class="line">s = Integer.toString(num);</span><br><span class="line"><span class="comment">// int ---&gt; Integer -----&gt; String</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="type">int</span> number);</span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> i.toString();</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="String技术点"><a href="#String技术点" class="headerlink" title="String技术点"></a>String技术点</h2><h3 id="String类是典型的Immutable类"><a href="#String类是典型的Immutable类" class="headerlink" title="String类是典型的Immutable类"></a>String类是典型的Immutable类</h3><ul>
<li>是典型的 Immutable 类，被声明成为 final class，所有属性也都是 final 的。也由于它的不可变，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。</li>
</ul>
<h3 id="字符串设计和实现考量"><a href="#字符串设计和实现考量" class="headerlink" title="字符串设计和实现考量"></a>字符串设计和实现考量</h3><ul>
<li>String 是 Immutable 类的典型实现，原生的保证了基础线程安全，因为你无法对它内部数据进行任何修改，这种便利甚至体现在拷贝构造函数中，由于不可变，Immutable 对象在拷贝时不需要额外复制数据。</li>
<li>为了实现修改字符序列的目的，StringBuffer 和 StringBuilder 底层都是利用可修改的（char，JDK 9 以后是 byte）数组，二者都继承了 AbstractStringBuilder，里面包含了基本操作，区别仅在于最终的方法是否加了 synchronized。</li>
<li>这个内部数组应该创建成多大的呢？如果太小，拼接的时候可能要重新创建足够大的数组；如果太大，又会浪费空间。目前的实现是，构建时初始字符串长度加 16（这意味着，如果没有构建对象时输入最初的字符串，那么初始值就是 16）。我们如果确定拼接会发生非常多次，而且大概是可预计的，那么就可以指定合适的大小，避免很多次扩容的开销。扩容会产生多重开销，因为要抛弃原有数组，创建新的（可以简单认为是倍数）数组，还要进行arraycopy。</li>
</ul>
<h3 id="字符串缓存"><a href="#字符串缓存" class="headerlink" title="字符串缓存"></a>字符串缓存</h3><ul>
<li>String 在 Java 6 以后提供了 intern()方法，目的是提示 JVM 把相应字符串缓存起来，以备重复使用。在我们创建字符串对象并调用 intern() 方法的时候，如果已经有缓存的字符串，就会返回缓存里的实例，否则将其缓存起来。</li>
<li>在后续版本中，这个缓存被放置在堆中，这样就极大避免了永久代占满的问题，甚至永久代在 JDK 8 中被 MetaSpace（元数据区）替代了。而且，默认缓存大小也在不断地扩大中，从最初的 1009，到 7u40 以后被修改为 60013。</li>
</ul>
<h3 id="String不可变的好处"><a href="#String不可变的好处" class="headerlink" title="String不可变的好处"></a>String不可变的好处</h3><ul>
<li><strong>可以缓存 hash 值</strong><ul>
<li>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</li>
</ul>
</li>
<li><strong>String Pool 的需要</strong><ul>
<li>如果一个String对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</li>
</ul>
</li>
<li><strong>安全性</strong><ul>
<li>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</li>
</ul>
</li>
<li><strong>线程安全</strong><ul>
<li>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</li>
</ul>
</li>
</ul>
<h2 id="StringBuffer与StringBuilder"><a href="#StringBuffer与StringBuilder" class="headerlink" title="StringBuffer与StringBuilder"></a>StringBuffer与StringBuilder</h2><ul>
<li>StringBuffer和StringBuilder都实现了AbstractStringBuilder抽象类，拥有几乎一致对外提供的调用接口；</li>
<li>其底层在内存中的存储方式与String相同，都是以一个有序的字符序列（char类型的数组）进行存储，不同点是StringBuffer&#x2F;StringBuilder对象的值是可以改变的，并且<strong>值改变以后，对象引用不会发生改变</strong>;</li>
<li>二者对象在构造过程中，首先按照默认大小申请一个字符数组，由于会不断加入新数据，当超过默认大小后，会创建一个更大的数组，并将原先的数组内容复制过来，再丢弃旧的数组。因此，对于较大对象的扩容会涉及大量的内存复制操作，如果能够预先评估大小，可提升性能。</li>
</ul>
<h3 id="StringBuffer类概述"><a href="#StringBuffer类概述" class="headerlink" title="StringBuffer类概述"></a>StringBuffer类概述</h3><ul>
<li>字符串缓冲区，StringBuffer是一个容器</li>
<li>我们如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。 而StringBuffer就可以解决这个问题</li>
<li><strong>线程安全</strong>的可变的字符序列 , 安全对应的效率比较低</li>
</ul>
<ul>
<li><p><strong>StringBuffer和String的区别</strong></p>
<ul>
<li>String 是不可变的字符序列</li>
<li>StringBuffer 是可以的字符序列</li>
</ul>
</li>
<li><p>StringBuffer的内部实现采用<strong>字符数组</strong>，默认数组的长度为16，超过数组大小时，动态扩充的算法是原来的长度*2+2</p>
<ul>
<li>所以当我们预知要添加的数据长度时，<strong>建议使用带初始化容量的构造方法</strong>，来避免动态扩充的次数，从而提高效率。</li>
</ul>
</li>
</ul>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li><p>构造方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public StringBuffer()</td>
<td>构造一个空的StringBuffer对象</td>
</tr>
<tr>
<td>public StringBuffer(String str)</td>
<td>将指定的String变为StringBuffer的内容</td>
</tr>
<tr>
<td>public StringBuffer(CharSequence seq)</td>
<td>接收CharSequence接口的实例</td>
</tr>
</tbody></table>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>capacity()</td>
<td>查看缓冲区的大小</td>
</tr>
<tr>
<td>char charAt(int index)</td>
<td>方法返回此序列中指定索引处的char值。第一个char值在索引0</td>
</tr>
<tr>
<td>indexOf(String str)</td>
<td>查询字符串第一次出现的位置</td>
</tr>
<tr>
<td>lastIndexOf(String str)</td>
<td>查询字符串最后出现的位置</td>
</tr>
<tr>
<td>append(数据类型 b)</td>
<td>提供了很多的append()方法，用于进行字符串连接</td>
</tr>
<tr>
<td>append (char[] ,start , end):</td>
<td>从start位置 插入end个字符</td>
</tr>
<tr>
<td>insert (int offser,数据类型 b)</td>
<td>在指定位置上增加一个内容</td>
</tr>
<tr>
<td>public StringBuffer replace(int start,int end,String str)</td>
<td>将指定范围的内容替换成其他内容</td>
</tr>
<tr>
<td>setCharAt (index,char)</td>
<td>修改指定位置的字符</td>
</tr>
<tr>
<td>deleteCharAt(index)</td>
<td>删除指定位置的字符</td>
</tr>
<tr>
<td>delete(start,end)</td>
<td>删除索引区间为[start , end)的字符</td>
</tr>
<tr>
<td>public <strong>String</strong> substring(int start)</td>
<td>截取从指定索引处的字符开始，直到此字符串末尾。</td>
</tr>
<tr>
<td>public <strong>String</strong> substring(int start,int end)</td>
<td>截取下标[start,end)范围的字符串</td>
</tr>
<tr>
<td>public StringBuffer reverse()</td>
<td>字符串翻转</td>
</tr>
<tr>
<td>void trimToSize()</td>
<td>将<em>StringBuffer</em>对象的中存储空间缩小到和字符串长度一样的长度,减少空间的浪费。</td>
</tr>
</tbody></table>
<h3 id="StringBuffer和String的相互转换"><a href="#StringBuffer和String的相互转换" class="headerlink" title="StringBuffer和String的相互转换"></a>StringBuffer和String的相互转换</h3><ul>
<li><p>String – StringBuffer</p>
<ul>
<li>通过构造方法</li>
<li>通过append()方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个String对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hi Java!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式一：构造方法</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str);</span><br><span class="line">System.out.println(buffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：通过append方法</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">buffer2.append(str);</span><br><span class="line">System.out.println(buffer2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>StringBuffer – String</p>
<ul>
<li>使用substring方法</li>
<li>通过构造方法</li>
<li>通过toString()方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个StringBuffer对象</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">buffer3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">buffer3.append(<span class="string">&quot;Happy birthday!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式一：通过构造方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer3);</span><br><span class="line">System.out.println(str2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：通过toString方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> buffer3.toString();</span><br><span class="line">System.out.println(str3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：通过substring方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> sb.substring(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 截取指定长度:String str3 = sb.substring(0,sb.length());</span></span><br><span class="line">System.out.println(str3);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><ul>
<li><p>StringBuilder是线程不安全的，在jdk1.5后才添加。其他跟StringBuffer一样；StringBuffer和StringBuilder底层是 char[]数组实现的</p>
</li>
<li><p>一个线程的时候优先采用StringBuilder，因为在大多数实现中，它比StringBuffer要快。</p>
</li>
</ul>
<h2 id="基本类型包装类"><a href="#基本类型包装类" class="headerlink" title="基本类型包装类"></a>基本类型包装类</h2><ul>
<li><p>为什么会有基本类型包装类</p>
<ul>
<li>为了对基本数据类型进行更多的操作,更方便的操作,java就针对每一种基本数据类型提供了对应的类类型.</li>
<li>原始数据类型和 Java 泛型并不能配合使用<ul>
<li>Java 的泛型某种程度上可以算作伪泛型，它完全是一种编译期的技巧，Java 编译期会自动将类型转换为对应的特定类型，这就决定了使用泛型，必须保证相应类型可以转换为Object。</li>
</ul>
</li>
<li>无法高效地表达数据，也不便于表达复杂的数据结构<ul>
<li>Java 的对象都是引用类型，</li>
<li>如果是一个原始数据类型数组，它在内存里是一段连续的内存</li>
<li>而对象数组则不然，数据存储的是引用，对象往往是分散地存储在堆的不同位置。虽然带来了极大灵活性，但是也导致了数据操作的低效，尤其是无法充分利用现代 CPU 缓存机制。</li>
</ul>
</li>
</ul>
</li>
<li><p>基本类型和包装类的对应</p>
</li>
<li><p>除了 int 和 char 两者的包装类名变化有些大以外，其余六种基本类型对应的包装类名，都是大写了首字母而已。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">byte           Byte</span><br><span class="line">short          Short</span><br><span class="line">int            Integer</span><br><span class="line">long           Long</span><br><span class="line"><span class="built_in">float</span>          Float</span><br><span class="line">double         Double</span><br><span class="line">char           Character</span><br><span class="line">boolean        Boolean</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="int和Integer的区别"><a href="#int和Integer的区别" class="headerlink" title="int和Integer的区别"></a>int和Integer的区别</h3><ul>
<li><p>Integer是int的包装类，int则是java的一种基本数据类型</p>
</li>
<li><p>Integer变量必须实例化后才能使用，而int变量不需要</p>
</li>
<li><p>Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值</p>
</li>
<li><p>Integer的默认值是null，int的默认值是0</p>
</li>
<li><p>关于Integer和int的比较：</p>
<ul>
<li><p>Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。</p>
</li>
<li><p>Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）</p>
</li>
<li><p>非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同）</p>
</li>
<li><p>对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">java在编译<span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span> ;时，会翻译成为<span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>)；，而java API中对Integer类型的valueOf的定义如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&#123;</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java对于-<span class="number">128</span>到<span class="number">127</span>之间的数，会进行缓存，<span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">127</span>时，会将<span class="number">127</span>进行缓存，下次再写<span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">127</span>时，就会直接从缓存中取，就不会<span class="keyword">new</span>了</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><ul>
<li>Java自带的线程安全的基本类型包括：<ul>
<li>AtomicInteger,</li>
<li>AtomicLong,</li>
<li>AtomicBoolean,</li>
<li>AtomicIntegerArray,</li>
<li>AtomicLongArray等</li>
</ul>
</li>
</ul>
<h3 id="验证int类型是否线程安全"><a href="#验证int类型是否线程安全" class="headerlink" title="验证int类型是否线程安全"></a>验证int类型是否线程安全</h3><ul>
<li><p>200个线程，每个线程对共享变量 count 进行 50 次 ++ 操作</p>
</li>
<li><p>int 作为基本类型，直接存储在内存栈，且对其进行+,-操作以及++,–操作都不是原子操作，都有可能被其他线程抢断，所以不是线程安全。int 用于单线程变量存取，开销小，速度快</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startThread</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">200</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">50</span>; k++)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 休眠10秒，以确保线程都已启动</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>*<span class="number">10</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        Log.e(<span class="string">&quot;打印日志----&quot;</span>,count+<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//期望输出10000，最后输出的是9818</span></span><br><span class="line"><span class="comment">//注意：打印日志----: 9818</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="AtomicInteger线程安全版"><a href="#AtomicInteger线程安全版" class="headerlink" title="AtomicInteger线程安全版"></a>AtomicInteger线程安全版</h3><ul>
<li><p>AtomicInteger类中有有一个变量valueOffset，用来描述AtomicInteger类中value的内存位置 。</p>
</li>
<li><p>当需要变量的值改变的时候，先通过get（）得到valueOffset位置的值，也即当前value的值.给该值进行增加，并赋给next</p>
</li>
<li><p>compareAndSet（）比较之前取到的value的值当前有没有改变，若没有改变的话，就将next的值赋给value，倘若和之前的值相比的话发生变化的话，则重新一次循环，直到存取成功，通过这样的方式能够保证该变量是线程安全的</p>
</li>
<li><p>value使用了volatile关键字，使得多个线程可以共享变量，使用volatile将使得VM优化失去作用，在线程数特别大时，效率会较低</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">count1</span> <span class="operator">=</span> Integer.valueOf(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startThread1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">200</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">50</span>; k++)&#123;</span><br><span class="line">                    <span class="comment">// getAndIncrement: 先获得值，再自增1，返回值为自增前的值</span></span><br><span class="line">                    count1 = atomicInteger.getAndIncrement();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 休眠10秒，以确保线程都已启动</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>*<span class="number">10</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        Log.e(<span class="string">&quot;打印日志----&quot;</span>,count1+<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//期望输出10000，最后输出的是10000</span></span><br><span class="line"><span class="comment">//注意：打印日志----: 10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//AtomicInteger使用了volatile关键字进行修饰，使得该类可以满足线程安全。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new AtomicInteger with the given initial value.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialValue the initial value</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AtomicInteger</span><span class="params">(<span class="type">int</span> initialValue)</span> &#123;</span><br><span class="line">    value = initialValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="自动拆-装箱-1-5以后"><a href="#自动拆-装箱-1-5以后" class="headerlink" title="自动拆&#x2F;装箱(1.5以后)"></a>自动拆&#x2F;装箱(1.5以后)</h2><ul>
<li><p>自动装箱是将原始数据类型转换为相应的包装类对象的过程，例如，<code>int</code>到<code>Integer</code>。</p>
<ul>
<li>将boolean值转换成Boolean对象</li>
<li>byte值转换成Byte对象，</li>
<li>char转换成Character对象，</li>
<li>float值转换成Float对象，</li>
<li>int转换成Integer，</li>
<li>long转换成Long，</li>
<li>short转换成Short，</li>
</ul>
</li>
<li><p>自动拆箱则是相反的操作，是将包装类对象转换为基本数据类型的过程。 例如，<code>Integer</code>到<code>int</code>。</p>
</li>
<li><p>在Java中是自动进行拆箱和自动装箱。 但是，我们可以使用<code>valueOf()</code>或<code>xxxValue()</code>等方法将一个外部转换为另一个。自动装箱时编译器调用valueOf将原始类型值转换成对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> Integer.valueOf(a);</span><br></pre></td></tr></table></figure>


</li>
<li><p>自动拆箱时，编译器通过调用类似intValue(),doubleValue()这类的方法将对象转换成原始类型值。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动拆/装箱</span></span><br><span class="line"><span class="type">Double</span> <span class="variable">aDouble</span> <span class="operator">=</span> Double.valueOf(<span class="number">3.14</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">v</span> <span class="operator">=</span> aDouble.doubleValue();</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">iObject</span> <span class="operator">=</span> Integer.valueOf(<span class="number">3</span>);</span><br><span class="line"><span class="type">Int</span> <span class="variable">iPrimitive</span> <span class="operator">=</span> iObject.intValue()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="装箱和拆箱的实现"><a href="#装箱和拆箱的实现" class="headerlink" title="装箱和拆箱的实现"></a>装箱和拆箱的实现</h3><ul>
<li><p>以Interger类为例，下面看一段代码来了解装箱和拆箱的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="何时发生自动装箱和拆箱"><a href="#何时发生自动装箱和拆箱" class="headerlink" title="何时发生自动装箱和拆箱"></a>何时发生自动装箱和拆箱</h3><ul>
<li><p>只要期望包装器类对象，并且提供原始数据类型，反之亦然，就会发生这种情况。</p>
<ul>
<li>将原始类型添加到Java中的<code>ArrayList</code>中。</li>
<li>创建参数化类的实例，例如，期望<code>Type</code>的<code>ThreadLocal</code>。</li>
<li>只要需要，Java就会自动将原始类型转换为对象，并在方法调用中提供另一个原始数据类型。</li>
<li>将基元类型分配给对象类型时。</li>
</ul>
</li>
<li><p>自动装箱主要发生在两种情况，一是赋值时，另一种是在方法调用的时候。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; intList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">intList.add(<span class="number">1</span>); <span class="comment">//autoboxing - primitive to object</span></span><br><span class="line">intList.add(<span class="number">2</span>); <span class="comment">//autoboxing</span></span><br><span class="line"></span><br><span class="line">ThreadLocal&lt;Integer&gt; intLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Integer&gt;();</span><br><span class="line">intLocal.set(<span class="number">4</span>); <span class="comment">//autoboxing</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> intList.get(<span class="number">0</span>); <span class="comment">// unboxing</span></span><br><span class="line"><span class="type">int</span> <span class="variable">local</span> <span class="operator">=</span> intLocal.get(); <span class="comment">// unboxing in Java</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="赋值时"><a href="#赋值时" class="headerlink" title="赋值时"></a>赋值时</h4><ul>
<li><p>这是最常见的一种情况，在Java 1.5以前我们需要手动地进行转换才行，而现在所有的转换都是由编译器来完成。</p>
</li>
<li><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//after java5 可以自动拆/装箱</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">iObject</span> <span class="operator">=</span> <span class="number">3</span>; <span class="comment">//autobxing - primitive to wrapper conversion</span></span><br><span class="line"><span class="type">int</span> <span class="variable">iPrimitive</span> <span class="operator">=</span> iObject; <span class="comment">//unboxing - object to primitive conversion</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="方法调用时"><a href="#方法调用时" class="headerlink" title="方法调用时"></a>方法调用时</h4><ul>
<li><p>这是另一个常用的情况，当我们在方法调用时，我们可以传入原始数据值或者对象，同样编译器会帮我们进行转换。</p>
</li>
<li><p>代码如下：</p>
<ul>
<li>show方法接受Integer对象作为参数，当调用show(3)时，会将int值转换成对应的Integer对象，这就是所谓的自动装箱，</li>
<li>show方法返回Integer对象，而int result &#x3D; show(3);中result为int类型，所以这时候发生自动拆箱操作，将show方法的返回的Integer对象转换成int值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">show</span><span class="params">(Integer iParam)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;autoboxing example - method invocation i: &quot;</span> + iParam);</span><br><span class="line">    <span class="keyword">return</span> iParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//autoboxing and unboxing in method invocation</span></span><br><span class="line">show(<span class="number">3</span>); <span class="comment">//autoboxing</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> show(<span class="number">3</span>); <span class="comment">//unboxing because return type of method is Integer</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="自动装箱的弊端"><a href="#自动装箱的弊端" class="headerlink" title="自动装箱的弊端"></a>自动装箱的弊端</h3><ul>
<li><p>在一个循环中进行自动装箱操作的情况，如下面的例子就会创建多余的对象，影响程序的性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1000</span>; i&lt;<span class="number">5000</span>; i++)&#123;</span><br><span class="line">    sum+=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面的代码sum+&#x3D;i可以看成sum &#x3D; sum + i，但是+这个操作符不适用于Integer对象，首先sum进行自动拆箱操作，进行数值相加操作，最后发生自动装箱操作转换成Integer对象。其内部变化如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> sum.intValue() + i;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(result);</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于我们这里声明的sum为Integer类型，在上面的循环中会创建将近4000个无用的Integer对象，在这样庞大的循环中，会降低程序的性能并且加重了垃圾回收的工作量。因此在我们编程时，需要注意到这一点，正确地声明变量类型，避免因为自动装箱引起的性能问题。</p>
</li>
</ul>
<h3 id="重载与自动装箱"><a href="#重载与自动装箱" class="headerlink" title="重载与自动装箱"></a>重载与自动装箱</h3><ul>
<li><p>当重载遇上自动装箱时，情况会比较有些复杂，可能会让人产生有些困惑。</p>
</li>
<li><p>在1.5之前，value(int)和value(Integer)是完全不相同的方法，开发者不会因为传入是int还是Integer调用哪个方法困惑，</p>
</li>
<li><p>但是由于自动装箱和拆箱的引入，处理重载方法时稍微有点复杂。一个典型的例子就是ArrayList的remove方法，它有remove(index)和remove(Object)两种重载，我们可能会有一点小小的困惑，其实这种困惑是可以验证并解开的，通过下面的例子我们可以看到，当出现这种情况时，不会发生自动装箱操作。仍然是重载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;method with primitive argument&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Integer num)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;method with wrapper argument&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//calling overloaded method</span></span><br><span class="line"><span class="type">AutoboxingTest</span> <span class="variable">autoTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutoboxingTest</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">autoTest.test(value); <span class="comment">//no autoboxing</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">iValue</span> <span class="operator">=</span> value;</span><br><span class="line">autoTest.test(iValue); <span class="comment">//no autoboxing</span></span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">method with primitive argument</span><br><span class="line">method with wrapper argument</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="对象相等比较"><a href="#对象相等比较" class="headerlink" title="对象相等比较"></a>对象相等比较</h3><ul>
<li><p>”&#x3D;&#x3D;“可以用于原始值进行比较，也可以用于对象进行比较</p>
</li>
<li><p>当用于对象与对象之间比较时，比较的不是对象代表的值，而是检查两个对象是否是同一对象，这个比较过程中没有自动装箱发生。</p>
</li>
<li><p>进行对象值比较不应该使用”&#x3D;&#x3D;“，而应该使用重写对象对应的equals方法进行值得判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Example 1: == 基本类型比较看值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;i1==i2 : &quot;</span> + (i1 == i2)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Example 2: 基本类型和包装类型比较看值</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;num1 == num2 : &quot;</span> + (num1 == num2)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Example 3: 自动装箱后的包装类型比较：-128~127之间看值，大于这个区间看地址值</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">obj3</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">obj4</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;obj1 == obj2 : &quot;</span> + (obj1 == obj2)); <span class="comment">// true</span></span><br><span class="line">    System.out.println(<span class="string">&quot;obj3 == obj4 : &quot;</span> + (obj1 == obj2)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Example 4: 包装类型比较：看地址值</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">one</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">anotherOne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;one == anotherOne : &quot;</span> + (one == anotherOne)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h2><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><ul>
<li>最大值：<code>public static final int MAX_VALUE;</code></li>
<li>最小值：<code>public static final int MIN_VALUE;</code></li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li><p><code>public Integer(int value)</code></p>
</li>
<li><p><code>public Integer(String s)</code>，注意：这个字符串必须是由数字字符组成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">ii</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">System.out.println(<span class="string">&quot;ii:&quot;</span> + ii); <span class="comment">//ii:100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;100&quot;</span>;</span><br><span class="line"><span class="comment">// NumberFormatException</span></span><br><span class="line"><span class="comment">// String s = &quot;abc&quot;;</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">iii</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(s);</span><br><span class="line">System.out.println(<span class="string">&quot;iii:&quot;</span> + iii);   <span class="comment">//iii:100</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Integer进制转换"><a href="#Integer进制转换" class="headerlink" title="Integer进制转换"></a>Integer进制转换</h3><ul>
<li><p>10进制转为2进制</p>
<ul>
<li><code>public static String toBinaryString(int i);</code></li>
</ul>
</li>
<li><p>10进制转8进制</p>
<ul>
<li><code>public static String toOctalString(int i);</code></li>
</ul>
</li>
<li><p>10进制转16进制</p>
<ul>
<li><code>public static String toHexString(int i);</code></li>
</ul>
</li>
<li><p>十进制到其他进制(范围：2-36，因为表示的数有0-9,a-z共36个)</p>
<ul>
<li><code>public static String toString(int i,int radix);</code></li>
</ul>
</li>
<li><p>其他进制到十进制</p>
<ul>
<li>p<code>ublic static int parseInt(String s,int radix);</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.parseInt(<span class="string">&quot;100&quot;</span>, <span class="number">10</span>));    <span class="comment">//100</span></span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">&quot;100&quot;</span>, <span class="number">2</span>));     <span class="comment">//4</span></span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">&quot;100&quot;</span>, <span class="number">8</span>));     <span class="comment">//64</span></span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">&quot;100&quot;</span>, <span class="number">16</span>));    <span class="comment">//256</span></span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">&quot;100&quot;</span>, <span class="number">23</span>));    <span class="comment">//529</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h3><ul>
<li><code>public int intValue()</code>　　&#x2F;&#x2F;把Integer类型转化为Int类型</li>
<li><code>public static int parseInt(String s)</code>　　&#x2F;&#x2F;把String类型转化为Int类型</li>
<li><code>public static int parseInt(String s ,int radix)</code>　　&#x2F;&#x2F;把String类型转化为radix进制</li>
<li><code>public static String toString(int i)</code>　　&#x2F;&#x2F;把Int类型转化为String类型</li>
<li><code>public static Integer toString(int i ,int radix)</code>　　10进制转为radix进制</li>
<li><code>public static Integer valueOf(String s)</code>　　　&#x2F;&#x2F;把String参数给的值，转化为Integer类型</li>
</ul>
<h2 id="Integer的值缓存的原理"><a href="#Integer的值缓存的原理" class="headerlink" title="Integer的值缓存的原理"></a>Integer的值缓存的原理</h2><h3 id="Java-5-中引入缓存特性"><a href="#Java-5-中引入缓存特性" class="headerlink" title="Java 5 中引入缓存特性"></a>Java 5 中引入缓存特性</h3><ul>
<li><p>在 Java 5 中，为 Integer 的操作引入了一个新的特性，用来节省内存和提高性能。整型对象在内部实现中通过使用相同的对象引用实现了缓存和重用。</p>
</li>
<li><p>这种 Integer 缓存策略仅在自动装箱（autoboxing）的时候有用，使用<strong>构造器创建的 Integer 对象不能被缓存</strong>。编译器会在自动装箱过程调用 valueOf() 方法，因此多个Integer实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。</p>
</li>
<li><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p>
<ul>
<li><p>new Integer(123) 每次都会新建一个对象；</p>
</li>
<li><p>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">z</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">k</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">123</span>;	<span class="comment">// 自动装箱</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">123</span>;	<span class="comment">// 自动装箱</span></span><br><span class="line">System.out.println(m == n); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="IntegerCache类"><a href="#IntegerCache类" class="headerlink" title="IntegerCache类"></a>IntegerCache类</h3><ul>
<li><p>在创建新的 Integer 对象之前会先在 IntegerCache.cache (是个Integer类型的数组)中查找。有一个专门的 Java 类来负责 Integer 的缓存。</p>
</li>
<li><p>这个类是用来实现缓存支持，并支持 -128 到 127 之间的自动装箱过程。最大值 127 可以通过 JVM 的启动参数 -XX:AutoBoxCacheMax&#x3D;size 修改。 缓存通过一个 for 循环实现。从小到大的创建尽可能多的整数并存储在一个名为 cache 的整数数组中。这个缓存会在 Integer 类第一次被使用的时候被初始化出来。以后，就可以使用缓存中包含的实例对象，而不是创建一个新的实例(在自动装箱的情况下)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 高值可由属性配置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span></span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">//最大数组大小为Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// 如果无法将属性解析为 int，忽略它。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IntegerCache</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="其他整型类型的缓存机制"><a href="#其他整型类型的缓存机制" class="headerlink" title="其他整型类型的缓存机制"></a>其他整型类型的缓存机制</h3><ul>
<li>这种缓存行为不仅适用于Integer对象。我们针对所有整数类型的类都有类似的缓存机制。<ul>
<li>有 ByteCache 用于缓存 Byte 对象</li>
<li>有 ShortCache 用于缓存 Short 对象</li>
<li>有 LongCache 用于缓存 Long 对象</li>
<li>有 CharacterCache 用于缓存 Character 对象</li>
<li>boolean的True,False。Byte，Short，Long 有固定范围: -128 到 127。对于 Character, 范围是 0 到 127。除了 Integer 可以通过参数改变范围外，其它的都不行。</li>
</ul>
</li>
</ul>
<h2 id="Character类概述"><a href="#Character类概述" class="headerlink" title="Character类概述"></a>Character类概述</h2><ul>
<li>Character 类在对象中包装一个基本类型 char 的值&lt;</li>
<li>此外，该类提供了几种方法，以确定字符的类别（小写字母，数字，等等），并将字符从大写转换成小写，反之亦然</li>
</ul>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><p><code>public Character(char value)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    <span class="comment">// Character ch = new Character((char) 97);</span></span><br><span class="line">    <span class="type">Character</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Character</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;ch:&quot;</span> + ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="成员方法-2"><a href="#成员方法-2" class="headerlink" title="成员方法"></a>成员方法</h3><ul>
<li><p>A:判断给定的字符是否是大写     public static boolean isUpperCase(char ch)</p>
</li>
<li><p>B:判断给定的字符是否是小写  public static boolean isLowerCase(char ch)</p>
</li>
<li><p>C:判断给定的字符是否是数字字符   public static boolean isDigit(char ch)</p>
</li>
<li><p>D:把给定的字符转成大写  public static char toUpperCase(char ch)</p>
</li>
<li><p>E:把给定的字符转成小写  public static char toLowerCase(char ch)</p>
</li>
<li><p>代码测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="comment">// public static boolean isUpperCase(char ch):判断给定的字符是否是大写字符</span></span><br><span class="line">	System.out.println(<span class="string">&quot;isUpperCase:&quot;</span> + Character.isUpperCase(<span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">	System.out.println(<span class="string">&quot;isUpperCase:&quot;</span> + Character.isUpperCase(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">	System.out.println(<span class="string">&quot;isUpperCase:&quot;</span> + Character.isUpperCase(<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">	System.out.println(<span class="string">&quot;-----------------------------------------&quot;</span>);</span><br><span class="line">	<span class="comment">// public static boolean isLowerCase(char ch):判断给定的字符是否是小写字符</span></span><br><span class="line">	System.out.println(<span class="string">&quot;isLowerCase:&quot;</span> + Character.isLowerCase(<span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">	System.out.println(<span class="string">&quot;isLowerCase:&quot;</span> + Character.isLowerCase(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">	System.out.println(<span class="string">&quot;isLowerCase:&quot;</span> + Character.isLowerCase(<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">	System.out.println(<span class="string">&quot;-----------------------------------------&quot;</span>);</span><br><span class="line">	<span class="comment">// public static boolean isDigit(char ch):判断给定的字符是否是数字字符</span></span><br><span class="line">	System.out.println(<span class="string">&quot;isDigit:&quot;</span> + Character.isDigit(<span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">	System.out.println(<span class="string">&quot;isDigit:&quot;</span> + Character.isDigit(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">	System.out.println(<span class="string">&quot;isDigit:&quot;</span> + Character.isDigit(<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">	System.out.println(<span class="string">&quot;-----------------------------------------&quot;</span>);</span><br><span class="line">	<span class="comment">// public static char toUpperCase(char ch):把给定的字符转换为大写字符</span></span><br><span class="line">	System.out.println(<span class="string">&quot;toUpperCase:&quot;</span> + Character.toUpperCase(<span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">	System.out.println(<span class="string">&quot;toUpperCase:&quot;</span> + Character.toUpperCase(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">	System.out.println(<span class="string">&quot;-----------------------------------------&quot;</span>);</span><br><span class="line">	<span class="comment">// public static char toLowerCase(char ch):把给定的字符转换为小写字符</span></span><br><span class="line">	System.out.println(<span class="string">&quot;toLowerCase:&quot;</span> + Character.toLowerCase(<span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">	System.out.println(<span class="string">&quot;toLowerCase:&quot;</span> + Character.toLowerCase(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">isUpperCase:<span class="literal">true</span></span><br><span class="line">isUpperCase:<span class="literal">false</span></span><br><span class="line">isUpperCase:<span class="literal">false</span></span><br><span class="line">-----------------------------------------</span><br><span class="line">isLowerCase:<span class="literal">false</span></span><br><span class="line">isLowerCase:<span class="literal">true</span></span><br><span class="line">isLowerCase:<span class="literal">false</span></span><br><span class="line">-----------------------------------------</span><br><span class="line">isDigit:<span class="literal">false</span></span><br><span class="line">isDigit:<span class="literal">false</span></span><br><span class="line">isDigit:<span class="literal">true</span></span><br><span class="line">-----------------------------------------</span><br><span class="line">toUpperCase:A</span><br><span class="line">toUpperCase:A</span><br><span class="line">-----------------------------------------</span><br><span class="line">toLowerCase:a</span><br><span class="line">toLowerCase:a</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ul>
<li><p>正则表达式，不需要记忆，用的时候去查就可以呢</p>
<ul>
<li>是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。其实就是一种规则。有自己特殊的应用。</li>
<li>具体使用直接上网搜索<ul>
<li>例如，匹配手机号，邮箱，身份证号等等</li>
</ul>
</li>
</ul>
</li>
<li><p>需求：只能输入数字</p>
<ul>
<li><p>常规写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//只能输入数字</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;124354232&quot;</span>;</span><br><span class="line">    <span class="type">char</span>[] arr = str.toCharArray();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;  i&lt; arr.length ; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(!(arr[i]&gt;=<span class="number">48</span>&amp;&amp;arr[i]&lt;=<span class="number">57</span>))&#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(flag?<span class="string">&quot;输入正确&quot;</span>:<span class="string">&quot;输出只能是数字&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用正则表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//只能输入数字</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;12435423a2&quot;</span>;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> str.matches(<span class="string">&quot;[0-9]+&quot;</span>);</span><br><span class="line">		System.out.println(flag?<span class="string">&quot;输入正确&quot;</span>:<span class="string">&quot;只能输入数字&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="正则表达式的符号"><a href="#正则表达式的符号" class="headerlink" title="正则表达式的符号"></a>正则表达式的符号</h3><table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
<th>表达式</th>
</tr>
</thead>
<tbody><tr>
<td><code>. </code></td>
<td>任何字符（与行结束符可能匹配也可能不匹配）</td>
<td></td>
</tr>
<tr>
<td><code>\d </code></td>
<td>数字：</td>
<td><code>[0-9]</code></td>
</tr>
<tr>
<td><code>\D </code></td>
<td>非数字：</td>
<td><code>[^0-9] </code></td>
</tr>
<tr>
<td><code>\s </code></td>
<td>空白字符：</td>
<td><code>[\t\n\x0B\f\r] </code></td>
</tr>
<tr>
<td><code>\S </code></td>
<td>非空白字符：</td>
<td><code>[^\s] </code></td>
</tr>
<tr>
<td><code>\w </code></td>
<td>单词字符：</td>
<td><code>[a-zA-Z_0-9] </code></td>
</tr>
<tr>
<td><code>\W </code></td>
<td>非单词字符：</td>
<td><code>[^\w]</code></td>
</tr>
</tbody></table>
<ul>
<li><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;1&quot;</span>.matches(<span class="string">&quot;\\d&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;%&quot;</span>.matches(<span class="string">&quot;\\D&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;\r&quot;</span>.matches(<span class="string">&quot;\\s&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;^&quot;</span>.matches(<span class="string">&quot;\\S&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Greedy-数量词"><a href="#Greedy-数量词" class="headerlink" title="Greedy 数量词"></a>Greedy 数量词</h3><table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>X?</td>
<td>X，一次或一次也没有</td>
</tr>
<tr>
<td>X*</td>
<td>X，零次或多次</td>
</tr>
<tr>
<td>X+</td>
<td>X，一次或多次</td>
</tr>
<tr>
<td>X{n}</td>
<td>X，恰好n次</td>
</tr>
<tr>
<td>X{n,}</td>
<td>X，至少n次</td>
</tr>
<tr>
<td>X{n,m}</td>
<td>X，至少n次，但是不超过m次</td>
</tr>
</tbody></table>
<ul>
<li><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">System.out.println( <span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;.&quot;</span>) );</span><br><span class="line">System.out.println( <span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;a&quot;</span>) );</span><br><span class="line">System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;a?&quot;</span>) );</span><br><span class="line">System.out.println( <span class="string">&quot;aaa&quot;</span>.matches(<span class="string">&quot;a*&quot;</span>) );</span><br><span class="line">System.out.println( <span class="string">&quot;&quot;</span>.matches(<span class="string">&quot;a+&quot;</span>) );</span><br><span class="line">System.out.println( <span class="string">&quot;aaaaa&quot;</span>.matches(<span class="string">&quot;a&#123;5&#125;&quot;</span>) );</span><br><span class="line">System.out.println( <span class="string">&quot;aaaaaaaaa&quot;</span>.matches(<span class="string">&quot;a&#123;5,8&#125;&quot;</span>) );</span><br><span class="line">System.out.println( <span class="string">&quot;aaa&quot;</span>.matches(<span class="string">&quot;a&#123;5,&#125;&quot;</span>) );</span><br><span class="line">System.out.println( <span class="string">&quot;aaaaab&quot;</span>.matches(<span class="string">&quot;a&#123;5,&#125;&quot;</span>) );</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="范围表示"><a href="#范围表示" class="headerlink" title="范围表示"></a>范围表示</h3><table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>[abc]</code></td>
<td>a、b 或 c（简单类）</td>
</tr>
<tr>
<td><code>[^abc]</code></td>
<td>任何字符，除了 a、b 或 c（否定）</td>
</tr>
<tr>
<td><code>[a-zA-Z]</code></td>
<td>a 到 z 或 A 到 Z，两头的字母包括在内（范围）</td>
</tr>
<tr>
<td><code>[a-d[m-p]]</code></td>
<td>a 到 d 或 m 到 p：[a-dm-p]（并集）</td>
</tr>
<tr>
<td><code>[a-z&amp;&amp;[def]]</code></td>
<td>d、e 或 f（交集）</td>
</tr>
<tr>
<td><code>[a-z&amp;&amp;[^bc]]</code></td>
<td>a 到 z，除了 b 和 c：[ad-z]（减去）</td>
</tr>
<tr>
<td><code>[a-z&amp;&amp;[^m-p]]</code></td>
<td>a 到 z，而非 m 到 p：[a-lq-z]（减去）</td>
</tr>
</tbody></table>
<ul>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">System.out.println( <span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[a]&quot;</span>) );</span><br><span class="line">System.out.println( <span class="string">&quot;aa&quot;</span>.matches(<span class="string">&quot;[a]+&quot;</span>) );</span><br><span class="line">System.out.println( <span class="string">&quot;abc&quot;</span>.matches(<span class="string">&quot;[abc]&#123;3,&#125;&quot;</span>) );</span><br><span class="line">System.out.println( <span class="string">&quot;abc&quot;</span>.matches(<span class="string">&quot;[abc]+&quot;</span>) );</span><br><span class="line">System.out.println( <span class="string">&quot;dshfshfu1&quot;</span>.matches(<span class="string">&quot;[^abc]+&quot;</span>) );</span><br><span class="line">System.out.println( <span class="string">&quot;abcdsaA&quot;</span>.matches(<span class="string">&quot;[a-z]&#123;5,&#125;&quot;</span>) );</span><br><span class="line">System.out.println( <span class="string">&quot;abcdsaA12&quot;</span>.matches(<span class="string">&quot;[a-zA-Z]&#123;5,&#125;&quot;</span>) );</span><br><span class="line">System.out.println( <span class="string">&quot;abcdsaA12&quot;</span>.matches(<span class="string">&quot;[a-zA-Z0-9]&#123;5,&#125;&quot;</span>) );</span><br><span class="line">System.out.println( <span class="string">&quot;abdxyz&quot;</span>.matches(<span class="string">&quot;[a-c[x-z]]+&quot;</span>));</span><br><span class="line">System.out.println( <span class="string">&quot;bcbcbc&quot;</span>.matches(<span class="string">&quot;[a-z&amp;&amp;[b-c]]&#123;5,&#125;&quot;</span>));</span><br><span class="line">System.out.println( <span class="string">&quot;tretrt&quot;</span>.matches(<span class="string">&quot;[a-z&amp;&amp;[^b-c]]&#123;5,&#125;&quot;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>行的开头</td>
</tr>
<tr>
<td>$</td>
<td>行的结尾</td>
</tr>
<tr>
<td>\b</td>
<td>单词边界</td>
</tr>
<tr>
<td>\B</td>
<td>非单词边界</td>
</tr>
<tr>
<td>\A</td>
<td>输入的开头</td>
</tr>
<tr>
<td>\G</td>
<td>上一个匹配的结尾</td>
</tr>
<tr>
<td>\Z</td>
<td>输入的结尾，仅用于最后的结束符（如果有的话）</td>
</tr>
<tr>
<td>\z</td>
<td>输入的结尾</td>
</tr>
</tbody></table>
<ul>
<li><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;45678&quot;</span>.matches(<span class="string">&quot;^[^0]\\d+&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;demo.java&quot;</span>.matches(<span class="string">&quot;\\w+\\.java$&quot;</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul>
<li><p>校验QQ号，要求：必须是5~15位数字，0不能开头。</p>
</li>
<li><p>有了正则表达式之后：<code>[1-9][0-9]&#123;4,14&#125;</code>表示是第一位数字是会出现1-9范围之间的其中一个，下来的数字范围会出现在0-9之间，至少出现4次，最多出现14次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkQQ2</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">qq</span> <span class="operator">=</span> <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">reg</span> <span class="operator">=</span> <span class="string">&quot;[1-9][0-9]&#123;4,14&#125;&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> qq.matches(reg);</span><br><span class="line">System.out.println(<span class="string">&quot;b=&quot;</span>+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>匹配是否为一个合法的手机号码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkTel</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">tel</span> <span class="operator">=</span> <span class="string">&quot;25800001111&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">reg</span> <span class="operator">=</span> <span class="string">&quot;1[35]\\d&#123;9&#125;&quot;</span>;<span class="comment">//在字符串中，定义正则出现\ 要一对出现。</span></span><br><span class="line">  <span class="type">boolean</span> b= tel.matches(reg);</span><br><span class="line">  System.out.println(tel+<span class="string">&quot;:&quot;</span>+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="正则切割字符串"><a href="#正则切割字符串" class="headerlink" title="正则切割字符串"></a>正则切割字符串</h3><ul>
<li><p>根据空格对一段字符串进行切割。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">splitDemo</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;aa.bb.cc&quot;</span>;</span><br><span class="line">  str = <span class="string">&quot;-1    99   4   23&quot;</span>;</span><br><span class="line">  String[] arr = str.split(<span class="string">&quot; +&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(String s : arr) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据重叠词进行切割。</p>
<ul>
<li>注意：为了提高规则复用，用()进行封装，每一个括号都有一个编号，从1开始，为了复用这个规则。可以通过编号来完成该规则的调用。</li>
<li>需要对编号数字进行转义。\1就代表获取1组规则。二个拼接后就是二个以上的任意单词</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">splitDemo2</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;sdqqfgkkkhjppppkl&quot;</span>;</span><br><span class="line">  String[] arr = str.split(<span class="string">&quot;(.)\\1+&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(String s : arr)  &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">sd</span><br><span class="line">fg</span><br><span class="line">hj</span><br><span class="line">kl</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串中的重叠字替换成单个单词。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">replaceDemo</span><span class="params">()</span>	&#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;sdaaafghcccjkqqqqqql&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> str.replaceAll(<span class="string">&quot;(.)\\1+&quot;</span>,<span class="string">&quot;$1&quot;</span>);<span class="comment">//$ 可以获取到该方法中正则实际参数中的某一个存在的组 $组编号即可。</span></span><br><span class="line">		System.out.println(str+<span class="string">&quot;:&quot;</span>+s);</span><br><span class="line">		<span class="type">String</span> <span class="variable">nums</span> <span class="operator">=</span> <span class="string">&quot;wser127372tyuiopd6226178909876789fghjk&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> nums.replaceAll(<span class="string">&quot;\\d+&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br><span class="line">		System.out.println(nums+<span class="string">&quot;:&quot;</span>+s1);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Pattern和Matcher类"><a href="#Pattern和Matcher类" class="headerlink" title="Pattern和Matcher类"></a>Pattern和Matcher类</h3><ul>
<li><p>正则的获取功能需要使用的类</p>
</li>
<li><p>步骤：</p>
<ol>
<li>先将正则表达式编译成正则对象。使用的是Pattern类一个静态的方法。compile(regex);</li>
<li>让正则对象和要操作的字符串相关联，通过matcher方法完成，并返回匹配器对象。</li>
<li>通过匹配器对象的方法将正则模式作用到字符串上对字符串进行针对性的功能操作</li>
</ol>
</li>
<li><p>需求：获取由3个字母组成的单词。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getDemo</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;da jia zhu yi le,ming tian bu fang jia,xie xie!&quot;</span>;</span><br><span class="line">  <span class="comment">//想要获取由3个字母组成的单词。</span></span><br><span class="line">  <span class="comment">//刚才的功能返回的都是一个结果，只有split返回的是数组，但是它是把规则作为分隔符，不会获取符合规则的内容。</span></span><br><span class="line">  <span class="comment">//这时我们要用到一些正则对象。</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">reg</span> <span class="operator">=</span> <span class="string">&quot;\\b[a-z]&#123;3&#125;\\b&quot;</span>;</span><br><span class="line">  <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(reg);</span><br><span class="line">  <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(str);</span><br><span class="line">  <span class="keyword">while</span>(m.find())</span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(m.start()+<span class="string">&quot;....&quot;</span>+m.end());</span><br><span class="line">    System.out.println(<span class="string">&quot;sub:&quot;</span>+str.substring(m.start(),m.end()));</span><br><span class="line">    System.out.println(m.group());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//		System.out.println(m.find());//将规则对字符串进行匹配查找。</span></span><br><span class="line">  <span class="comment">//		System.out.println(m.group());//在使用group方法之前，必须要先找，找到了才可以取。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><ul>
<li>Date:表示特定的瞬间，精确到毫秒。</li>
<li>日期类的时间从为什么是从1970年1月1日<ul>
<li>最初计算机操作系统是32位，而时间也是用32位表示。Integer在JAVA内用32位表 示，因此32位能表示的最大值是2147483647。另外1年365天的总秒数是31536000，2147483647&#x2F;31536000 &#x3D; 68.1。也就是说32位能表示的最长时间是68年，而实际上到2038年01月19日03时14分07秒，便会到达最大时间，过了这个时间点，所有32位操作系统时间便会变为10000000 00000000 00000000 00000000，也就是1901年12月13日20时45分52秒，这样便会出现时间回归的现象，很多软件便会运行异常了。所以从1970年1月1日开始，延长使用时间。</li>
</ul>
</li>
</ul>
<h4 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h4><ul>
<li><p>Date():根据当前的默认毫秒值创建日期对象</p>
</li>
<li><p>Date(long date)：根据给定的毫秒值创建日期对象</p>
</li>
<li><p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;d:&quot;</span> + d);	<span class="comment">//d:Mon Jul 30 16:21:01 CST 2018</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="comment">// long time = System.currentTimeMillis();</span></span><br><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span>; <span class="comment">// 1小时</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(time);</span><br><span class="line">System.out.println(<span class="string">&quot;d2:&quot;</span> + d2);	<span class="comment">//d2:Thu Jan 01 08:00:00 CST 1970</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="成员方法-3"><a href="#成员方法-3" class="headerlink" title="成员方法"></a>成员方法</h4><ul>
<li><p>public long getTime():获取时间，以毫秒为单位</p>
</li>
<li><p>public void setTime(long time):设置时间</p>
</li>
<li><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="comment">// 获取时间</span></span><br><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> d.getTime();</span><br><span class="line">System.out.println(time);		<span class="comment">//1532939861629</span></span><br><span class="line"><span class="comment">// System.out.println(System.currentTimeMillis());	//1532939861630</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;d:&quot;</span> + d);	<span class="comment">//d:Mon Jul 30 16:37:41 CST 2018</span></span><br><span class="line"><span class="comment">// 设置时间</span></span><br><span class="line">d.setTime(<span class="number">1000</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;d:&quot;</span> + d);	d:Thu Jan <span class="number">01</span> 08:<span class="number">00</span>:<span class="number">01</span> CST <span class="number">1970</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time time = new Time(date.getTime());</span><br><span class="line">	System.out.println(time);	//15:20:51</span><br></pre></td></tr></table></figure>

<h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><ul>
<li><p>它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等 日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。</p>
</li>
<li><p>月份从0开始</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">System.out.println(c.getTime());		<span class="comment">//Sun Aug 12 15:23:15 CST 2018</span></span><br><span class="line">System.out.println(c.get(Calendar.YEAR));	<span class="comment">//2018</span></span><br><span class="line">System.out.println(c.get(Calendar.MONTH)+<span class="number">1</span>);	<span class="comment">//8</span></span><br><span class="line">System.out.println(c.get(Calendar.DATE));		/<span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//add()调节时间</span></span><br><span class="line">c.add(Calendar.YEAR, -<span class="number">10</span>);		<span class="comment">//10年前的今天;</span></span><br><span class="line">System.out.println(c.getTime());	<span class="comment">//Tue Aug 12 15:24:55 CST 2008</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>public final void set(int year,int month,int date)</code>:设置当前日历的年月日</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">c.set(<span class="number">1314</span>,<span class="number">05</span>,<span class="number">20</span>);</span><br><span class="line"><span class="comment">// 获取年</span></span><br><span class="line">year = c.get(Calendar.YEAR);</span><br><span class="line"><span class="comment">// 获取月</span></span><br><span class="line">month = c.get(Calendar.MONTH);</span><br><span class="line"><span class="comment">// 获取日</span></span><br><span class="line">date = c.get(Calendar.DATE);</span><br><span class="line">System.out.println(year + <span class="string">&quot;年&quot;</span> + (month + <span class="number">1</span>) + <span class="string">&quot;月&quot;</span> + date + <span class="string">&quot;日&quot;</span>);	<span class="comment">//1314年6月20日</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取任意一年的二月有多少天</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 分析：</span></span><br><span class="line"><span class="comment"> * 		A:键盘录入任意的年份</span></span><br><span class="line"><span class="comment"> * 		B:设置日历对象的年月日</span></span><br><span class="line"><span class="comment"> * 			年就是A输入的数据</span></span><br><span class="line"><span class="comment"> * 			月是2</span></span><br><span class="line"><span class="comment"> * 			日是1</span></span><br><span class="line"><span class="comment"> * 		C:把时间往前推一天，就是2月的最后一天</span></span><br><span class="line"><span class="comment"> * 		D:获取这一天输出即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="comment">// 键盘录入任意的年份</span></span><br><span class="line">	<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">	System.out.println(<span class="string">&quot;请输入年份：&quot;</span>);</span><br><span class="line">	<span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置日历对象的年月日</span></span><br><span class="line">	<span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">	c.set(year, <span class="number">2</span>, <span class="number">1</span>); <span class="comment">// 其实是这一年的3月1日</span></span><br><span class="line">	<span class="comment">// 把时间往前推一天，就是2月的最后一天</span></span><br><span class="line">	c.add(Calendar.DATE, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取这一天输出即可</span></span><br><span class="line">	System.out.println(c.get(Calendar.DATE));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><h3 id="数字的格式化"><a href="#数字的格式化" class="headerlink" title="数字的格式化"></a>数字的格式化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数字的格式化Format</span></span><br><span class="line"><span class="comment">//当前环境 缺省的格式</span></span><br><span class="line"><span class="type">NumberFormat</span> <span class="variable">f1</span> <span class="operator">=</span> NumberFormat.getInstance();</span><br><span class="line">System.out.println(f1.format(<span class="number">234.55665</span>));	<span class="comment">//234.557</span></span><br><span class="line"><span class="comment">// 当前环境缺省的货币格式</span></span><br><span class="line">f1 = NumberFormat.getCurrencyInstance();</span><br><span class="line">System.out.println(f1.format(<span class="number">2.364588</span>));	<span class="comment">//￥2.36</span></span><br></pre></td></tr></table></figure>

<h3 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h3><ul>
<li><p>DateFormat抽象类:针对日期进行格式化和针对字符串进行解析的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="comment">//当前环境缺省格式</span></span><br><span class="line"><span class="type">DateFormat</span>  <span class="variable">df</span> <span class="operator">=</span> DateFormat.getInstance();</span><br><span class="line">System.out.println(df.format(date));<span class="comment">//18-8-10 上午11:47</span></span><br><span class="line"><span class="comment">//==Date=============================================================</span></span><br><span class="line">df = DateFormat.getDateInstance();</span><br><span class="line">System.out.println(df.format(date));<span class="comment">//2018-8-10</span></span><br><span class="line"></span><br><span class="line">df = DateFormat.getDateInstance(DateFormat.SHORT);</span><br><span class="line">System.out.println(df.format(date));<span class="comment">//18-8-10</span></span><br><span class="line"></span><br><span class="line">df = DateFormat.getDateInstance(DateFormat.MEDIUM);</span><br><span class="line">System.out.println(df.format(date));<span class="comment">//2018-8-10</span></span><br><span class="line"></span><br><span class="line">df = DateFormat.getDateInstance(DateFormat.LONG);</span><br><span class="line">System.out.println(df.format(date));<span class="comment">//2018年8月10日</span></span><br><span class="line"></span><br><span class="line">df = DateFormat.getDateInstance(DateFormat.FULL);</span><br><span class="line">System.out.println(df.format(date));<span class="comment">//2018年8月10日 星期五</span></span><br><span class="line"><span class="comment">//==Time=============================================================</span></span><br><span class="line">df = DateFormat.getTimeInstance();</span><br><span class="line">System.out.println(df.format(date));<span class="comment">//11:50:46</span></span><br><span class="line"></span><br><span class="line">d1 = DateFormat.getTimeInstance(DateFormat.SHORT);</span><br><span class="line">System.out.println(d1.format(date));<span class="comment">// 上午11:58</span></span><br><span class="line"></span><br><span class="line">d1 = DateFormat.getTimeInstance(DateFormat.MEDIUM);</span><br><span class="line">System.out.println(d1.format(date));<span class="comment">// 11:50:46</span></span><br><span class="line"></span><br><span class="line">d1 = DateFormat.getTimeInstance(DateFormat.LONG);</span><br><span class="line">System.out.println(d1.format(date));<span class="comment">// 上午11时58分30秒</span></span><br><span class="line"><span class="comment">//===DateTime=============================================================</span></span><br><span class="line">df = DateFormat.getDateTimeInstance();</span><br><span class="line">System.out.println(df.format(date));<span class="comment">//2018-8-10 11:51:20</span></span><br><span class="line"></span><br><span class="line">df = DateFormat.getDateTimeInstance(DateFormat.FULL,DateFormat.FULL);</span><br><span class="line">System.out.println(df.format(date));<span class="comment">//2018年8月10日 星期五 上午11时52分06秒 CST</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>子类SimpleDateFormat</p>
<ul>
<li><code>SimpleDateFormat(String pattern):给定的模式构造</code><ul>
<li>年 y</li>
</ul>
<ul>
<li>月 M</li>
<li>日 d</li>
<li>时 H</li>
<li>分 m</li>
<li>秒 s</li>
</ul>
</li>
<li><code>public final String format(Date date)</code> 格式化)</li>
<li><code>public Date parse(String source)</code> 解析</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建日期对象</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="comment">// 创建格式化对象</span></span><br><span class="line"><span class="comment">// SimpleDateFormat sdf = new SimpleDateFormat();	//18-7-30 下午5:09(默认格式)</span></span><br><span class="line"><span class="comment">// 给定模式</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">// public final String format(Date date)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sdf.format(d);</span><br><span class="line">System.out.println(s);		<span class="comment">//2018年07月30日 17:07:17</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;2008-08-08 12:12:12&quot;</span>;</span><br><span class="line"><span class="comment">//在把一个字符串解析为日期的时候，请注意格式必须和给定的字符串格式匹配</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">dd</span> <span class="operator">=</span> sdf2.parse(str);</span><br><span class="line">System.out.println(dd);		<span class="comment">//Fri Aug 08 12:12:12 CST 2008</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="jdk8新API"><a href="#jdk8新API" class="headerlink" title="jdk8新API"></a>jdk8新API</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//日期</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">ldate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">ldate = LocalDate.of(<span class="number">2012</span>, <span class="number">1</span>, <span class="number">23</span>);	<span class="comment">//自己设置时间</span></span><br><span class="line">System.out.println(ldate);	<span class="comment">//2012-02-23</span></span><br><span class="line">System.out.println(ldate.getYear());	<span class="comment">//2012</span></span><br><span class="line">System.out.println(ldate.getMonthValue());	<span class="comment">//2</span></span><br><span class="line">System.out.println(ldate.getDayOfMonth());	<span class="comment">//23</span></span><br><span class="line">System.out.println(ldate.getDayOfYear());	<span class="comment">//一年中的第几天54</span></span><br><span class="line">System.out.println(ldate.getDayOfWeek());	<span class="comment">//THURSDAY</span></span><br><span class="line">System.out.println(ldate.plusYears(<span class="number">10</span>));	<span class="comment">//2022-02-23 10年后</span></span><br><span class="line">System.out.println(ldate.minusYears(<span class="number">5</span>));	<span class="comment">//2007-02-23 5年前</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//时间</span></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">ltime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">ltime = LocalTime.of(<span class="number">3</span>, <span class="number">20</span>, <span class="number">23</span>);</span><br><span class="line">System.out.println(ltime);		<span class="comment">//03:20:23</span></span><br><span class="line">System.out.println(ltime.getHour());	<span class="comment">//3</span></span><br><span class="line">System.out.println(ltime.plusHours(<span class="number">10</span>));	<span class="comment">//13:20:23</span></span><br><span class="line">System.out.println(ltime.minusHours(<span class="number">4</span>));	<span class="comment">//23:20:23</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//日期时间</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt1</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">ldt1 = LocalDateTime.of(<span class="number">2012</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ,<span class="number">56</span>);</span><br><span class="line">System.out.println(ldt1);		<span class="comment">//2012-02-03T04:05:56</span></span><br><span class="line">System.out.println(ldt1.getYear());	<span class="comment">//2012</span></span><br><span class="line">System.out.println(ldt1.getDayOfMonth());	<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运算</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt2</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">ldt2 = LocalDateTime.of(<span class="number">2012</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">56</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt3</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">ldt3 = LocalDateTime.of(<span class="number">2012</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">56</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Duration</span> <span class="variable">du</span> <span class="operator">=</span> Duration.between(ldt2, ldt3);</span><br><span class="line">System.out.println(du.toDays());	<span class="comment">//33</span></span><br></pre></td></tr></table></figure>

<h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><ul>
<li>java.lang.Math(不用导包)，针对数学的一个类，方法都式static的</li>
<li>Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。</li>
</ul>
<h3 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public static final double E</td>
<td>自然底数</td>
</tr>
<tr>
<td>public static final double PI</td>
<td>圆周率</td>
</tr>
</tbody></table>
<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public static double <strong>ceil</strong>(double d):</td>
<td>向上取整,获取大于指定参数的最小整数 Math.ceil(33.4) &#x2F;&#x2F;34.0</td>
</tr>
<tr>
<td>public static double <strong>floor</strong>(double d)</td>
<td>向下取整,获取小于指定参数的最大整数 Math.floor(33.4) &#x2F;&#x2F;33.0</td>
</tr>
<tr>
<td>public static long <strong>round</strong>(double d)</td>
<td>四舍五入 Math.round(33.5) &#x2F;&#x2F;34</td>
</tr>
<tr>
<td>public static double pow(double a,double b)</td>
<td>获取a的b次幂,a是底b是指数 Math.pow(2,3) &#x2F;&#x2F;8.0</td>
</tr>
<tr>
<td>public static double random()</td>
<td>产生[0.1)的随机小数</td>
</tr>
<tr>
<td>(int)(Math.rando*(n-m+1)+m)</td>
<td>产生任意范围内[m,n]的随机数</td>
</tr>
<tr>
<td>public static int abs(int a)</td>
<td>取绝对值</td>
</tr>
<tr>
<td>public static int max(int a,int b)</td>
<td>获取最大值</td>
</tr>
<tr>
<td>public static int min(int a, int b)</td>
<td>获取最小值</td>
</tr>
<tr>
<td>public static double sqrt(double a)</td>
<td>获取正平方根</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h2><ul>
<li>随机类<code>java.util.Random</code><ul>
<li>此类用于产生随机数如果用相同的种子创建两个 Random 实例，则对每个实例进行相同的方法调用序列，它们将生成并返回相同的数字序列</li>
</ul>
</li>
</ul>
<h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Random</span><span class="params">()</span>             没有给定种子,使用的是默认的(当前系统的毫秒值)</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Random</span><span class="params">(<span class="type">long</span> seed)</span> 给定一个<span class="type">long</span>类型的种子,给定以后每一次生成的随机数是相同的</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextInt</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextInt</span><span class="params">(<span class="type">int</span> n)</span></span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li><p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建对象</span></span><br><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">r.nextInt(<span class="number">10</span>);<span class="comment">//产生[0,10)之间的随机整理</span></span><br><span class="line">r.nextDouble();<span class="comment">//产生随机小数[0.1)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><ul>
<li>系统级类<ul>
<li>System 类包含一些有用的类字段和方法。它不能被实例化。</li>
<li>系统级操作</li>
</ul>
</li>
</ul>
<h2 id="类与类的关系"><a href="#类与类的关系" class="headerlink" title="类与类的关系"></a>类与类的关系</h2><ul>
<li>在学习面向对象设计时，类关系涉及依赖、关联、聚合、组合和泛化这五种关系</li>
<li>耦合度依次递增。关于耦合度，可以简单地理解为当一个类发生变更时，对其他类造成的影响程度</li>
<li>影响越小则耦合度越弱，影响越大耦合度越强。</li>
</ul>
<h3 id="依赖（Dependency）"><a href="#依赖（Dependency）" class="headerlink" title="依赖（Dependency）"></a>依赖（Dependency）</h3><ul>
<li><p>是一种 <strong>使用</strong> 的 关系.</p>
<ul>
<li>学生使用电脑:学生指向电脑</li>
<li>人使用车:人 指向 车</li>
<li>动物依赖食物: 动物指向食物</li>
</ul>
</li>
<li><p>UML建模语言: <code>虚线 + 箭头</code></p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/42e10e0d/324c059cb9914b42c1407b3dc8cbfa42.png"></p>
</li>
<li><p>A要完成某个功能引用了类B，则类A依赖类B。</p>
<ul>
<li>依赖在代码中主要体现为<strong>类A的某个成员函数的返回值、形参、局部变量或静态方法的调用使用了类B，则表示类A引用了类B</strong>。</li>
</ul>
</li>
</ul>
<h3 id="关联（Association）"><a href="#关联（Association）" class="headerlink" title="关联（Association）"></a>关联（Association）</h3><ul>
<li><p>是一种<strong>拥有</strong>的关系,类之间的关系比依赖要强。学生可以不用电脑，但是学生不能没有老师。</p>
<ul>
<li>学员拥有课程</li>
</ul>
</li>
<li><p>对象拥有的个数分类</p>
<ul>
<li>单向关联，双向关联、自身关联、多维关联。后三个可以不加箭头。</li>
<li>1对1(汽车 和 车位)</li>
<li>1对多(学员 和 多门课程)</li>
<li>多对多(老师 和 学员)</li>
</ul>
</li>
<li><p>UML建模语言:<code>实线 + 箭头</code></p>
</li>
<li><p>相似之处：<br>关联暗示了依赖，二者都用来表示无法用聚合和组合表示的关系。</p>
</li>
<li><p>区别：</p>
<ul>
<li><p>发生依赖关系的两个类都不会增加属性。其中的一个类作为另一个类的方法的参数或者返回值，或者是某个方法的变量而已。</p>
</li>
<li><p>发生关联关系的两个类，类A成为类B的属性，而属性是一种更为紧密的耦合，更为长久的持有关系。</p>
</li>
<li><p>从关系的生命周期来看，</p>
<ul>
<li>依赖关系是仅当类的方法被调用时而产生，伴随着方法的结束而结束。</li>
<li>关联关系当类实例化的时候产生，当类对象销毁的时候关系结束。</li>
<li>相比依赖，关联关系的生存期更长。</li>
</ul>
</li>
</ul>
</li>
<li><p><img src= "/medias/detail/load.gif" data-lazy-src="/p/42e10e0d/621e75a3ad17ed9476698a5c818ddd69.png"></p>
</li>
</ul>
<h3 id="聚合-Aggregation"><a href="#聚合-Aggregation" class="headerlink" title="聚合(Aggregation)"></a>聚合(Aggregation)</h3><ul>
<li><p>聚合是强关联，表示整体和局部，局部离开整体 ,整体可以独立存在(键盘和鼠标)</p>
<ul>
<li>班级与学生之间存在聚合关系</li>
</ul>
</li>
<li><p>UML建模语言:<code>空心菱形 + 箭头</code>,菱形指向整体</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/42e10e0d/f696baac2a2187e93f508ad676b462f3.png"></p>
</li>
</ul>
<h3 id="组合（Composition）"><a href="#组合（Composition）" class="headerlink" title="组合（Composition）"></a>组合（Composition）</h3><ul>
<li><p>组合又叫复合，组合也是聚集的一种。表示整体和局部的关系，局部离开整体整体不可以独立存在(人和心脏)</p>
</li>
<li><p>组合关系中，客户端只认识Student类，根本不知道Heart类的存在，因为心脏类被严密地封装在学生类中。</p>
</li>
<li><p><strong>聚合的成员可独立，复合的成员必须依赖于整体才有意义。</strong></p>
</li>
<li><p>UML建模语言: <code>实心菱形 + 箭头</code> ,实心菱形指向 整体<br><img src= "/medias/detail/load.gif" data-lazy-src="/p/42e10e0d/652f58f21df0ba44aae47aff2f5d207d.png"></p>
</li>
</ul>
<h3 id="泛化-继承"><a href="#泛化-继承" class="headerlink" title="泛化(继承)"></a>泛化(继承)</h3><ul>
<li><p>泛化是学术名称，通俗来讲，泛化指的是类与类之间的继承关系。</p>
</li>
<li><p>UML建模语言: <code>实线 + 空心三角</code>,子类指向 –&gt; 父类</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/42e10e0d/2f42278ddb6e5258014f7786cb21da4a.png"></p>
</li>
</ul>
<h3 id="实现-接口"><a href="#实现-接口" class="headerlink" title="实现(接口)"></a>实现(接口)</h3><ul>
<li><p>表示类与接口之间的实现关系</p>
</li>
<li><p>UML建模语言: <code>虚线 + 空心三角</code>,实现类指向 –&gt; 接口</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/42e10e0d/1a9b2c0db3ea99c6b7762b56ec35ce9f.png"></p>
</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p>依赖、关联、聚合、组合与泛化代表类与类之间的耦合度依次递增。</p>
<ul>
<li>依赖关系实际上是一种比较弱的关联</li>
<li>聚合是一种比较强的关联</li>
<li>组合是一种更强的关联</li>
<li>泛化则是一种最强的关联</li>
<li>所以笼统的来区分的话，实际上这五种关系都是关联关系。</li>
</ul>
</li>
<li><p>依赖关系比较好区分，它是耦合度最弱的一种，在编码中表现为类成员函数的局部变量、形参、返回值或对静态方法的对依赖对象的调用。</p>
</li>
<li><p>关联、聚合与组合在编码形式上都以类成员变量的形式来表示，所以只给出一段代码我们很难判断出是关联、聚合还是组合关系，我们需要从上下文语境中来判别。</p>
<ul>
<li><strong>关联表示类之间存在联系，不存在集体与个体、个体与组成部分之间的关系。</strong></li>
<li><strong>聚合表示类之间存在集体与个体的关系。</strong></li>
<li><strong>组合表示个体与组成部分之间的关系。</strong></li>
</ul>
</li>
<li><p>依赖、关联、聚合与组合是逻辑上的关联，泛化和实现是物理上的关联。</p>
<ul>
<li>物理上的关联指的是类体的耦合，所以类间耦合性最强。</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://fulsun.github.io">凉月</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://fulsun.github.io/p/42e10e0d">https://fulsun.github.io/p/42e10e0d</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://fulsun.github.io" target="_blank">凉月の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/medias/featureimages/012.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/9bc01b38" title="内部类"><img class="cover" src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/012.jpg" onerror="onerror=null;src='/medias/detail/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">内部类</div></div></a></div><div class="next-post pull-right"><a href="/p/db572cd7" title="Java的单例模式,继承,多态，接口和抽象类"><img class="cover" src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/006.jpg" onerror="onerror=null;src='/medias/detail/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java的单例模式,继承,多态，接口和抽象类</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/avatar.jpg" onerror="this.onerror=null;this.src='/medias/detail/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">凉月</div><div class="author-info__description">记录生活,分享知识。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/fulsun"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/fulsun" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:fl_6145@163.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">感谢访问本站，若喜欢请收藏 ^_^</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">final关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final%EF%BC%8Cfinally%EF%BC%8Cfinalize%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-text">final，finally，finalize有什么不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3"><span class="toc-text">深入理解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Objecg%E7%B1%BB"><span class="toc-text">Objecg类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">公用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E6%8B%B7%E8%B4%9D"><span class="toc-text">Java 拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">浅拷贝的实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E7%B1%BB"><span class="toc-text">String类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">拼接字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-%E6%8B%BC%E6%8E%A5"><span class="toc-text">使用+拼接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NULL-%E6%8B%BC%E6%8E%A5"><span class="toc-text">NULL+拼接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%9C%BA%E7%90%86"><span class="toc-text">创建机理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E5%92%8C%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2"><span class="toc-text">String和数字转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E6%8A%80%E6%9C%AF%E7%82%B9"><span class="toc-text">String技术点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E7%B1%BB%E6%98%AF%E5%85%B8%E5%9E%8B%E7%9A%84Immutable%E7%B1%BB"><span class="toc-text">String类是典型的Immutable类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0%E8%80%83%E9%87%8F"><span class="toc-text">字符串设计和实现考量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%93%E5%AD%98"><span class="toc-text">字符串缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">String不可变的好处</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuffer%E4%B8%8EStringBuilder"><span class="toc-text">StringBuffer与StringBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuffer%E7%B1%BB%E6%A6%82%E8%BF%B0"><span class="toc-text">StringBuffer类概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuffer%E5%92%8CString%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-text">StringBuffer和String的相互转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuilder%E7%B1%BB"><span class="toc-text">StringBuilder类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-text">基本类型包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#int%E5%92%8CInteger%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">int和Integer的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-text">安全问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81int%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-text">验证int类型是否线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AtomicInteger%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%89%88"><span class="toc-text">AtomicInteger线程安全版</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%8B%86-%E8%A3%85%E7%AE%B1-1-5%E4%BB%A5%E5%90%8E"><span class="toc-text">自动拆&#x2F;装箱(1.5以后)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">装箱和拆箱的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E5%8F%91%E7%94%9F%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1"><span class="toc-text">何时发生自动装箱和拆箱</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E6%97%B6"><span class="toc-text">赋值时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%97%B6"><span class="toc-text">方法调用时</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-text">自动装箱的弊端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E4%B8%8E%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1"><span class="toc-text">重载与自动装箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9B%B8%E7%AD%89%E6%AF%94%E8%BE%83"><span class="toc-text">对象相等比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Integer"><span class="toc-text">Integer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Integer%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-text">Integer进制转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95-1"><span class="toc-text">成员方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Integer%E7%9A%84%E5%80%BC%E7%BC%93%E5%AD%98%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">Integer的值缓存的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-5-%E4%B8%AD%E5%BC%95%E5%85%A5%E7%BC%93%E5%AD%98%E7%89%B9%E6%80%A7"><span class="toc-text">Java 5 中引入缓存特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IntegerCache%E7%B1%BB"><span class="toc-text">IntegerCache类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%95%B4%E5%9E%8B%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-text">其他整型类型的缓存机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Character%E7%B1%BB%E6%A6%82%E8%BF%B0"><span class="toc-text">Character类概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-1"><span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95-2"><span class="toc-text">成员方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%AC%A6%E5%8F%B7"><span class="toc-text">正则表达式的符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Greedy-%E6%95%B0%E9%87%8F%E8%AF%8D"><span class="toc-text">Greedy 数量词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E8%A1%A8%E7%A4%BA"><span class="toc-text">范围表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E7%AC%A6"><span class="toc-text">定位符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E5%88%87%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">正则切割字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pattern%E5%92%8CMatcher%E7%B1%BB"><span class="toc-text">Pattern和Matcher类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4"><span class="toc-text">时间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Date"><span class="toc-text">Date</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-text">构造方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95-3"><span class="toc-text">成员方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Time"><span class="toc-text">Time</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Calendar%E7%B1%BB"><span class="toc-text">Calendar类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-text">格式化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-text">数字的格式化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-text">日期格式化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jdk8%E6%96%B0API"><span class="toc-text">jdk8新API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Math%E7%B1%BB"><span class="toc-text">Math类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-1"><span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Random%E7%B1%BB"><span class="toc-text">Random类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-2"><span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-text">使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System%E7%B1%BB"><span class="toc-text">System类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">类与类的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%EF%BC%88Dependency%EF%BC%89"><span class="toc-text">依赖（Dependency）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%EF%BC%88Association%EF%BC%89"><span class="toc-text">关联（Association）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88-Aggregation"><span class="toc-text">聚合(Aggregation)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%EF%BC%88Composition%EF%BC%89"><span class="toc-text">组合（Composition）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%8C%96-%E7%BB%A7%E6%89%BF"><span class="toc-text">泛化(继承)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-%E6%8E%A5%E5%8F%A3"><span class="toc-text">实现(接口)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/p/94e3914c" title="Import 注册组件"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/008.jpg" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Import 注册组件"/></a><div class="content"><a class="title" href="/p/94e3914c" title="Import 注册组件">Import 注册组件</a><time datetime="2024-07-15T22:24:08.000Z" title="发表于 2024-07-15 22:24:08">2024-07-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/a0c53761" title="Configuration Bean 注册组件"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/012.jpg" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Configuration Bean 注册组件"/></a><div class="content"><a class="title" href="/p/a0c53761" title="Configuration Bean 注册组件">Configuration Bean 注册组件</a><time datetime="2024-07-15T21:24:08.000Z" title="发表于 2024-07-15 21:24:08">2024-07-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/65826306" title="Spring5新功能"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/008.jpg" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Spring5新功能"/></a><div class="content"><a class="title" href="/p/65826306" title="Spring5新功能">Spring5新功能</a><time datetime="2024-07-14T17:24:08.000Z" title="发表于 2024-07-14 17:24:08">2024-07-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/40bb048a" title="JdbcTemplate与声明式事务"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/013.jpg" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="JdbcTemplate与声明式事务"/></a><div class="content"><a class="title" href="/p/40bb048a" title="JdbcTemplate与声明式事务">JdbcTemplate与声明式事务</a><time datetime="2024-07-14T11:24:08.000Z" title="发表于 2024-07-14 11:24:08">2024-07-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/92933cdb" title="Spring-AOP编程"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/012.jpg" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Spring-AOP编程"/></a><div class="content"><a class="title" href="/p/92933cdb" title="Spring-AOP编程">Spring-AOP编程</a><time datetime="2024-07-14T09:24:38.000Z" title="发表于 2024-07-14 09:24:38">2024-07-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 凉月</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://unpkg.com/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.js"></script><script src="https://unpkg.com/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null

  const initWaline = (Fn) => {
    const waline = Fn(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-fulsun.netlify.app/.netlify/functions/comment',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))

    const destroyWaline = () => {
      waline.destroy()
    }

    btf.addGlobalFn('pjax', destroyWaline, 'destroyWaline')
  }

  const loadWaline = async () => {
    if (initFn) initWaline(initFn)
    else {
      await getCSS('https://unpkg.com/@waline/client@3.1.2/dist/waline.css')
      const { init } = await import('https://unpkg.com/@waline/client@3.1.2/dist/waline.js')
      initFn = init || Waline.init
      initWaline(initFn)
      window.walineFn = initFn
    }
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://unpkg.com/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>