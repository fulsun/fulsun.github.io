<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Git使用(带图) | 凉月の博客</title><meta name="author" content="凉月"><meta name="copyright" content="凉月"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统">
<meta property="og:type" content="article">
<meta property="og:title" content="Git使用(带图)">
<meta property="og:url" content="https://fulsun.github.io/p/ca675cd4">
<meta property="og:site_name" content="凉月の博客">
<meta property="og:description" content="版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fulsun.github.io/medias/featureimages/003.jpg">
<meta property="article:published_time" content="2019-09-26T14:47:05.000Z">
<meta property="article:modified_time" content="2024-10-17T07:06:55.226Z">
<meta property="article:author" content="凉月">
<meta property="article:tag" content="Git">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fulsun.github.io/medias/featureimages/003.jpg"><link rel="shortcut icon" href="/medias/favicon.png"><link rel="canonical" href="https://fulsun.github.io/p/ca675cd4"><link rel="preconnect" href="//unpkg.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"至上次更新后的","messageNext":"天,文章内容可能已过时。"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 凉月","link":"链接: ","source":"来源: 凉月の博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://unpkg.com/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Git使用(带图)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-17 07:06:55'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/avatar.jpg" onerror="onerror=null;src='/medias/detail/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-heartbeat"></i><span> 我的</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> 联系</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user-circle"></i><span> 博主</span></a></li><li><a class="site-page child" href="/contact"><i class="fa-fw fas fa-comments"></i><span> 留言</span></a></li><li><a class="site-page child" href="/journal"><i class="fa-fw fas fa-cogs"></i><span> 日志</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> JS动画</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/snake/"><i class="fa-fw fas fa-gamepad"></i><span> 贪吃蛇</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/medias/featureimages/003.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="凉月の博客"><span class="site-name">凉月の博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-heartbeat"></i><span> 我的</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> 联系</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user-circle"></i><span> 博主</span></a></li><li><a class="site-page child" href="/contact"><i class="fa-fw fas fa-comments"></i><span> 留言</span></a></li><li><a class="site-page child" href="/journal"><i class="fa-fw fas fa-cogs"></i><span> 日志</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-list"></i><span> JS动画</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/snake/"><i class="fa-fw fas fa-gamepad"></i><span> 贪吃蛇</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Git使用(带图)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-09-26T14:47:05.000Z" title="发表于 2019-09-26 14:47:05">2019-09-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-17T07:06:55.226Z" title="更新于 2024-10-17 07:06:55">2024-10-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Git/">Git</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>56分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Git使用(带图)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><span id="more"></span>

<h2 id="版本控制工具"><a href="#版本控制工具" class="headerlink" title="版本控制工具"></a>版本控制工具</h2><h3 id="集中式版本控制工具"><a href="#集中式版本控制工具" class="headerlink" title="集中式版本控制工具"></a>集中式版本控制工具</h3><p>集中化的版本控制系统诸如 CVS，Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，<strong>保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新</strong>。多年以来，这已成为版本控制系统的标准做法</p>
<p>这种做法带来了许多好处，现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个集中化的版本控制系统；要远比在各个客户端上维护本地数据库来得轻松容易</p>
<p>事分两面，有好有坏。这么做最显而易见的缺点是中央服务器的单点故障</p>
<p>如果服务器宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作</p>
<p>并不是说服务器故障了就没有办法写代码了，只是在服务器故障的情况下写的代码是没有办法得到保障的。试想svn中央服务器挂机一天，你还拼命写了天代码，其中12点之前的代码都是高质量可靠的，而且有很多闪光点。而12点之后的代码由于你想尝试一个比较大胆的想法，将代码改的面目全非了。这样下来你12点之前做的工作也都白费了。有记录的版本只能是 svn 服务器挂掉时保存的版本！</p>
<p>要是中央服务器的磁盘发生故障，碰巧没做备份，或者备份不够及时，就会有丢失数据的风险。最坏的情况是彻底丢失整个项目的所有历史更改记录，而被客户端偶然提取出来的保存在本地的某些快照数据就成了恢复数据的希望。但这样的话依然是个问题，你不能保证所有的数据者都已经有人事先完整提取出来过。只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险</p>
<p><strong>集中式总结</strong></p>
<ul>
<li>优点：代码存放在单一的服务器上，便于项目管理</li>
<li>缺点：服务器宕机、故障</li>
</ul>
<h3 id="分布式版本控制工具"><a href="#分布式版本控制工具" class="headerlink" title="分布式版本控制工具"></a>分布式版本控制工具</h3><p>于是分布式版本控制系统面世了。在这类系统中，像 Git、BitKeeper 等，<strong>客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来</strong>。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份</p>
<p>分布式的版本控制系统在管理项目时存放的不是项目版本与版本之间的差异，它存的是索引（所需磁盘空间很少，所以每个客户端都可以放下整个项目的历史记录）</p>
<p>分布式的版本控制系统出现之后，解决了集中式版本控制系统的缺陷：</p>
<ul>
<li>1）断网的情况下也可以进行开发（因为版本控制是在本地进行的）</li>
<li>2）使用 git 业进行团队协作，哪怕 github 挂了，每个客户端保存的也都是整个完整的项目（包含历史记录的！！）</li>
</ul>
<h2 id="Git-简介"><a href="#Git-简介" class="headerlink" title="Git 简介"></a>Git 简介</h2><p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/0262cdfa224b659d972a7cbd4cbde558.png"></p>
<ul>
<li><p>Git 是 Linux 发明者 Linus 开发的一款新时代的版本控制系统 ，版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统，对于软件开发领域来说版本控制是最重要的一环，而 Git 毫无疑问是当下最流行、最好用的版本控制系统。</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/dcea9130ce5ec2b8c56834dbce6bc1a3.png"></p>
</li>
</ul>
<ol>
<li>图中左侧为工作区，右侧为版本库。在版本库中标记为<code>index</code>的区域是暂存区（<code>stage</code>,<code>index</code>），标记为<code>master</code>的是<code>master</code>分支所代表的目录树。</li>
<li>图中我们可以看出此时<code>HEAD</code>指针实际是指向<code>master</code>分支的一个“游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。</li>
<li>图中的<code>objects</code>标识的区域为<code>Git</code>的对象库，实际位于<code>.git/objects</code>目录下。</li>
<li>当对工作区修改（或新增）的文件执行<code>git add</code>命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的<code>ID</code>被记录在暂存区的文件索引中。</li>
<li>当执行提交操作<code>git commit</code>时，暂存区的目录树写到版本库（对象库）中，<code>master</code>分支会做相应的更新。即<code>master</code>指向的目录树就是提交时暂存区的目录树。</li>
<li>当执行<code>git reset HEAD</code>命令时，暂存区的目录树会被重写，被<code>master</code>分支指向的目录树所替换，但是工作区不受影响。</li>
<li>当执行<code>git rm --cached &lt;file&gt;</code>命令时，会直接从暂存区删除文件，工作区则不做出改变。</li>
<li>当执行<code>git checkout .</code>或者<code>git checkout -- &lt;file&gt;</code>命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</li>
<li>当执行<code>git checkout HEAD .</code>或者<code>git checkout HEAD &lt;file&gt;</code>命令时，会用<code>HEAD</code>指向的<code>master</code>分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</li>
</ol>
<h2 id="安装与设置"><a href="#安装与设置" class="headerlink" title="安装与设置"></a>安装与设置</h2><h3 id="Git-安装"><a href="#Git-安装" class="headerlink" title="Git 安装"></a>Git 安装</h3><p>官网地址：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://git-scm.com/">https://git-scm.com/</a></p>
<p>查看 GNU 协议，可以直接点击下一步</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/cd7201594bda5c1a687509d45f05c03c.png"></p>
<p>选择 Git 安装位置，要求是非中文并且没有空格的目录，然后下一步</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/49854cac12d784558ef8b74603f89ee8.png"></p>
<p>Git 选项配置，推荐默认设置，然后下一步</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/589c84e470a6dcec1ac189c46b723f79.png"></p>
<p>Git 安装目录名，不用修改，直接点击下一步</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/6cbf62149bbf0807af0b0b94fb35c5d4.png"></p>
<p>Git 的默认编辑器，建议使用默认的 Vim 编辑器，然后点击下一步</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/56e80fedbcc293279d90cbb3e1674f8b.png"></p>
<p>默认分支名设置，选择让 Git 决定，分支名默认为 master，下一步</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/b9573f37bf83b20abf50b6982e9e7455.png"></p>
<p>修改 Git 的环境变量，选第一个，不修改环境变量，只在 Git Bash 里使用 Git</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/6e782843ba1e906541bf138bf766bc8d.png"></p>
<p>选择后台客户端连接协议，选默认值 OpenSSL，然后下一步</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/967019ba79c88b161fcd47522993c053.png"></p>
<p>配置 Git 文件的行末换行符，Windows 使用 CRLF，Linux 使用 LF，选择第一个自动转换，然后继续下一步</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/4a6880298dd59949ca68f9f2575d2ca2.png"></p>
<p>选择 Git 终端类型，选择默认的 Git Bash 终端，然后继续下一步</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/e62ecaa2c159e3546e362b0a773a612e.png"></p>
<p>选择 Git pull 合并的模式，选择默认，然后下一步</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/108b80229d1a05fe7ca68402b6aa329c.png"></p>
<p>选择 Git 的凭据管理器，选择默认的跨平台的凭据管理器，然后下一步</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/3a5e8cee927bb5420df91324388f7c2a.png"></p>
<p>其他配置，选择默认设置，然后下一步</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/3c75e0c4dd9a67cf5c284a4a4cb27d76.png"></p>
<p>实验室功能，技术还不成熟，有已知的 bug，不要勾选，然后点击右下角的 Install 按钮，开始安装 Git</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/9b698491f95851311373655d14b42365.png"></p>
<p>点击 Finsh 按钮，Git 安装成功！</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/ea57508c2bde6d797c8c0e641b4d8084.png"></p>
<p>右键任意位置，在右键菜单里选择 Git Bash Here 即可打开 Git Bash 命令行终端</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/644e4323836ef7ab9b26a1f1f77a0bf0.png"></p>
<p>在 Git Bash 终端里输入 <code>git --version</code> 查看 git 版本，如图所示，说明 Git 安装成功</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/d2542e4adb67daf9dc0f4dd48393febc.png"></p>
<h3 id="命令查询"><a href="#命令查询" class="headerlink" title="命令查询"></a>命令查询</h3><ul>
<li><p>使用<code>--global</code>参数表示设置了全局的环境，如果想对与特定的项目使用不同的用户名和邮件地址，则可已在该项目目录下不使用<code>--global</code>参数设置不同的用户名和邮件地址。</p>
</li>
<li><p><code>git config --list</code>命令可以列出当前Git所有的配置信息。</p>
</li>
</ul>
<h3 id="设置命令"><a href="#设置命令" class="headerlink" title="设置命令"></a>设置命令</h3><ul>
<li><p>通常情况下，安装完Git后的第一件事就是设置<strong>用户名称</strong>和<strong>邮件地址</strong>。每一个Git的提交都会使用这些信息，如果不设置则无法进行提交。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用户名和邮箱也可以填写别的（只要是用户名和邮箱格式就OK）。</span></span><br><span class="line">git config --global user.name <span class="string">&quot;fl&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;fl_6145@163.com&quot;</span></span><br><span class="line"><span class="comment"># 设置主分支名称</span></span><br><span class="line">git config --global init.defaultBranch main</span><br><span class="line"><span class="comment"># 忽略ssl证书错误 禁用ssl校验</span></span><br><span class="line">git config --global http.sslVerify <span class="literal">false</span></span><br><span class="line"><span class="comment"># 保存密码</span></span><br><span class="line">git config --global credential.helper store</span><br><span class="line"><span class="comment"># 全局过滤列表</span></span><br><span class="line">git config --global core.excludesfile /e/fulsun/Documents/.gitignore_global</span><br><span class="line"><span class="comment"># 回车换行符input:Windows系统上的签出文件中保留CRLF，会在Mac和Linux系统上，包括仓库中保留LF。</span></span><br><span class="line">git config --global core.autocrlf input</span><br><span class="line"><span class="comment"># 查看设置值</span></span><br><span class="line">git config --list</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#.gitignore_global</span></span><br><span class="line">target/</span><br><span class="line">!.mvn/wrapper/maven-wrapper.jar</span><br><span class="line"></span><br><span class="line"><span class="comment">## STS ##</span></span><br><span class="line">.apt_generated</span><br><span class="line">.classpath</span><br><span class="line">.factorypath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">.springBeans</span><br><span class="line"></span><br><span class="line"><span class="comment">## IntelliJ IDEA ##</span></span><br><span class="line">.idea</span><br><span class="line">*.iws</span><br><span class="line">*.iml</span><br><span class="line">*.ipr</span><br><span class="line"></span><br><span class="line"><span class="comment">## JRebel ##</span></span><br><span class="line">rebel.xml</span><br><span class="line">.rebel.xml.bak</span><br><span class="line"></span><br><span class="line"><span class="comment">## MAC ##</span></span><br><span class="line">.DS_Store</span><br><span class="line"></span><br><span class="line"><span class="comment">## Other ##</span></span><br><span class="line">logs/</span><br><span class="line">temp/</span><br><span class="line">——————</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="git别名"><a href="#git别名" class="headerlink" title="git别名"></a>git别名</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.lg1 <span class="string">&quot;log --graph --abbrev-commit --decorate --format=format:&#x27;%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)&#x27; --all&quot;</span></span><br><span class="line"></span><br><span class="line">git config --global alias.lg2 <span class="string">&quot;log --graph --abbrev-commit --decorate --format=format:&#x27;%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n&#x27;&#x27;%C(white)%s%C(reset) %C(dim white)-   %an%C(reset)&#x27; --all&quot;</span></span><br><span class="line"></span><br><span class="line">git config --global alias.lg <span class="string">&#x27;!&quot;git lg1&quot;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="下载问题"><a href="#下载问题" class="headerlink" title="下载问题"></a>下载问题</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.postBuffer 104857600   <span class="comment"># 100MB</span></span><br><span class="line"><span class="comment"># Git缓存值设置为5G 5242880000</span></span><br><span class="line">git config --global http.postBuffer 5242880000</span><br><span class="line">git config --global https.postBuffer 5242880000</span><br></pre></td></tr></table></figure>

<h3 id="status-乱码问题"><a href="#status-乱码问题" class="headerlink" title="status 乱码问题"></a>status 乱码问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotepath false</span><br></pre></td></tr></table></figure>



<h2 id="Git-命令操作"><a href="#Git-命令操作" class="headerlink" title="Git 命令操作"></a>Git 命令操作</h2><ul>
<li><p>命令行（win + R），输入 cmd 后，输入 git可以判断是否成功安装。</p>
</li>
<li><p>网上找了个图，别人整理的一张图，很全很好，借来用下。下面详细解释一些常用命令。</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/9c8eed5631ca72b7c8f2752de66ca8d5.jpg"></p>
</li>
</ul>
<h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><ul>
<li><p>在掌握具体命令前，先理解下<code>HEAD</code>。<code>HEAD</code>，它始终指向当前所处分支的最新的提交点。你所处的分支变化了，或者产生了新的提交点，HEAD就会跟着改变。</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/fe6eb28040c4dbdd828c93970a335c08.png"></p>
</li>
</ul>
<h3 id="Init-Clone"><a href="#Init-Clone" class="headerlink" title="Init&#x2F;Clone"></a>Init&#x2F;Clone</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化本地库</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浅尝clone： depth的参数控制着clone最近多少次的提交。</span></span><br><span class="line">git <span class="built_in">clone</span> &lt;版本库的网址&gt; &lt;本地目录名&gt;</span><br><span class="line">git <span class="built_in">clone</span> --depth=1 http://xxx.git</span><br><span class="line">git <span class="built_in">clone</span> --depth=1 git@github.com:xxx.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取完整当前分支</span></span><br><span class="line">git fetch --unshallow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 追踪所有远程分支</span></span><br><span class="line">git remote set-branches origin <span class="string">&#x27;*&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取所有远程分支</span></span><br><span class="line">git fetch -v</span><br></pre></td></tr></table></figure>

<ul>
<li><p>以上2种clone 方式有如下区别：</p>
<ul>
<li>https方式：不管是谁，只要拿到该项目的 url 可以随便 clone，但是在 push 到远程的时候需要验证用户名和密码；</li>
<li>ssh方式：需要现将你电脑的SSH key（SSH公钥）添加到GitHub（或者其他代码托管网站）上，这样在 clone 项目和 push 项目到远程时都不需要输入用户名和密码。</li>
<li>通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考<a target="_blank" rel="noopener external nofollow noreferrer" href="http://git-scm.com/book/en/Git-on-the-Server-The-Protocols">官方文档</a>。</li>
</ul>
</li>
<li><p><code>git clone</code>支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> http[s]://example.com/path/to/repo.git</span><br><span class="line">git <span class="built_in">clone</span> ssh://example.com/path/to/repo.git</span><br><span class="line">git <span class="built_in">clone</span> git://example.com/path/to/repo.git</span><br><span class="line">git <span class="built_in">clone</span> /opt/git/project.git</span><br><span class="line">git <span class="built_in">clone</span> file:///opt/git/project.git</span><br><span class="line">git <span class="built_in">clone</span> ftp[s]://example.com/path/to/repo.git</span><br><span class="line">git <span class="built_in">clone</span> rsync://example.com/path/to/repo.git</span><br><span class="line"><span class="comment"># SSH协议还有另一种写法</span></span><br><span class="line">git <span class="built_in">clone</span> [user@]example.com:path/to/repo.git</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><ul>
<li><p>git status 这个命令顾名思义就是查看状态，这个命令可以算是使用最频繁的一个命令了，建议大家没事就输入下这个命令，来查看你当前 git 仓库的一些状态。一般会显示当前所处的分支，以及当前工作区是否干净，是否有文件要提交。</p>
</li>
<li><p>当你克隆远程仓库到本地后，通过该命令查看当前状态时，显示信息如下图所示：</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/3954c41c0552dfd738a556e9e5505c67.png"></p>
</li>
<li><p>当你修改了一个文件后，再用该命令查看当前状态，它会提示你把当前的变更添加到暂存区或者丢弃该变更，显示信息如下图所示：</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/ae4e43d09943427e2f14e8fea25b2442.png"></p>
</li>
<li><p>当你新增一个文件后，用该命令查看当前状态，它会显示新增的文件状态是未跟踪，并且提示用<code>git add</code>命令将其添加到暂存区，显示信息如下图所示：</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/d4c584ccb6fc4480e3f1a71c5956c935.png"></p>
</li>
</ul>
<h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p>新建立一个文件，输入 <code>git status</code> 后查看 ，Untracked files ，就是说 a.md 这个文件还没有被跟踪输入 <code>git add a.md</code>，然后再输入 <code>git status</code> :提示以下文件 Changes to be committed ， 意思就是 a.md 文件等待被提交，当然你可以使用 <code>git rm --cached</code> 这个命令去移除这个缓存.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区 </span></span><br><span class="line">git add .</span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line">git add [<span class="built_in">dir</span>]</span><br><span class="line"><span class="comment"># 添加指定的文件到暂存区</span></span><br><span class="line">git add [file1] </span><br><span class="line"><span class="comment"># 使用命令，删除暂存区该文件（只是删除暂存区，不影响工作区）</span></span><br><span class="line">git <span class="built_in">rm</span> --cached hello.txt</span><br></pre></td></tr></table></figure>



<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/db1ef4c79097864093409dd125445a2e.png"></p>
<h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -m 表示添加一个版本日志信息，不写此参数也会打开日志信息的文件框。一般带参数</span></span><br><span class="line"><span class="comment"># 提交暂存区到本地仓库，message代表说明消息</span></span><br><span class="line">git commit -m [message] </span><br><span class="line"><span class="comment"># 提交暂存区的指定文件到本地仓库</span></span><br><span class="line">git commit [file1] -m [message]</span><br><span class="line"><span class="comment"># 使用一次新的commit，替代上一次提交 </span></span><br><span class="line">git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存后，git 里是按照行维护文件， 会将本次修改行数信息进行提示</span></span><br><span class="line"><span class="comment"># 1 insertion(+), 1 deletion(-)</span></span><br></pre></td></tr></table></figure>



<h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><p>这个时候我们输入 <code>git log</code> 命令，查看所有产生的 commit 记录，所以可以看到已经产生了一条 commit 记录，而提交时候的附带信息叫 ‘first commit’ 。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看精简版本信息</span></span><br><span class="line">git reflog</span><br><span class="line"><span class="comment"># 查看详细版本信息</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"><span class="comment"># 以图形的方式查看历史（这个我比较常用，能很好的显示各个分支之间的关系）</span></span><br><span class="line">$ git <span class="built_in">log</span> --graph </span><br></pre></td></tr></table></figure>

<ul>
<li><p>git log</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/f969a55200122e6ff44f620c2e040a52.png"></p>
</li>
<li><p>–graph 左边显示出了分支的图形</p>
</li>
</ul>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/7aa3796913296eb60fe03e54ab39d446.png"></p>
<h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><ul>
<li><p>diff 显示变更内容, 当你对文件进行了修改，想查看进行了哪些修改时，可以通过该命令查看。</p>
</li>
<li><p><code>git diff</code>命令会显示修改的文件中哪些内容进行了修改，包括新增了哪些内容，删除了哪些内容。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 后面不接参数，表示显示所有修改文件的变更</span></span><br><span class="line">git diff</span><br><span class="line"><span class="comment"># 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line">git diff HEAD</span><br><span class="line"><span class="comment"># 后面接文件名，表示只显示该文件的变更</span></span><br><span class="line">git diff README.md</span><br></pre></td></tr></table></figure>
</li>
<li><p>例如：我对 <code>README.md</code> 文件进行了修改，删除了1行，新增了2行，然后用该命令查看进行了哪些修改，如下图所示： （<code>“+”</code> 表示新增的内容，<code>“-”</code> 表示删除的内容）</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/d13cfe3a76b78233572793a957aeb0e1.png"></p>
</li>
</ul>
<h3 id="git-add-git-commit"><a href="#git-add-git-commit" class="headerlink" title="git add &amp; git commit"></a>git add &amp; git commit</h3><p>看到这里估计很多人会有疑问，我想要提交直接进行 commit 不就行了么，为什么先要再 add一次呢？</p>
<p>首先 <code>git add</code> 是先把改动添加到一个「暂存区」，你可以理解成是一个缓存区域，临时保存你的改动，而 <code>git commit</code> 才是最后真正的提交。这样做的好处就是防止误提交。</p>
<p>当然也有办法把这两步合并成一步，为了实现一次性进行add和commit，我们可以使用<code>git commit -a</code>命令。这个命令的含义是将当前Git跟踪的所有已修改的文件一并提交，并且会自动将这些文件添加到暂存区。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -a 参数的作用是将所有已修改的文件添加到暂存区，</span></span><br><span class="line"><span class="comment"># -m 参数用来设置提交信息。</span></span><br><span class="line">git commit -am <span class="string">&quot;Initial commit&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h3><ul>
<li><p>reset命令把当前分支指向另一个位置，并且相应的变动工作区和暂存区。</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/bff477cc2019d196f212f178473c9539.png"></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git reset –soft [commit]</td>
<td>只改变提交点，暂存区和工作目录的内容都不改变</td>
</tr>
<tr>
<td>git reset –mixed [commit]</td>
<td>只改变提交点，同事改变暂存区的内容</td>
</tr>
<tr>
<td>git reset –hard [commit]</td>
<td>暂存区和工作区的内容都会被修改到与提交点完全一致的状态</td>
</tr>
<tr>
<td>git reset –hard HEAD</td>
<td>让工作区回到上次提交的状态</td>
</tr>
</tbody></table>
<ul>
<li><p>我们可以先用 <code>git log</code> 看一下当前历史版本，如下图所示：</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/322528558c618347874bf0cd02cd6ebd.png"></p>
</li>
<li><p>如果要回退到前一个版本，则只需要输入：<code>git reset HEAD~1</code>，执行完再看一下历史版本：</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/f5c6b8e300607462ef6a97b4882cfb6f.png"></p>
</li>
<li><p>我们已经回退到前一个版本了。如果需要回退到前2个版本，命令是：<code>git reset HEAD~2</code>，回退到前n个版本就是：<code>git reset HEAD~n</code></p>
</li>
<li><p>如果需要回退到任何一个版本，则需要替换成该版本的 <code>commit id</code> 就可以了，例如：<code>git reset a8336834b50daafa0793370</code>，执行完再看一下历史：</p>
</li>
</ul>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/39574bf790cffe8692fb9210f36c488c.png"></p>
<h3 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h3><ul>
<li><p>git revert用一个新提交来消除一个历史提交所做的任何修改。</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/7f680adf5d09d71f48ffa85b23bd20db.png"></p>
</li>
</ul>
<h3 id="revert与reset的区别"><a href="#revert与reset的区别" class="headerlink" title="revert与reset的区别"></a>revert与reset的区别</h3><p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/71d811f0cc95d2e331a5b4c8b8a796c7.png"></p>
<ul>
<li><p>git revert是用一次新的commit来回滚之前的commit</p>
</li>
<li><p>git reset是直接删除指定的commit。</p>
</li>
<li><p>在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。</p>
<ul>
<li>因为git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，减少冲突。</li>
<li>但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入，产生很多冲突。</li>
</ul>
</li>
<li><p>git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。</p>
</li>
</ul>
<h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><ul>
<li><p>我们在客户端开发的时候经常有版本的概念，比如v1.0、v1.1之类的，不同的版本肯定对应不同的代码，所以我一般要给我们的代码加上标签，这样假设v1.1版本出了一个新bug，但是又不晓得v1.0是不是有这个bug，有了标签就可以顺利切换到v1.0的代码，重新打个包测试了。</p>
</li>
<li><p>所以如果想要新建一个标签很简单，比如 <code>git tag v1.0</code>就代表我在当前代码状态下新建了一个v1.0的标签，输入 <code>git tag</code> 可以查看历史 tag 记录。</p>
</li>
<li><p>想要切换到某个tag怎么办？也很简单，执行 <code>git checkout v1.0</code> ，这样就顺利的切换到 v1.0tag的代码状态了。</p>
</li>
<li><p>截止到图中的最近一次提交，我们完成了 1.0 版本的开发，则可以通过以下命令为其打上版本的标签。</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/98d826e32af1ff2b0cc67c5797a2a7ed.png"></p>
<ul>
<li><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0 //为当前提交打上 v1.0 的标签</span><br><span class="line">git tag v1.0 ab1591eb4e06c1e93fdd50126b9fab8a88d89155 //为这个节点打上 v1.0 的标签</span><br></pre></td></tr></table></figure>

<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/bcbcadaa84b5c30ffb6fbc80d9215e09.png"></p>
</li>
<li><p>图中可以看出 v1.0 标签已经打上了。 如果发现标签打错了，想删除某个标签，则可以通过如下命令来执行。 命令：<code>git tag -d v1.0</code> 删除 v1.0 标签</p>
</li>
<li><p>如果想将标题推送到远程库，则可以使用如下命令来完成。 命令：<code>git push origin --tags</code> 将打的 tag 都推送到远程库</p>
</li>
</ul>
</li>
</ul>
<h3 id="git-show"><a href="#git-show" class="headerlink" title="git show"></a>git show</h3><ul>
<li><p>显示信息,可用于显示某次提交或者某个 tag 相关的信息。</p>
</li>
<li><p>命令：<code>git show commit_id</code> 显示某次提交的详细信息</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/6c11f417aba9471f3c82ee4b99804870.png"></p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/76c37ce6e20a6217a3f34389d997cdc7.png"></p>
</li>
<li><p>命令：<code>git show tag_name</code> 显示某个 tag 的详细信息</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/8b9c9b5203da7d615d58b255439534f8.png"></p>
</li>
</ul>
<h3 id="git-blame"><a href="#git-blame" class="headerlink" title="git blame"></a>git blame</h3><ul>
<li><p>查看文件每行的提交历史（追责）,可用于查看某个文件中的每一行是那次提交产生的，是谁提交的，什么时候提交的，提交的版本号是多少等等详细信息，在实际工作中方便对出问题的代码进行追责，找到产生 BUG 的责任人。</p>
</li>
<li><p>命令：<code>git blame file_name</code></p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/3ae900574dd64d43a4f4bb6f2370b578.png"></p>
</li>
<li><p>上图中可以看到 <code>README.md</code> 这个文件有 5 行，其中后 4 行都是我在 2018 年提交的，第 1 行是另外一个人在 2017 年提交的。</p>
</li>
</ul>
<h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><p>为了便于管理，Git要求每个远程主机都必须指定一个主机名。<code>git remote</code>命令就用于管理主机名。不带选项的时候，<code>git remote</code>命令列出所有远程主机。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有远程主机 -v选项，可以参看远程主机的网址</span></span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 克隆版本库的时候，所使用的远程主机自动被Git命名为origin。</span></span><br><span class="line"><span class="comment"># 如果想用其他的主机名，需要用git clone命令的-o选项指定。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看该主机的详细信息 git remote show origin</span></span><br><span class="line">git remote show &lt;主机名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加远程主机。</span></span><br><span class="line">git remote add &lt;主机名&gt; &lt;网址&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程主机</span></span><br><span class="line">git remote <span class="built_in">rm</span> &lt;主机名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程主机的改名</span></span><br><span class="line">git remote rename &lt;原主机名&gt; &lt;新主机名&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p>一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到<code>git fetch</code>命令。</p>
<blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch &lt;远程主机名&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令将某个远程主机的更新，全部取回本地。</p>
<p><code>git fetch</code>命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。</p>
<p>默认情况下，<code>git fetch</code>取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。</p>
<blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch &lt;远程主机名&gt; &lt;分支名&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>比如，取回<code>origin</code>主机的<code>master</code>分支。</p>
<blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin master</span><br></pre></td></tr></table></figure>
</blockquote>
<p>所取回的更新，在本地主机上要用”<code>远程主机名/分支名</code>“的形式读取。比如<code>origin</code>主机的<code>master</code>，就要用<code>origin/master</code>读取。</p>
<p><code>git branch</code>命令的<code>-r</code>选项，可以用来查看远程分支，<code>-a</code>选项查看所有分支。</p>
<blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -r</span><br><span class="line">origin/master</span><br><span class="line"></span><br><span class="line">$ git branch -a</span><br><span class="line">* master</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令表示，本地主机的当前分支是<code>master</code>，远程分支是<code>origin/master</code>。</p>
<p>取回远程主机的更新以后，可以在它的基础上，使用<code>git checkout</code>命令创建一个新的分支。</p>
<blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b newBrach origin/master</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令表示，在<code>origin/master</code>的基础上，创建一个新分支。</p>
<p>此外，也可以使用<code>git merge</code>命令或者<code>git rebase</code>命令，在本地分支上合并远程分支。</p>
<blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git merge origin/master</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ git rebase origin/master</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令表示在当前分支上，合并<code>origin/master</code>。</p>
<h2 id="Git-分支操作"><a href="#Git-分支操作" class="headerlink" title="Git 分支操作"></a>Git 分支操作</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git branch</td>
<td>列出本地所有分支</td>
</tr>
<tr>
<td>git branch -r</td>
<td>列出所有远程分支</td>
</tr>
<tr>
<td>git branch -a</td>
<td>列出所有本地分支和远程分支</td>
</tr>
<tr>
<td>git branch [branch-name]</td>
<td>新建一个分支，但是停留在当前分支</td>
</tr>
<tr>
<td>git branch -b [branch-name]</td>
<td>新建一个分支并切换到该分支</td>
</tr>
<tr>
<td>git branch –track [branch][remote-branch]</td>
<td>新建一个分支，与指定的分支建立追踪关系</td>
</tr>
<tr>
<td>git checkout [branch-name]</td>
<td>切换到指定的分区，并更新工作区</td>
</tr>
<tr>
<td>git branch -d [branch-name]</td>
<td>删除分支</td>
</tr>
<tr>
<td>git push origin –delete [branch-name]</td>
<td>删除远程分支，不要加 origin&#x2F;</td>
</tr>
</tbody></table>
<h3 id="什么是分支"><a href="#什么是分支" class="headerlink" title="什么是分支"></a>什么是分支</h3><p>在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行。对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本（分支底层其实也是指针的引用）</p>
<p>分支的好处：同时并行推进多个功能开发，<strong>提高开发效率</strong>，各个分支在开发过程中，如果某一个分支开发失败，<strong>不会对其他分支有任何影响</strong>。失败的分支删除重新开始即可</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/64cda4e8f24139a5a271d814cca633a0.png"></p>
<h3 id="创建-查看分支"><a href="#创建-查看分支" class="headerlink" title="创建&#x2F;查看分支"></a>创建&#x2F;查看分支</h3><p>执行<code>git init</code> 初始化git仓库之后会默认生成一个主分支 master ，也是你所在的默认分支，也基本是实际开发正式环境下的分支，一般情况下 master 分支不会轻易直接在上面操作的，你们可以输入 <code>git branch</code>查看下当前分支情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建了一个名字叫 [name] 的分支</span></span><br><span class="line">git branch [name]</span><br><span class="line"><span class="comment"># 查看的当前分支情况, * 号表示当前分支</span></span><br><span class="line">git branch</span><br><span class="line">git branch -v</span><br></pre></td></tr></table></figure>

<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/2bca7ad8ce31e244b61c97e72a1af041.png"></p>
<h3 id="checkout-分支"><a href="#checkout-分支" class="headerlink" title="checkout 分支"></a>checkout 分支</h3><p>切换分支执行这个命令<code>git checkout [branchName]</code>,那有人就说了，我要先新建再切换，未免有点麻烦，有没有一步到位的，聪明： <code>git checkout -b [branchName]</code> 这个命令的意思就是<strong>新建分支，并且自动切换到分支</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换分支 </span></span><br><span class="line">git checkout 分支名</span><br><span class="line"><span class="comment"># 创建并切换分支</span></span><br><span class="line">git checkout -b [branchName]</span><br></pre></td></tr></table></figure>

<h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>有新建分支，那肯定有删除分支，假如这个分支新建错了，或者a分支的代码已经顺利合并到master 分支来了，那么a分支没用了， 就可以把a分支删除了。</p>
<p>有些时候可能会删除失败，比如如果a分支的代码还没有合并到master，你执行 <code>git branch -d a</code> 是删除不了的，它会智能的提示你a分支还有未合并的代码，但是如果你非要删除，那就执行 <code>git branch -D a</code> 就可以强制删除a分支。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">git branch -d [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除 </span></span><br><span class="line">git branch -D</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果远程主机删除了某个分支，默认情况下，<code>git pull</code> 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致<code>git pull</code>不知不觉删除了本地分支。但是，你可以改变这个行为，加上参数 <code>-p</code> 就会在本地删除远程已经删除的分支。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull -p</span><br></pre></td></tr></table></figure>





<h3 id="merge分支"><a href="#merge分支" class="headerlink" title="merge分支"></a>merge分支</h3><ul>
<li><p>merge命令把不同的分支合并起来。如图，在实际开放中，我们可能从master分支中切出一个分支，然后进行开发完成需求，中间经过R3,R4,R5的commit记录，最后开发完成需要合入master中，这便用到了merge。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># merge之前先拉一下远程仓库最新代码</span></span><br><span class="line">git fetch [remote]</span><br><span class="line"><span class="comment"># 合并指定分区到当前分区</span></span><br><span class="line">git merge [branch]</span><br></pre></td></tr></table></figure>



<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/a7d27fbc0734d64989ac8968e6baacd3.png"></p>
</li>
<li><p>A同学在a分支代码写的不亦乐乎，终于他的功能完工了，并且测试也都ok了，准备要上线了，这个时候就需要把他的代码合并到主分支master上来，然后发布。<code>git merge</code> 就是合并分支用到的命令. 针对这个情况，需要先做两步，</p>
<ul>
<li>第一步是切换到 master 分支，如果你已经在了就不用切换了</li>
<li>第二步执行 <code>git merge a</code>，意思就是把a分支的代码合并过来，不出意外， 这个时候a分支的代码就顺利合并到 master 分支来了。</li>
<li>为什么说不出意外呢？因为这个时候可能会有冲突而合并失败。</li>
</ul>
</li>
</ul>
<h4 id="正常合并"><a href="#正常合并" class="headerlink" title="正常合并"></a>正常合并</h4><p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/d0985d38e9d099bb6b8e0754338b87d3.png"></p>
<h4 id="冲突合并"><a href="#冲突合并" class="headerlink" title="冲突合并"></a>冲突合并</h4><p>冲突产生的原因：合并分支时，两个分支在同一个文件的同一个位置有两套完全不同的修改。Git无法替我们决定使用哪一个。必须人为决定新代码内容</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/6d6ad52de64eb852ad2c92ab1e076fee.png"></p>
<h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/696a4885920f892885023d3b38662cb3.png"></p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/3579ae4d95a5cb37a0f5988904b9fd72.png"></p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/fe40db0288aa9afb1ffc7a9a9d540f2c.png"></p>
<h3 id="rebase分支"><a href="#rebase分支" class="headerlink" title="rebase分支"></a>rebase分支</h3><ul>
<li><p>rebase又称为衍合，是合并的另外一种选择。</p>
</li>
<li><p>在开始阶段，我们处于new分支上，执行<code>git rebase dev</code>，那么new分支上新的commit都在master分支上重演一遍，最后checkout切换回到new分支。这一点与merge是一样的，合并前后所处的分支并没有改变。</p>
</li>
<li><p><code>git rebase dev</code>，通俗的解释就是new分支想站在dev的肩膀上继续下去。<strong>rebase也需要手动解决冲突</strong>。</p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/dc0e905278c6efc7bcb03b588125ad8c.png"></p>
</li>
<li><p>使用说明：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://links.jianshu.com/go?to=https://git-scm.com/docs/git-rebase">https://git-scm.com/docs/git-rebase</a></p>
<ul>
<li>不要通过rebase对任何已经提交到公共仓库中的commit进行修改，</li>
<li>不要在master分支上rebase，在master分支上rebase就会出现游离分支。</li>
<li>正常做法是比如在dev分支开发，然后需要的话在dev分支rebase，然后再merge到master</li>
</ul>
</li>
</ul>
<h4 id="准备示例"><a href="#准备示例" class="headerlink" title="准备示例"></a>准备示例</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们初始化一个项目</span></span><br><span class="line">git init</span><br><span class="line"><span class="comment"># 制造一些提交</span></span><br><span class="line"><span class="built_in">touch</span> base.txt</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;add base&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">touch</span> 1.txt</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;add 1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">touch</span> 2.txt</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;add 2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">touch</span> 3.txt</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;add 3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">touch</span> 4.txt</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;add 4&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">touch</span> 5.txt</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;add 5&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="合并commit"><a href="#合并commit" class="headerlink" title="合并commit"></a>合并commit</h4><ul>
<li><p>命令 <code>git rebase -i  [startpoint]  [endpoint]</code></p>
<ul>
<li><code>-i </code>的意思是 <code>--interactive</code>，即弹出交互式的界面让用户编辑完成合并操作，</li>
<li><code>[startpoint]</code> <code> [endpoint]</code> 则指定了一个编辑区间，如果不指定<code>[endpoint]</code>，则该区间的终点默认是当前分支HEAD所指向的commit(注：该区间指定的是一个<strong>前开后闭的区间</strong>)。</li>
</ul>
</li>
<li><p>合并多个commit为一个完整commit</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在查看到了log日志后，我们运行以下命令：</span></span><br><span class="line">* 09b85cb - (17 minutes ago) add 5 - XXX (HEAD -&gt; main)</span><br><span class="line">* 0f89d77 - (17 minutes ago) add 4 - XXX</span><br><span class="line">* 6c82fb4 - (17 minutes ago) add 3 - XXX</span><br><span class="line">* 4c4e075 - (17 minutes ago) add 2 - XXX</span><br><span class="line">* eda0aa7 - (17 minutes ago) add 1 - XXX</span><br><span class="line">* e90bc6c - (17 minutes ago) add base - XXX</span><br></pre></td></tr></table></figure>
</li>
<li><p>把如下分支add 4&#x2F;5二个提交记录合并为一个完整的提交，然后再push到公共仓库。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 合并最近二次提交 需要选择二次提交的前一个提交</span></span><br><span class="line">git rebase -i 6c82fb4</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">git rebase -i HEAD~2</span><br></pre></td></tr></table></figure>
</li>
<li><p>出交互式的界面，我们可以编辑说明</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pick 0f89d77 add 4</span><br><span class="line">pick 09b85cb add 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rebase 6c82fb4..09b85cb onto 6c82fb4 (2 commands)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line">每一个commit <span class="built_in">id</span> 前面的pick表示指令类型，git 为我们提供了以下几个命令:</span><br><span class="line">pick：保留该commit（缩写:p）</span><br><span class="line">reword：保留该commit，但我需要修改该commit的注释（缩写:r）</span><br><span class="line">edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）</span><br><span class="line">squash：将该commit和前一个commit合并（缩写:s）</span><br><span class="line">fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）</span><br><span class="line"><span class="built_in">exec</span>：执行shell命令（缩写:x）</span><br><span class="line">drop：我要丢弃该commit（缩写:d）</span><br><span class="line"></span><br><span class="line"><span class="comment">## 合并add 5到add 4</span></span><br><span class="line">pick 0f89d77 add 4</span><br><span class="line">s 09b85cb add 5</span><br></pre></td></tr></table></figure>
</li>
<li><p>保存后是注释修改界面，修改保存后查看日志</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\sfuli\Desktop\<span class="built_in">test</span>&gt; git lg</span><br><span class="line">* 7290f75 - (31 minutes ago) add 4 5 - XXX (HEAD -&gt; main)</span><br><span class="line">* 6c82fb4 - (31 minutes ago) add 3 - XXX</span><br><span class="line">* 4c4e075 - (31 minutes ago) add 2 - XXX</span><br><span class="line">* eda0aa7 - (31 minutes ago) add 1 - XXX</span><br><span class="line">* e90bc6c - (31 minutes ago) add base - XXX</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="commit粘到其他分支"><a href="#commit粘到其他分支" class="headerlink" title="commit粘到其他分支"></a>commit粘到其他分支</h4><ul>
<li><p>当我们项目中存在多个分支，有时候我们需要将<strong>某一个分支中的一段commit记录 同时应用到其他分支中</strong></p>
</li>
<li><p>我们希望将develop分支中的C~E部分复制到master分支中，这时我们就可以通过rebase命令来实现（如果只是复制某一两个提交到其他分支，建议使用更简单的命令:<code>git cherry-pick</code>）。</p>
</li>
<li><p>命令： <code>git rebase   [startpoint]   [endpoint]  --onto  [branchName]</code></p>
<ul>
<li><code>[startpoint] [endpoint]</code> 仍然和上一个命令一样指定了一个编辑区间(<strong>前开后闭</strong>)</li>
<li><code>--onto</code> 的意思是要将该指定的提交复制到哪个分支上。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将develop分支中的C~E部分复制到master分支中</span></span><br><span class="line"><span class="comment"># 为了让这个区间包含C（90bc0045b）提交，我们将区间起始点向后退了一步。C(90bc0045b)和E(5de0da9f2)</span></span><br><span class="line">git rebase 90bc0045b^ 5de0da9f2 --onto master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行完成后虽然此时HEAD所指向的内容正是我们所需要的，但是master分支是没有任何变化的</span></span><br><span class="line"><span class="comment"># git只是将C~E部分的提交内容复制一份粘贴到了master所指向的提交后面</span></span><br><span class="line"><span class="comment"># 我们需要做的就是将master所指向的提交id设置为当前HEAD所指向的提交id</span></span><br><span class="line"><span class="comment"># 即</span></span><br><span class="line">git checkout master</span><br><span class="line">git reset --hard  0c72e64</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="rebase与merge的区别"><a href="#rebase与merge的区别" class="headerlink" title="rebase与merge的区别"></a>rebase与merge的区别</h3><ul>
<li><p><strong>merge操作会生成一个新的节点，之前的提交分开显示。</strong></p>
</li>
<li><p><strong>rebase操作不会生成新的节点，是将两个分支融合成一个线性的提交。</strong></p>
</li>
<li><p>现在我们有这样的两个分支,test和master，提交如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      D---E <span class="built_in">test</span></span><br><span class="line">     /</span><br><span class="line">A---B---C---F master</span><br></pre></td></tr></table></figure>
</li>
<li><p>在master执行 <code>git merge test</code>，然后得到如下结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      D--------E</span><br><span class="line">     /</span><br><span class="line">A---B---C---F----G   <span class="built_in">test</span>, master</span><br></pre></td></tr></table></figure>
</li>
<li><p>在master执行 <code>git rebase test</code>，然后得到如下结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A---B---D---E---C<span class="string">&#x27;---F&#x27;</span>   <span class="built_in">test</span>, master</span><br></pre></td></tr></table></figure>

</li>
<li><p>如果你想要一个干净的，没有merge commit的线性历史树，那么你应该选择git rebase</p>
</li>
<li><p>如果你想保留完整的历史记录，并且想要避免重写commit history的风险，你应该选择使用git merge</p>
</li>
</ul>
<h4 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h4><ul>
<li><p>挑拣节点合并到当前分支上,该命令一般用于从其他分支上挑拣某些节点到当前分支。</p>
</li>
<li><p>命令：<code>git cherry-pick commit_id</code></p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/0501395240afb80977a35fb827a7d0b7.png"></p>
</li>
<li><p>上图中我想把 ruby_client 分支上的 e43a6 这个节点合并到 master 分支上，但不需要 5ddae 这个节点，那么我们就可以使用下面的命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master // 先切换到 master 分支</span><br><span class="line">$ git cherry-pick e43a6 //将 e43a6 节点挑拣合并到当前分支</span><br></pre></td></tr></table></figure>
</li>
<li><p>完成后如下图所示： <strong>注意：该节点被挑拣合并到 master 上后会产生一个新的节点a0a41</strong></p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/2616ffc2673fadfe0ede5877bd344811.png"></p>
</li>
</ul>
<h4 id="创建分支和切换分支图解"><a href="#创建分支和切换分支图解" class="headerlink" title="创建分支和切换分支图解"></a>创建分支和切换分支图解</h4><p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/0b700af7f1a49ad2b22b14549a6f89e6.png"></p>
<p><img src= "/medias/detail/load.gif" data-lazy-src="/p/ca675cd4/e28ada347f6872c28d22153886a08d3b.png"></p>
<p>master、hot-fix 其实都是指向具体版本记录的指针。当前所在的分支，其实是由 HEAD 决定的。所以创建分支的本质就是多创建一个指针</p>
<ul>
<li>HEAD 如果指向 master，那么我们现在就在 master 分支上</li>
<li>HEAD 如果指向 hotfix，那么我们现在就在 hotfix 分支上</li>
</ul>
<p>所以切换分支的本质就是移动HEAD指针</p>
<h3 id="stash分支"><a href="#stash分支" class="headerlink" title="stash分支"></a>stash分支</h3><ul>
<li><p><code>git stash</code>命令：将当前未提交的修改(即，工作区的修改和暂存区的修改)先暂时储藏起来，这样工作区干净了后，就可以切换切换到master分支下拉一个fix分支。在完成线上bug的修复工作后，重新切换到dev分支下通过<code>git stash pop</code>命令将之前储藏的修改取出来，继续进行新功能的开发工作</p>
</li>
<li><p>没有在git 版本控制中的文件，是不能被<code>git stash</code> 存起来的</p>
</li>
<li><p>常规<code>git stash</code>的一个限制是它会一下暂存所有的文件。有时，只备份某些文件更为方便，让另外一些与代码库保持一致。一个非常有用的技巧，用来<strong>备份部分文件</strong>：</p>
<ol>
<li>add 那些你不想备份的文件（例如： <code>git add file1.js, file2.js</code>）</li>
<li>调用 <code>git stash –keep-index</code>。只会备份那些没有被add的文件。</li>
<li>调用 <code>git reset</code> 取消已经add的文件的备份，继续自己的工作。</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看储藏记录列表</span></span><br><span class="line">git stash list</span><br><span class="line">stash@&#123;index&#125;: WIP on [分支名]: [最近一次的commitID] [最近一次的提交信息]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 标识储藏记录</span></span><br><span class="line">git stash save [stashMessage]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取出最近一次储藏的修改到工作区</span></span><br><span class="line"><span class="comment"># 命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@&#123;0&#125;</span></span><br><span class="line"><span class="comment"># 如果要应用并删除其他stash 比如应用并删除第二个：git stash pop stash@&#123;1&#125;</span></span><br><span class="line">git stash pop</span><br><span class="line">git stash pop stash@&#123;<span class="variable">$num</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取出指定index的储藏的修改到工作区中,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@&#123;0&#125;</span></span><br><span class="line"><span class="comment"># 取出第二个：git stash apply stash@&#123;1&#125;</span></span><br><span class="line">git stash apply stash@&#123;index&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指定index的储藏从储藏记录列表中删除</span></span><br><span class="line">git stash drop stash@&#123;index&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空所有缓存的stash  </span></span><br><span class="line">git stash clear</span><br><span class="line"></span><br><span class="line"><span class="comment">#  显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加`stash@&#123;$num&#125;`，比如第二个` git stash show stash@&#123;1&#125;`</span></span><br><span class="line">git stash show</span><br><span class="line"><span class="comment"># 显示指定的 stash 中保存的所有文件的列表</span></span><br><span class="line">git stash show stash@&#123;0&#125; --name-only</span><br><span class="line"><span class="comment"># 显示第一个存储的改动，如果想显示其他存存储，命令：git stash show stash@&#123;$num&#125; -p </span></span><br><span class="line">git stash show -p </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="push推送"><a href="#push推送" class="headerlink" title="push推送"></a>push推送</h3><ul>
<li><p>上传本地仓库分支到远程仓库分支，实现同步。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line"><span class="comment"># 如果省略远程分支名，则表示将本地分支推送与之存在&quot;追踪关系&quot;的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。</span></span><br><span class="line"><span class="comment"># 将本地的`master`分支推送到`origin`主机的`master`分支。如果后者不存在，则会被新建。</span></span><br><span class="line">git push origin master</span><br><span class="line"><span class="comment"># 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line">git push [remote] –force</span><br><span class="line"><span class="comment"># 推送所有分支到远程仓库</span></span><br><span class="line">git push [remote] -all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</span></span><br><span class="line">git push origin :master</span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">git push origin --delete master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</span></span><br><span class="line">git push origin</span><br><span class="line"><span class="comment"># 如果当前分支只有一个追踪分支，那么主机名都可以省略。</span></span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果当前分支与多个主机存在追踪关系，则可以使用`-u`选项指定一个默认主机，这样后面就可以不加任何参数使用`git push`。</span></span><br><span class="line"><span class="comment"># 将本地的`master`分支推送到`origin`主机，同时指定`origin`为默认主机，后面就可以不加任何参数使用`git push`了</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
</li>
<li><p>不带任何参数的<code>git push</code>，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用<code>git config</code>命令。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global push.default matching</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">git config --global push.default simple</span><br></pre></td></tr></table></figure>


</li>
<li><p>还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用<code>--all</code>选项。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git push --all origin</span><br><span class="line"><span class="comment"># 上面命令表示，将所有本地分支都推送到`origin`主机。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做`git pull`合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用`--force`选项。</span></span><br><span class="line">git push --force origin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面命令使用`--force`选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用`--force`选项。</span></span><br><span class="line"></span><br><span class="line">最后，`git push`不会推送标签（tag），除非使用`--tags`选项。</span><br><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure>


</li>
<li><p>新建仓库 推送</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;# README&quot;</span> &gt;&gt; README.md</span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">&quot;first commit&quot;</span></span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin git@github.com:xxx/xxx.git</span><br><span class="line"></span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>
</li>
<li><p>已经存在的仓库</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除关联的origin的远程库</span></span><br><span class="line">git remote <span class="built_in">rm</span> origin</span><br><span class="line">git remote add origin https://gitee.com/xxxxxx.git</span><br><span class="line">git branch -M main</span><br><span class="line">git push -u origin main  <span class="comment"># git push --set-upstream origin main</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="pull-分支"><a href="#pull-分支" class="headerlink" title="pull 分支"></a>pull 分支</h3><ul>
<li><p><code>git pull</code>命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。一般是本地分支的进度落后于远程分支时，需要使用该命令：<code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code> </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取回 origin 主机的 next 分支，与本地的 master 分支合并，需要写成下面这样。</span></span><br><span class="line">git pull origin next:master</span><br><span class="line"><span class="comment"># 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</span></span><br><span class="line">git pull origin next</span><br><span class="line"><span class="comment"># 上面命令表示，取回`origin/next`分支，再与当前分支合并。实质上，这等同于先做`git fetch`，再做`git merge`</span></span><br><span class="line">$ git fetch origin</span><br><span class="line">$ git merge origin/next</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在本地删除远程已经删除的分支 如果远程主机删除了某个分支，默认情况下，`git pull` 不会在拉取远程分支的时候，删除对应的本地分支。</span></span><br><span class="line">$ git pull -p</span><br><span class="line"><span class="comment"># 等同于下面的命令</span></span><br><span class="line">$ git fetch --prune origin</span><br><span class="line">$ git fetch -p</span><br></pre></td></tr></table></figure>
</li>
<li><p>在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在<code>git clone</code>的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的<code>master</code>分支自动”追踪”<code>origin/master</code>分支。Git也允许手动建立追踪关系。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定`master`分支追踪`origin/next`分支。</span></span><br><span class="line">git branch --set-upstream master origin/next</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果当前分支与远程分支存在追踪关系，`git pull`就可以省略远程分支名。</span></span><br><span class="line"><span class="comment"># 下面命令表示本地的当前分支自动与对应的`origin`主机&quot;追踪分支&quot;（remote-tracking branch）进行合并。</span></span><br><span class="line">$ git pull origin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果当前分支只有一个追踪分支，连远程主机名都可以省略。表示当前分支自动与唯一一个追踪分支进行合并。</span></span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>常用 <code>git pull --rebase origin master</code> 用 rebase 的方式进行，不会产生 merge 保持分支干净、整洁</strong></p>
</li>
<li><p>pull 分支报错</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin</span><br><span class="line">提示:您有不同的分支，需要指定如何协调它们。</span><br><span class="line">hint: You have divergent branches and need to specify how to reconcile them.</span><br><span class="line">提示:您可以通过在之前某个时间运行以下命令之一来做到这一点</span><br><span class="line">hint: You can <span class="keyword">do</span> so by running one of the following commands sometime before</span><br><span class="line">hint: your next pull:</span><br><span class="line">hint:</span><br><span class="line">hint:   git config pull.rebase <span class="literal">false</span>  <span class="comment"># merge</span></span><br><span class="line">hint:   git config pull.rebase <span class="literal">true</span>   <span class="comment"># rebase</span></span><br><span class="line">hint:   git config pull.ff only       <span class="comment"># fast-forward only 仅快进</span></span><br><span class="line">hint:</span><br><span class="line">提示:可以将“git config”替换为“git config——global”来设置默认值</span><br><span class="line">hint: You can replace <span class="string">&quot;git config&quot;</span> with <span class="string">&quot;git config --global&quot;</span> to <span class="built_in">set</span> a default</span><br><span class="line">提示:首选所有存储库。你也可以传递——rebase，——no-rebase，</span><br><span class="line">hint: preference <span class="keyword">for</span> all repositories. You can also pass --rebase, --no-rebase,</span><br><span class="line">提示:或命令行上的——ff-only，以覆盖配置的默认per</span><br><span class="line">hint: or --ff-only on the <span class="built_in">command</span> line to override the configured default per</span><br><span class="line">hint: invocation.</span><br><span class="line">fatal:需要指定如何协调不同的分支。</span><br><span class="line">fatal: Need to specify how to reconcile divergent branches.</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认将pull下来的代码与现有改动的代码进行合并</span></span><br><span class="line">git config --global pull.rebase <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 回退到合并之前的代码，在进行pull拉取最新代码</span></span><br><span class="line">git reset --hard c129513</span><br><span class="line">git pull origin</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="pull-rebase-模式"><a href="#pull-rebase-模式" class="headerlink" title="pull rebase 模式"></a>pull rebase 模式</h3><ol>
<li><p>命令 <code> git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></p>
</li>
<li><p>多人使用同一个远程分支合作开发，在 push 代码的时候很可能出现以下问题：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果如下</span></span><br><span class="line">To github.com:hello/demo.git</span><br><span class="line"> ! [rejected]        master -&gt; master (fetch first)</span><br><span class="line">error: failed to push some refs to <span class="string">&#x27;git@github.com:hello/demo.git&#x27;</span></span><br><span class="line">hint: Updates were rejected because the remote contains work that you <span class="keyword">do</span></span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., <span class="string">&#x27;git pull ...&#x27;</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">&#x27;Note about fast-forwards&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;git push --help&#x27;</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure>
</li>
<li><p>从输出结果中可以明显看出此时远程分支有新的 commit 未同步到本地，无法推送。此时我们一般会执行以下操作：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin master</span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
</li>
<li><p>确实 push 成功了，但是此时用 <code>git log</code> 查看提交记录：多出了一条 merge commit，这个 commit 就是在执行 <code>git pull origin master</code> 的时候自动生成的。如果多人多次如此操作，那么提交记录就会出现很多条这种自动生成的 merge commit，非常难看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 结果如下</span><br><span class="line">commit 1aefef1a2bedbd3ebd82db8dcf802011a35a9888 (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Merge: 24cfa5c f318a05</span><br><span class="line">Author: hello &lt;hello@qq.com&gt;</span><br><span class="line">Date:   Tue Jul 23 09:53:47 2019 +0800</span><br><span class="line"></span><br><span class="line">    Merge branch &#x27;master&#x27; of github.com:hello/demo</span><br><span class="line"></span><br><span class="line">commit 24cfa5c3ad271e85ff0e64793bf2bcc9d700c233</span><br><span class="line">Author: hello &lt;hello@qq.com&gt;</span><br><span class="line">Date:   Tue Jul 23 09:50:06 2019 +0800</span><br><span class="line"></span><br><span class="line">    feat: 新功能提交</span><br><span class="line"></span><br><span class="line">commit f318a05b1a4cbc0a6cf8d7dc7d3fb99cbafb0363</span><br><span class="line">Author: world &lt;world@qq.com&gt;</span><br><span class="line">Date:   Tue Jul 23 09:48:20 2019 +0800</span><br><span class="line"></span><br><span class="line">    feat: 其他功能提交</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解决方案</strong>:要解决以上问题，不再出现自动生成的 merge commit，那么只要在执行 <code>git pull origin master</code> 的时候带上 <code>--rebase</code> 即可：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 等价于：git fetch --all &amp;&amp; git rebase branch</span></span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意事项</strong>: <strong>执行 <code>git pull --rebase</code> 的时候必须保持本地目录干净</strong>。即：不能存在状态为 <code>modified</code> 的文件。（存在<code>Untracked files</code>是没关系的）,<strong>如果出现冲突，可以选择手动解决冲突后继续 <code>rebase</code>，也可以放弃本次 <code>rebase</code></strong></p>
</li>
<li><p>如果 A、B 同学修改了同一个文件。那么很有可能会出现冲突，当 B 同学来执行命令的时候会出现如下状况：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ git pull --rebase</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果如下</span></span><br><span class="line">remote: Counting objects: 6, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (6/6), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 6 (delta 1), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (6/6), <span class="keyword">done</span>.</span><br><span class="line">From gitlab.lrts.me:fed/gitlab-merge</span><br><span class="line">   93a1a93..960b5fc  master     -&gt; origin/master</span><br><span class="line">First, rewinding <span class="built_in">head</span> to replay your work on top of it...</span><br><span class="line">Applying: feat: 其他功能提交</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">M	one.md</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging one.md</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> one.md</span><br><span class="line">error: Failed to merge <span class="keyword">in</span> the changes.</span><br><span class="line">Patch failed at 0001 feat：其他功能提交</span><br><span class="line">hint: Use <span class="string">&#x27;git am --show-current-patch&#x27;</span> to see the failed patch</span><br><span class="line"></span><br><span class="line">Resolve all conflicts manually, mark them as resolved with</span><br><span class="line"><span class="string">&quot;git add/rm &lt;conflicted_files&gt;&quot;</span>, <span class="keyword">then</span> run <span class="string">&quot;git rebase --continue&quot;</span>.</span><br><span class="line">You can instead skip this commit: run <span class="string">&quot;git rebase --skip&quot;</span>.</span><br><span class="line">To abort and get back to the state before <span class="string">&quot;git rebase&quot;</span>, run <span class="string">&quot;git rebase --abort&quot;</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这种情况下，可以手动打开 one.md 文件解决冲突，然后再执行：</span></span><br><span class="line">$ git add one.md</span><br><span class="line">$ git rebase --<span class="built_in">continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以用 git rebase --abort 放弃本次 rebase 操作。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>总结</strong>:多人基于同一个远程分支开发的时候，如果想要顺利 push 又不自动生成 merge commit，建议在每次提交都按照如下顺序操作：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把本地发生改动的文件贮藏一下</span></span><br><span class="line">$ git stash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把远程最新的 commit 以变基的方式同步到本地</span></span><br><span class="line">$ git pull --rebase</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把本地的 commit 推送到远程</span></span><br><span class="line">$ git push</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把本地贮藏的文件弹出，继续修改</span></span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="SSH-密钥"><a href="#SSH-密钥" class="headerlink" title="SSH 密钥"></a>SSH 密钥</h2><p>SSH是一种网络协议，用于计算机之间的加密登录。而大多数 Git 服务器都会选择使用 SSH 公钥来进行授权，所以想要在 GitHub 提交代码的第一步就是要先添加 SSH key 配置。</p>
<h3 id="生成SSH-key"><a href="#生成SSH-key" class="headerlink" title="生成SSH key"></a>生成SSH key</h3><p>Linux 与 Mac 都是默认安装了 SSH ，而 Windows 系统安装了 Git Bash 应该也是带了 SSH的。大家可以在终端（win下在 Git Bash 里）输入 ssh 如果出现提示证明你本机已经安装 SSH， 否则请搜索自行安装下。</p>
<p>紧接着输入 <code>ssh-keygen -t rsa</code> ，什么意思呢？就是指定 rsa 算法生成密钥，接着连续三个回车键（不需要输入密码），然后就会生成两个文件 id_rsa 和 id_rsa.pub ，而<code>id_rsa 是密钥</code>，<code>id_rsa.pub 就是公钥</code>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[sun@CMCC#1 ~]$ ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;your_mail@gmail.com&quot;</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line"></span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/Users/sun/.ssh/id_rsa): Created directory <span class="string">&#x27;/Users/sun/.ssh&#x27;</span>.</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /Users/sun/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /Users/sun/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:BQZcuTpPMQ2L/xYPFQoF8jhKsWrSZU4S3iIU7QiUxyU fl_6145@163.com</span><br><span class="line">The key<span class="string">&#x27;s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 4096]----+</span></span><br><span class="line"><span class="string">|.+*Eoooo=+.      |</span></span><br><span class="line"><span class="string">|oo *.o.=+.  .    |</span></span><br><span class="line"><span class="string">|o B B o..*.. .   |</span></span><br><span class="line"><span class="string">| + @ ...=.o .    |</span></span><br><span class="line"><span class="string">|. + o  oSo .     |</span></span><br><span class="line"><span class="string">| o    o o o      |</span></span><br><span class="line"><span class="string">|       + . +     |</span></span><br><span class="line"><span class="string">|        . o .    |</span></span><br><span class="line"><span class="string">|         .       |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br><span class="line"><span class="string">[sun@CMCC#1 ~]$</span></span><br></pre></td></tr></table></figure>

<p>这两文件默认分别在如下目录里生成： Linux&#x2F;Mac 系统 在 <code>~/.ssh</code> 下，win系统在 <code>/c/Documents and Settings/username/.ssh</code> 下，都是隐藏文件，相信你们有办法查看的。</p>
<p>接下来要做的是把 id_rsa.pub 的内容添加到 GitHub 上，这样你本地的 id_rsa 密钥跟 GitHub上的 id_rsa.pub 公钥进行配对，授权成功才可以提交代码。</p>
<h3 id="ed25519-算法"><a href="#ed25519-算法" class="headerlink" title="ed25519 算法"></a>ed25519 算法</h3><p>如果有多个平台,可以生产多份 ssh密钥， RSA 经典且可靠，但性能不够理想。 OpenSSH 版本大于 6.5（2014 年的古早版本），就可以利用 Ed25519 算法生成的密钥对，减少你的登录时间</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ssh-keygen -t ed25519</span></span><br><span class="line">ssh-keygen -t ed25519 -C <span class="string">&quot;fl_6145@163.com&quot;</span></span><br><span class="line"><span class="comment"># 生成目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/.ssh &amp;&amp; <span class="built_in">cd</span> ~/.ssh</span><br><span class="line"><span class="comment"># 我在 GitHub</span></span><br><span class="line">ssh-keygen -t ed25519 -f my_github_ed25519  -C <span class="string">&quot;me@github&quot;</span></span><br><span class="line"><span class="comment"># 我在 Gitee</span></span><br><span class="line">ssh-keygen -t ed25519 -f my_gitee_ed25519   -C <span class="string">&quot;me@gitee&quot;</span></span><br><span class="line"><span class="comment"># 我在 GitLab</span></span><br><span class="line">ssh-keygen -t ed25519 -f my_gitlab_ed25519  -C <span class="string">&quot;me@gitlab&quot;</span></span><br><span class="line"><span class="comment"># 我在企业</span></span><br><span class="line">ssh-keygen -t ed25519 -f my_company_ed25519 -C <span class="string">&quot;email@example.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># RSA</span></span><br><span class="line">ssh-keygen -t rsa -b 4096 -f my_id -C <span class="string">&quot;email@example.com&quot;</span></span><br><span class="line"><span class="comment"># [-t rsa] 表示使用 RSA 算法。</span></span><br><span class="line"><span class="comment"># [-b 4096] 表示 RSA 密钥长度 4096 bits （默认 2048 bits）。Ed25519 算法不需要指定。</span></span><br><span class="line"><span class="comment"># [-f my_id] 表示在【当前工作目录】下生成一个私钥文件 my_id （同时也会生成一个公钥文件 my_id.pub）。</span></span><br><span class="line"><span class="comment"># [-C &quot;email@example.com&quot;] 表示在公钥文件中添加注释，即为这个公钥“起个别名”（不是 id，可以更改）。</span></span><br></pre></td></tr></table></figure>



<h3 id="多个ssh秘钥"><a href="#多个ssh秘钥" class="headerlink" title="多个ssh秘钥"></a>多个ssh秘钥</h3><p>ssh-add 这个命令不是用来永久性的记住你所使用的私钥的。实际上，它的作用只是把你指定的私钥添加到 ssh-agent 所管理的一个session 当中。而 ssh-agent 是一个用于存储私钥的临时性的 session 服务，也就是说当你重启之后，ssh-agent服务也就重置了。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把专用密钥添加到 ssh-agent 的高速缓存中</span></span><br><span class="line">ssh-add ~/.ssh/id_dsa</span><br><span class="line"><span class="comment"># 从ssh-agent中删除密钥：</span></span><br><span class="line">ssh-add -d ~/.ssh/id_xxx.pub</span><br><span class="line"><span class="comment"># 查看ssh-agent中的密钥：</span></span><br><span class="line">ssh-add -l</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ~/.ssh/config中配置</span></span><br><span class="line"><span class="comment"># 关于别名</span></span><br><span class="line"><span class="comment"># Host 是别名，HostName 是真正的域名。</span></span><br><span class="line"><span class="comment"># 得益于别名，你可以直接以别名访问地址。例如：</span></span><br><span class="line"><span class="comment"># 无别名： git clone git@github.com:torvalds/linux.git</span></span><br><span class="line"><span class="comment"># 有别名： git clone github:torvalds/linux.git</span></span><br><span class="line"><span class="comment"># 本例中使用与域名一致的别名，以免错误的配置导致登录不上。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关于代理</span></span><br><span class="line"><span class="comment"># SOCKS 代理格式： ProxyCommand connect -S localhost:1080  %h %p</span></span><br><span class="line"><span class="comment"># HTTP 代理格式： ProxyCommand connect -H localhost:1080  %h %p</span></span><br><span class="line"><span class="comment">## SSH 代理依赖外部程序，这里使用了 Git for Windows 同捆的 connect.exe。</span></span><br><span class="line"><span class="comment">## Linux 下使用该代理方式需要额外安装 connect-proxy。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我在 GitHub</span></span><br><span class="line">Host github.com</span><br><span class="line">  Hostname github.com</span><br><span class="line"><span class="comment">#  ProxyCommand connect -H localhost:1080  %h %p</span></span><br><span class="line">  User git</span><br><span class="line">  PreferredAuthentications publickey</span><br><span class="line">  IdentityFile ~/.ssh/my_github_ed25519</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我在 GitLab</span></span><br><span class="line">Host gitlab.com</span><br><span class="line">  Hostname gitlab.com</span><br><span class="line"><span class="comment">#  ProxyCommand connect -H localhost:1080  %h %p</span></span><br><span class="line">  User git</span><br><span class="line">  PreferredAuthentications publickey</span><br><span class="line">  IdentityFile ~/.ssh/my_gitlab_ed25519</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我在 Gitee</span></span><br><span class="line">Host gitee.com</span><br><span class="line">  Hostname gitee.com</span><br><span class="line">  User git</span><br><span class="line">  PreferredAuthentications publickey</span><br><span class="line">  IdentityFile ~/.ssh/my_gitee_ed25519</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我在企业</span></span><br><span class="line">Host example.com</span><br><span class="line">  Hostname example.com</span><br><span class="line">  Port 22</span><br><span class="line">  User git</span><br><span class="line">  PreferredAuthentications publickey</span><br><span class="line">  IdentityFile ~/.ssh/my_company_ed25519</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ssh config 就是一个配置文件，描述不同的秘钥对应的设置——包括主机名、用户名、访问策略等等，本地配置内容放在文件<code>/Users/you/.ssh/config</code>, Host 是别名，HostName 是真正的域名。Hostname 是域名则最好保持一致。</p>
<ul>
<li><p>当我 <code>git clone https://github.com/user/repo</code> 的时候，<code>~/.ssh/my_github_ed25519</code> 秘钥会被使用</p>
</li>
<li><p>当我 <code>git clone https://gitlab.com/user/repo</code> 的时候，很显然 <code>~/.ssh/my_gitlab_ed25519</code> 秘钥会被使用。</p>
</li>
</ul>
</li>
<li><p>如果同一域名下有两个不同的配置怎么办？</p>
<ul>
<li><p>以 Github 为例，如果我有两个账户，一个个人的，一个组织的，并且要使用不同的秘钥，那么我可以这么写：这里 Host 后面对应的是 Github 的两个用户名 <code>github.com/user1</code>  <code>github.com/user2</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Host github.com-user1</span><br><span class="line">  Hostname github.com</span><br><span class="line">  User git</span><br><span class="line">  PreferredAuthentications publickey</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa</span><br><span class="line">  </span><br><span class="line">Host github.com-user2</span><br><span class="line">  Hostname github.com</span><br><span class="line">  User git</span><br><span class="line">  PreferredAuthentications publickey</span><br><span class="line">  IdentityFile ~/.ssh/my_github_ed25519</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>如果域名是数字 IP，是否可以简化呢？<strong>Host 可以帮助你把对应的 IP 变成好记的名字。</strong></p>
</li>
</ul>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 比如说我在公司内部配置了 Git Server（基于 gitolite 或 Gitlab 或任何工具）</span></span><br><span class="line"><span class="comment"># 正常的访问地址是：git://xxx.xxx.xxx.xxx:repo.git，如下的配置则可以帮你把它简化成：git.work:repo.git</span></span><br><span class="line">Host git.work</span><br><span class="line">  Hostname 192.168.61.11</span><br><span class="line">  User git</span><br><span class="line">  PreferredAuthentications publickey</span><br><span class="line">  IdentityFile ~/.ssh/work</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="添加-SSH-key"><a href="#添加-SSH-key" class="headerlink" title="添加 SSH key"></a>添加 SSH key</h3><p>先在 GitHub 上的设置页面，点击最左侧 SSH and GPG keys ： 然后点击右上角的 New SSH key 按钮： 需要做的只是在 Key 那栏把<code>id_rsa.pub</code>公钥文件里的内容复制粘贴进去就可以了，Title 那栏不需要填写，点击 Add SSH key 按钮就ok了。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  Linux/Mac 用户执行以下命令：</span></span><br><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line"><span class="built_in">cat</span> id_rsa.pub</span><br><span class="line"><span class="comment"># 将 SSH 密钥复制到剪贴板</span></span><br><span class="line">pbcopy &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>SSH key 添加成功之后，输入 <code>ssh -T git@github.com</code> 进行测试，如果出现以下提示证明添加成功了。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 验证ssh key是否设置成功</span></span><br><span class="line"><span class="comment"># ssh -T git@gitee.com</span></span><br><span class="line">ssh -T git@github.com</span><br><span class="line">Hi fulsun! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure>



<h2 id="大文件清理"><a href="#大文件清理" class="headerlink" title="大文件清理"></a>大文件清理</h2><h3 id="斩草除根式"><a href="#斩草除根式" class="headerlink" title="斩草除根式"></a>斩草除根式</h3><ul>
<li><p>把根目录下面的.git文件夹删除，然后重建，简单粗暴，但如果需要git log历史记录的，请不要这样做</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf .git</span><br><span class="line"><span class="comment"># 删除之后，该目录就不是一个git仓库了，因此需要重建</span></span><br><span class="line"><span class="comment"># 输入rm -rf + github仓库地址  在 github 的对应的库中到 setting 删除库</span></span><br><span class="line"><span class="built_in">rm</span> -rf https://github.com/xxx/xxx.git</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="逐个攻破式"><a href="#逐个攻破式" class="headerlink" title="逐个攻破式"></a>逐个攻破式</h3><ul>
<li><p>对仓库进行gc操作</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git gc</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看空间使用，size-pack 是以千字节为单位表示的 packfiles 的</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git count-objects -v</span><br><span class="line"><span class="built_in">du</span> -ah .git/objects</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行底层命令 git verify-pack 以识别大对象，对输出的第三列信息即文件大小进行排序.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 占用空间最多的五个文件</span></span><br><span class="line">git verify-pack -v .git/objects/pack/*.idx | <span class="built_in">sort</span> -k 3 -n | <span class="built_in">tail</span> -5</span><br><span class="line"><span class="comment"># 787d86fa5890fa037cca876b7b67d581d424b357 blob   1259085 1168273 16059429</span></span><br><span class="line"><span class="comment"># 第一行的字母其实相当于文件的id,用以下命令可以找出id 对应的文件名：</span></span><br><span class="line">git rev-list --objects --all | grep 787d86fa5890fa037cca876b7b67d581d424b357</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 rev-list 命令，传入 --objects选项，它会列出所有 commit SHA 值，blob SHA 值及相应的文件路径，这样查看 blob 的文件名。</span></span><br><span class="line">git rev-list --objects --all | grep <span class="string">&quot;<span class="subst">$(git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -5 | awk &#x27;&#123;print$1&#125;&#x27;)</span>&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查找文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查出文件提交commit记录</span></span><br><span class="line">git <span class="built_in">log</span> --pretty=oneline --branches -- <span class="variable">$&#123;FILE_PATH&#125;</span></span><br><span class="line"><span class="comment"># 想要知道这条commit id所在的分支，可以使用以下命令</span></span><br><span class="line">git branch -a --contains &lt;COMMIT ID&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 遍历所有提交： commit多了会比较慢</span></span><br><span class="line">git filter-branch -f --prune-empty --index-filter <span class="string">&#x27;git rm -rf --cached --ignore-unmatch &lt;file&gt;&#x27;</span> --tag-name-filter <span class="built_in">cat</span> -- --all</span><br><span class="line"></span><br><span class="line">filter-branch命令可以用来重写Git仓库中的提交</span><br><span class="line">-f , --force 假如遇到冲突也让git强制执行</span><br><span class="line">--prune-empty 选项告诉git，如果因为重写导致某些commit变成了空（比如修改的文件全部被删除），那么忽略掉这个commit。</span><br><span class="line">--index-filter参数用来指定一条Bash命令，然后Git会检出（checkout）所有的提交， 执行该命令，然后重新提交。</span><br><span class="line">	git <span class="built_in">rm</span> --cached --ignore-unmatch file 让git删除掉缓存的文件，如果有匹配的话</span><br><span class="line">--tag-name-filter 表示对每一个tag如何重命名，重命名的命令紧跟在后面，当前的tag名会从标注输入送给后面的命令，用<span class="built_in">cat</span>就表示保持tag名不变。</span><br><span class="line">-- 紧跟着的-- 表示分割符，</span><br><span class="line">--all 表示对所有的文件都考虑在内</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定commit修改</span></span><br><span class="line">git filter-branch -f --prune-empty --index-filter <span class="string">&#x27;git rm -rf --cached --ignore-unmatch &lt;file&gt;&#x27;</span> -- &lt;commit_id&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>回收内存</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf .git/refs/original/</span><br><span class="line">git reflog expire --expire=now --all</span><br><span class="line">git fsck --full --unreachable</span><br><span class="line">git repack -A -d  <span class="comment"># 将所有未被包含在一个pack的松散对象连结成一个pack</span></span><br><span class="line">git gc --aggressive --prune=now</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交到远程仓库</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push --force [remote] master</span><br><span class="line"><span class="comment"># 让远程仓库变小</span></span><br><span class="line">git remote prune origin</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="脚本-更新目录的多个仓库"><a href="#脚本-更新目录的多个仓库" class="headerlink" title="脚本-更新目录的多个仓库"></a>脚本-更新目录的多个仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim ~/git_pull_Batch.sh</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">showGreen</span></span>()&#123; <span class="built_in">echo</span> -e <span class="string">&quot;\033[32m <span class="variable">$1</span> \033[0m&quot;</span>&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">showBlue</span></span>()&#123; <span class="built_in">echo</span> -e <span class="string">&quot;\033[36m <span class="variable">$1</span> \033[0m&quot;</span>&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">showYellow</span></span>()&#123; <span class="built_in">echo</span> -e <span class="string">&quot;\033[33m <span class="variable">$1</span> \033[0m&quot;</span>&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">showWhite</span></span>()&#123; <span class="built_in">echo</span> -e <span class="string">&quot;\033[37m <span class="variable">$1</span> \033[0m&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">traversal_dir</span></span>()&#123;</span><br><span class="line">    <span class="keyword">for</span> sub_dir <span class="keyword">in</span> `<span class="built_in">ls</span> <span class="variable">$1</span>` <span class="comment">#通过 ls root_dir 遍历出子目录，装入子目录 sub_dir 中</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">dir</span>=<span class="variable">$1</span><span class="string">&quot;/&quot;</span><span class="variable">$sub_dir</span> <span class="comment">#将根目录 $1 与子目录 sub_dir 拼接成完整的目录</span></span><br><span class="line">        <span class="keyword">if</span> [ -d <span class="variable">$dir</span> ] <span class="comment">#判断：是目录的继续下一步</span></span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">cd</span> <span class="variable">$dir</span></span><br><span class="line">			showBlue <span class="variable">$dir</span></span><br><span class="line">            showGreen <span class="string">&#x27;git pull &#x27;</span><span class="variable">$sub_dir</span></span><br><span class="line">            git pull</span><br><span class="line">			<span class="built_in">echo</span> <span class="comment">#打印空行</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            showYellow <span class="variable">$dir</span></span><br><span class="line">			<span class="built_in">echo</span> <span class="comment">#打印空行</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root_dir=<span class="string">&quot;N:\Desktop\qnit&quot;</span> <span class="comment">#定义根目录，即项目 project 的上级目录。例如：root_dir/project/.git</span></span><br><span class="line">traversal_dir <span class="variable">$root_dir</span></span><br></pre></td></tr></table></figure>

<h2 id="代码行数统计"><a href="#代码行数统计" class="headerlink" title="代码行数统计"></a>代码行数统计</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 个人提交的代码行数统计</span></span><br><span class="line">git <span class="built_in">log</span> --author=<span class="string">&quot;username&quot;</span> --pretty=tformat: --numstat | awk <span class="string">&#x27;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc &#125;&#x27;</span> -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看项目每个人提交的代码行数统计</span></span><br><span class="line">git <span class="built_in">log</span> --format=<span class="string">&#x27;%aN&#x27;</span> | <span class="built_in">sort</span> -u | <span class="keyword">while</span> <span class="built_in">read</span> name; <span class="keyword">do</span> <span class="built_in">echo</span> -en <span class="string">&quot;<span class="variable">$name</span>\t&quot;</span>; git <span class="built_in">log</span> --author=<span class="string">&quot;<span class="variable">$name</span>&quot;</span> --pretty=tformat: --numstat | awk <span class="string">&#x27;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc &#125;&#x27;</span> -; <span class="keyword">done</span></span><br><span class="line"><span class="comment"># 查询所有用户的提交总次数</span></span><br><span class="line">git <span class="built_in">log</span> --pretty=<span class="string">&#x27;%aN&#x27;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -k1 -n -r</span><br></pre></td></tr></table></figure>



<h2 id="Git在工作中的使用"><a href="#Git在工作中的使用" class="headerlink" title="Git在工作中的使用"></a>Git在工作中的使用</h2><h3 id="Git-工作流分类"><a href="#Git-工作流分类" class="headerlink" title="Git 工作流分类"></a>Git 工作流分类</h3><ul>
<li><p>GItFlow是在项目开发过程中使用 Git 的方式</p>
</li>
<li><p>集中式工作流 ：像 SVN 一样，集中式工作流以中央仓库作为项目所有修改的单点实体。所有修改都提交到Master 这个分支上。 这种方式与 SVN的主要区别就是开发人员有本地库。Git 很多特性并没有用到。</p>
</li>
<li><p>GitFlow工作流：为功能开发、发布准备和维护设立了独立的分支，让发布迭代过程更流畅。严格的分支模型也为大型项目提供了一些非常必要的结构</p>
</li>
<li><p>Forking 工作流：在 GitFlow 基础上，充分利用了 Git 的 Fork 和 pull request 的功能以达到代码审核的目的。更适合安全可靠地管理大团队的开发者，而且能接受不信任贡献者的提交。</p>
</li>
</ul>
<h3 id="分支种类详解"><a href="#分支种类详解" class="headerlink" title="分支种类详解"></a>分支种类详解</h3><ul>
<li>主干分支 <code>master</code>: 主要负责管理正在运行的生产环境代码。永远保持与正在运行的生产环境完全一致。</li>
<li>开发分支<code> develop</code>: 主要负责管理正在开发过程中的代码。一般情况下应该是最新的代码。</li>
<li>bug 修理分支 <code>hotfix</code>: 主要负责管理生产环境下出现的紧急修复的代码。 从主干分支分出，修理完毕并测试上线后，并回主干分支。并回后，视情况可以删除该分支。</li>
<li>准生产分支（预发布分支） <code>release</code>: 较大的版本上线前，会从开发分支中分出准生产分支，进行最后阶段的集成测试。该版本上线后，会合并到主干分支。生产环境运行一段阶段较稳定后 可以视情况删除。</li>
<li><h2 id="功能分支-feature-为了不影响较短周期的开发工作，一般把中长期开发模块，会从开发分支-中独立出来。-开发完成后会合并到开发分支。"><a href="#功能分支-feature-为了不影响较短周期的开发工作，一般把中长期开发模块，会从开发分支-中独立出来。-开发完成后会合并到开发分支。" class="headerlink" title="功能分支 feature: 为了不影响较短周期的开发工作，一般把中长期开发模块，会从开发分支 中独立出来。 开发完成后会合并到开发分支。"></a>功能分支 <code>feature</code>: 为了不影响较短周期的开发工作，一般把中长期开发模块，会从开发分支 中独立出来。 开发完成后会合并到开发分支。</h2></li>
</ul>
<h3 id="Github跨团队协作"><a href="#Github跨团队协作" class="headerlink" title="Github跨团队协作"></a>Github跨团队协作</h3><ol>
<li>假设zs团队在开发，要请ls团队协作。</li>
<li>ls登录Github账户，forkzs的项目后</li>
<li>修改本地代码后，推送到远程仓库中，访问Github后，点击<code>Pull Request</code>，新建一个pull请求。</li>
<li>这时候zs登录github后可以在pull request 中看到请求， 可以进行交流和审核提交的代码。</li>
<li>确认无误后，合并代码，选择<code>merge pull request</code>,填写操作的日志信息后， confirm merge即可。</li>
<li>zs团队后续继续开发，ls要获取代码，同样取zs项目和自己项目的diff，创建pull request ，然后merge即可。</li>
</ol>
<h3 id="普通开发人员的操作"><a href="#普通开发人员的操作" class="headerlink" title="普通开发人员的操作"></a>普通开发人员的操作</h3><p>普通开发人员，一般按照如下几个步骤来进行开发、测试工作就可以了：</p>
<ol>
<li>将远程 dev 分支 clone 到本地，例如：<code>git clone git@github.com:goto456/test.git</code>；</li>
<li>从 dev 分支拉出（新建）自己的 feature 分支用于开发，例如：<code>git checkout -b feature_login</code>；</li>
<li>在自己的 feature 分支上进行开发工作；</li>
<li>开发完了用 add、commit 等操作提交到当前分支；</li>
<li>如果需要在测试环境进行测试，则将远程 test 分支拉到本地，例如：<code>git branch test origin/test</code>;</li>
<li>将自己的 feature 分支合并到 test 分支，并将 test 分支 push 到远程，例如：<code>git rebase test</code>, <code>git checkout test</code>, <code>git merge feature_login</code>, <code>git push origin test</code>；<strong>（注意：我们推荐用 rebase 来合并，以保证分支的整洁、美观）</strong></li>
<li>通过公司的发布平台将远程 test 分支发布到测试环境进行测试；</li>
<li>如果测试没问题或者开始就不需要测试，这可以直接将当前 feature 分支合并到 dev 分支，并 push 到远程库，例如：<code>git rebase dev</code>, <code>git checkout dev</code>, <code>git merge feature_login</code>, <code>git push origin dev</code>；<strong>（注意：我们推荐用 rebase 来合并，以保证分支的整洁、美观）</strong></li>
<li>这时表示该功能已经开发完成了，代码的 review 以及发布，需要团队 leader 在合并到 master 操作时进行；这时可以删除了自己的 feature 分支，例如：<code>git branch -d feature_login</code>；</li>
<li><strong>如果在 push 到远程的时候提示需要先 pull 时，我们推荐使用 rebase 的方式：<code>git pull --rebase</code> 以保持分支的整洁、美观。</strong></li>
</ol>
<h3 id="团队-leader-的操作"><a href="#团队-leader-的操作" class="headerlink" title="团队 leader 的操作"></a>团队 leader 的操作</h3><p>因为只有 leader 有操作 master 分支的权限，所以需要完成 dev 分支到 master 分支的合并，以及后续打 tag 和正式上线发布的工作：</p>
<ol>
<li>先切换到 dev 分支，并拉取最新的状态，例如：<code>git checkout dev</code>, <code>git pull --rebase origin dev</code>；</li>
<li>进行代码 review 等过程后，合并到 master 分支，例如：<code>git rebase master</code>, <code>git checkout master</code>, <code>git merge dev</code>;<strong>（注意：我们推荐用 rebase 来合并，以保证分支的整洁、美观）</strong></li>
<li>为本次完成的版本打上标签，例如：<code>git tag v1.0 -m &quot;release version 1.0&quot;</code>；</li>
<li>将本地合并后的 master 分支以及标签 push 到远程库，例如：<code>git push orgin master --tags</code>。</li>
</ol>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>以上就是我从自己平时的应用中整理出的一个比较简洁的教程，以及我们团队在实际工作中是如何使用的。希望对大家有所帮助！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://fulsun.github.io">凉月</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://fulsun.github.io/p/ca675cd4">https://fulsun.github.io/p/ca675cd4</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://fulsun.github.io" target="_blank">凉月の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Git/">Git</a></div><div class="post_share"><div class="social-share" data-image="/medias/featureimages/003.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/8b5af2fd" title="IDEA+Github+自建GitLab"><img class="cover" src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/006.jpg" onerror="onerror=null;src='/medias/detail/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">IDEA+Github+自建GitLab</div></div></a></div><div class="next-post pull-right"><a href="/p/aca885fa" title="Java的加载执行过程"><img class="cover" src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/010.jpg" onerror="onerror=null;src='/medias/detail/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java的加载执行过程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/p/3969fd76" title="Git基本命令"><img class="cover" src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/013.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-03-18</div><div class="title">Git基本命令</div></div></a></div><div><a href="/p/8b5af2fd" title="IDEA+Github+自建GitLab"><img class="cover" src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/006.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-18</div><div class="title">IDEA+Github+自建GitLab</div></div></a></div><div><a href="/p/7ebd23a0" title="深入 Git"><img class="cover" src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/011.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-19</div><div class="title">深入 Git</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/avatar.jpg" onerror="this.onerror=null;this.src='/medias/detail/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">凉月</div><div class="author-info__description">记录生活,分享知识。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/fulsun"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/fulsun" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:fl_6145@163.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">感谢访问本站，若喜欢请收藏 ^_^</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7"><span class="toc-text">版本控制工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E4%B8%AD%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7"><span class="toc-text">集中式版本控制工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7"><span class="toc-text">分布式版本控制工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git-%E7%AE%80%E4%BB%8B"><span class="toc-text">Git 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E4%B8%8E%E8%AE%BE%E7%BD%AE"><span class="toc-text">安装与设置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Git-%E5%AE%89%E8%A3%85"><span class="toc-text">Git 安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2"><span class="toc-text">命令查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%91%BD%E4%BB%A4"><span class="toc-text">设置命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git%E5%88%AB%E5%90%8D"><span class="toc-text">git别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E9%97%AE%E9%A2%98"><span class="toc-text">下载问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#status-%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98"><span class="toc-text">status 乱码问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git-%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C"><span class="toc-text">Git 命令操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HEAD"><span class="toc-text">HEAD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Init-Clone"><span class="toc-text">Init&#x2F;Clone</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-status"><span class="toc-text">git status</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-add"><span class="toc-text">git add</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-commit"><span class="toc-text">git commit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-log"><span class="toc-text">git log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-diff"><span class="toc-text">git diff</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-add-git-commit"><span class="toc-text">git add &amp; git commit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reset"><span class="toc-text">reset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#revert"><span class="toc-text">revert</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#revert%E4%B8%8Ereset%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">revert与reset的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-tag"><span class="toc-text">git tag</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-show"><span class="toc-text">git show</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-blame"><span class="toc-text">git blame</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-remote"><span class="toc-text">git remote</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-fetch"><span class="toc-text">git fetch</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git-%E5%88%86%E6%94%AF%E6%93%8D%E4%BD%9C"><span class="toc-text">Git 分支操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E6%94%AF"><span class="toc-text">什么是分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-%E6%9F%A5%E7%9C%8B%E5%88%86%E6%94%AF"><span class="toc-text">创建&#x2F;查看分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#checkout-%E5%88%86%E6%94%AF"><span class="toc-text">checkout 分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF"><span class="toc-text">删除分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#merge%E5%88%86%E6%94%AF"><span class="toc-text">merge分支</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%B8%B8%E5%90%88%E5%B9%B6"><span class="toc-text">正常合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%B2%E7%AA%81%E5%90%88%E5%B9%B6"><span class="toc-text">冲突合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81"><span class="toc-text">解决冲突</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rebase%E5%88%86%E6%94%AF"><span class="toc-text">rebase分支</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E7%A4%BA%E4%BE%8B"><span class="toc-text">准备示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6commit"><span class="toc-text">合并commit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#commit%E7%B2%98%E5%88%B0%E5%85%B6%E4%BB%96%E5%88%86%E6%94%AF"><span class="toc-text">commit粘到其他分支</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rebase%E4%B8%8Emerge%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">rebase与merge的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#git-cherry-pick"><span class="toc-text">git cherry-pick</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF%E5%92%8C%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF%E5%9B%BE%E8%A7%A3"><span class="toc-text">创建分支和切换分支图解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stash%E5%88%86%E6%94%AF"><span class="toc-text">stash分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#push%E6%8E%A8%E9%80%81"><span class="toc-text">push推送</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pull-%E5%88%86%E6%94%AF"><span class="toc-text">pull 分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pull-rebase-%E6%A8%A1%E5%BC%8F"><span class="toc-text">pull rebase 模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SSH-%E5%AF%86%E9%92%A5"><span class="toc-text">SSH 密钥</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90SSH-key"><span class="toc-text">生成SSH key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ed25519-%E7%AE%97%E6%B3%95"><span class="toc-text">ed25519 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AAssh%E7%A7%98%E9%92%A5"><span class="toc-text">多个ssh秘钥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0-SSH-key"><span class="toc-text">添加 SSH key</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E6%96%87%E4%BB%B6%E6%B8%85%E7%90%86"><span class="toc-text">大文件清理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%A9%E8%8D%89%E9%99%A4%E6%A0%B9%E5%BC%8F"><span class="toc-text">斩草除根式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%90%E4%B8%AA%E6%94%BB%E7%A0%B4%E5%BC%8F"><span class="toc-text">逐个攻破式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC-%E6%9B%B4%E6%96%B0%E7%9B%AE%E5%BD%95%E7%9A%84%E5%A4%9A%E4%B8%AA%E4%BB%93%E5%BA%93"><span class="toc-text">脚本-更新目录的多个仓库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0%E7%BB%9F%E8%AE%A1"><span class="toc-text">代码行数统计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">Git在工作中的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Git-%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%88%86%E7%B1%BB"><span class="toc-text">Git 工作流分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E7%A7%8D%E7%B1%BB%E8%AF%A6%E8%A7%A3"><span class="toc-text">分支种类详解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E5%88%86%E6%94%AF-feature-%E4%B8%BA%E4%BA%86%E4%B8%8D%E5%BD%B1%E5%93%8D%E8%BE%83%E7%9F%AD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%EF%BC%8C%E4%B8%80%E8%88%AC%E6%8A%8A%E4%B8%AD%E9%95%BF%E6%9C%9F%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9D%97%EF%BC%8C%E4%BC%9A%E4%BB%8E%E5%BC%80%E5%8F%91%E5%88%86%E6%94%AF-%E4%B8%AD%E7%8B%AC%E7%AB%8B%E5%87%BA%E6%9D%A5%E3%80%82-%E5%BC%80%E5%8F%91%E5%AE%8C%E6%88%90%E5%90%8E%E4%BC%9A%E5%90%88%E5%B9%B6%E5%88%B0%E5%BC%80%E5%8F%91%E5%88%86%E6%94%AF%E3%80%82"><span class="toc-text">功能分支 feature: 为了不影响较短周期的开发工作，一般把中长期开发模块，会从开发分支 中独立出来。 开发完成后会合并到开发分支。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Github%E8%B7%A8%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C"><span class="toc-text">Github跨团队协作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">普通开发人员的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%A2%E9%98%9F-leader-%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">团队 leader 的操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9D%9F%E8%AF%AD"><span class="toc-text">结束语</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/p/94e3914c" title="Import 注册组件"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/008.jpg" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Import 注册组件"/></a><div class="content"><a class="title" href="/p/94e3914c" title="Import 注册组件">Import 注册组件</a><time datetime="2024-07-15T22:24:08.000Z" title="发表于 2024-07-15 22:24:08">2024-07-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/a0c53761" title="Configuration Bean 注册组件"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/012.jpg" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Configuration Bean 注册组件"/></a><div class="content"><a class="title" href="/p/a0c53761" title="Configuration Bean 注册组件">Configuration Bean 注册组件</a><time datetime="2024-07-15T21:24:08.000Z" title="发表于 2024-07-15 21:24:08">2024-07-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/65826306" title="Spring5新功能"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/008.jpg" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Spring5新功能"/></a><div class="content"><a class="title" href="/p/65826306" title="Spring5新功能">Spring5新功能</a><time datetime="2024-07-14T17:24:08.000Z" title="发表于 2024-07-14 17:24:08">2024-07-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/40bb048a" title="JdbcTemplate与声明式事务"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/013.jpg" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="JdbcTemplate与声明式事务"/></a><div class="content"><a class="title" href="/p/40bb048a" title="JdbcTemplate与声明式事务">JdbcTemplate与声明式事务</a><time datetime="2024-07-14T11:24:08.000Z" title="发表于 2024-07-14 11:24:08">2024-07-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/92933cdb" title="Spring-AOP编程"><img src= "/medias/detail/load.gif" data-lazy-src="/medias/featureimages/012.jpg" onerror="this.onerror=null;this.src='/medias/detail/404.jpg'" alt="Spring-AOP编程"/></a><div class="content"><a class="title" href="/p/92933cdb" title="Spring-AOP编程">Spring-AOP编程</a><time datetime="2024-07-14T09:24:38.000Z" title="发表于 2024-07-14 09:24:38">2024-07-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 凉月</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://unpkg.com/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.js"></script><script src="https://unpkg.com/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null

  const initWaline = (Fn) => {
    const waline = Fn(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-fulsun.netlify.app/.netlify/functions/comment',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))

    const destroyWaline = () => {
      waline.destroy()
    }

    btf.addGlobalFn('pjax', destroyWaline, 'destroyWaline')
  }

  const loadWaline = async () => {
    if (initFn) initWaline(initFn)
    else {
      await getCSS('https://unpkg.com/@waline/client@3.1.2/dist/waline.css')
      const { init } = await import('https://unpkg.com/@waline/client@3.1.2/dist/waline.js')
      initFn = init || Waline.init
      initWaline(initFn)
      window.walineFn = initFn
    }
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://unpkg.com/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>